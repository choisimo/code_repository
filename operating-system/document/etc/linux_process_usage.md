## 터미널 세션 종료 후에도 프로세스 유지하는 방법

프로세스를 백그라운드에서 계속 실행시키려면 다음 방법들을 사용할 수 있습니다:

### 1. `nohup` + `&` 조합 (가장 간단한 방법)
```bash
nohup your_command &
```
- **특징**:  
  - `nohup`: HUP(Hangup) 시그널 무시
  - `&`: 백그라운드 실행
  - 출력은 `nohup.out` 파일에 저장

### 2. `disown` 사용 (이미 실행중인 프로세스 처리)
```bash
your_command
Ctrl+Z       # 프로세스 일시 정지
bg           # 백그라운드 실행 재개
disown -h %1 # 현재 셸에서 분리
```
- **단계별 동작**:  
  1. `jobs -l`로 작업 번호 확인
  2. `disown -h %작업번호` 실행

### 3. `screen`/`tmux` 사용 (고급 방법)
```bash
screen -S session_name
your_command
Ctrl+A → D   # 세션 분리
```
- **재접속 방법**:  
  ```bash
  screen -r session_name
  ```
- **장점**:  
  - 다중 세션 관리 가능
  - 실행 상태 시각적 확인

### 4. `setsid` 활용 (새 세션에서 실행)
```bash
setsid your_command
```
- **원리**:  
  새로운 세션 ID에서 프로세스 실행

---

## 방법별 비교 표

| 방법 | 장점 | 단점 | 사용 시나리오 |
|------|------|------|---------------|
| `nohup` | 간단한 사용법 | 출력 파일 관리 필요 | 단일 명령어 실행 |
| `disown` | 실행중인 프로세스 처리 | 사전 작업 필요 | 작업 중인 프로세스 유지 |
| `screen` | 세션 관리 용이 | 추가 도구 설치 필요 | 장기적/복잡한 작업 |
| `setsid` | 즉시 실행 가능 | 출력 리다이렉션 필요 | 백그라운드 즉시 실행 |

---

## 프로세스 확인 명령어
```bash
ps aux | grep your_command  # 프로세스 확인
pgrep -f your_command       # PID 확인
lsof -p PID                 # 열린 파일 확인
```

> **중요**: SSH 연결이 끊어져도 프로세스가 계속 실행되려면 **터미널과의 완전한 분리**가 필요합니다. `nohup`이나 `screen`을 사용하면 네트워크 연결 불안정에도 안정적으로 동작합니다. 클라우드 환경에서는 추가로 systemd 서비스 유닛 파일 작성이 권장됩니다.


<hr/>

## 다른 세션에서 프로세스 제어하기

다른 터미널 세션(pts/1)에서 다음과 같이 진행할 수 있습니다:

### 방법 1: 실행 중인 프로세스를 직접 disown 하기

백업 프로세스의 부모 PID는 19282(backup_proc.sh)입니다. 이 프로세스를 disown 하려면:

```bash
kill -SIGTSTP 19282   # TSTP 신호 보내기 (Ctrl+Z와 같은 효과)
kill -SIGCONT 19282   # 프로세스 다시 시작
disown 19282          # 프로세스 disown 처리
```

### 방법 2: 백업 프로세스를 nohup 상태로 전환하기

`nohup` 상태로 직접 전환할 수는 없지만, 기존 프로세스를 종료하지 않고 다시 시작하는 방법이 있습니다:

1. 현재 실행 중인 백업 스크립트의 정확한 명령어를 확인:
   ```bash
   cat /bin/bash ./backup_proc.sh
   ```

2. 백업 스크립트를 종료하고 nohup으로 다시 시작:
   ```bash
   kill 19282
   cd /mnt/nas/files/backup
   nohup ./backup_proc.sh > backup.log 2>&1 &
   ```

### 방법 3: 작업 제어를 통한 disown

백업 프로세스가 현재 세션의 작업으로 관리되고 있다면:

```bash
# 다른 세션(pts/1)에서
kill -STOP 19282
kill -CONT 19282 &
```

이후 원래 세션(pts/0)으로 돌아가면 프로세스가 일시정지됐다가 재개된 상태가 되어, 명령어를 입력할 수 있습니다. 그때 `disown %1` 명령을 실행하면 됩니다.

## PID 기반 disown 적용하기

`disown` 명령어는 작업 ID(%)뿐만 아니라 PID도 직접 사용할 수 있습니다:

```bash
# 다른 세션(pts/1)에서
disown 19282
```

이렇게 하면 해당 프로세스가 현재 세션에서 분리되어, 세션이 종료되어도 계속 실행됩니다.

## 추가 작업: 리디렉션 관리

지속적인 로그 출력으로 인한 문제를 방지하려면, 향후 백업 스크립트 실행 시 출력을 파일로 리디렉션하는 것이 좋습니다:

```bash
nohup ./backup_proc.sh > backup.log 2>&1 &
```

또는 로그 파일을 완전히 무시하려면:

```bash
nohup ./backup_proc.sh > /dev/null 2>&1 &
```

이 명령어들을 사용하면 백업 프로세스가 백그라운드에서 실행되며, 세션이 종료되어도 계속 실행됩니다.


<hr/>

`disown` 명령어 사용 시 나타나는 오류에 대한 문제를 해결해 드리겠습니다.

## 오류 원인 분석

현재 마주한 두 가지 오류 메시지를 살펴보면:

1. `disown 19446` 실행 시: `-bash: disown: 19446: no such job`
2. `sudo disown 19446` 실행 시: `sudo: disown: command not found`

이 오류들은 다음과 같은 이유로 발생합니다:

1. `disown`은 프로세스 ID(PID)가 아닌 **작업 ID(job ID)**를 사용합니다. 작업 ID는 일반적으로 `%1`, `%2`와 같이 `%` 기호로 시작합니다[2][8].
2. `disown`은 독립적인 실행 파일이 아닌 **쉘 내장 명령어**이기 때문에 `sudo`로 실행할 수 없습니다[3][4].

## 해결 방법

### 1. 작업 ID 확인 및 사용

현재 쉘에서 관리하는 작업 목록을 확인하려면:

```bash
jobs -l
```

만약 rsync 작업이 현재 쉘의 작업 목록에 있다면, 해당 작업 번호를 사용하여 disown을 실행합니다:

```bash
disown %작업번호
```

### 2. 간접적인 방법으로 프로세스 분리

작업이 현재 쉘의 작업 목록에 없는 경우(다른 쉘에서 시작된 경우), 다음 방법을 시도해볼 수 있습니다:

```bash
# 프로세스를 일시 중지했다가 백그라운드로 재개
kill -STOP 19446
kill -CONT 19446 &
```

### 3. disown을 사용할 수 없는 이유

`disown`은 다음과 같은 경우에만 사용할 수 있습니다:

1. 현재 쉘 세션에서 시작된 작업에만 적용됩니다[5][6].
2. 작업이 쉘의 작업 테이블에 등록되어 있어야 합니다[8].

해당 프로세스(19446)가 현재 쉘 세션에서 시작되지 않았거나, 백그라운드 작업으로 실행되지 않았다면 `disown`을 사용할 수 없습니다.

### 4. 다른 대안

이미 실행 중인 프로세스를 다음 방법으로 처리할 수 있습니다:

1. **다른 터미널에서 프로세스 종료 후 재시작**:
   ```bash
   kill 19446
   nohup rsync [원래 옵션들] > rsync.log 2>&1 &
   ```

2. **Screen이나 tmux 사용**:
   ```bash
   screen -S backup
   # 원하는 명령어 실행
   # Ctrl+A, D로 detach
   ```

3. **setsid 명령어 사용** (설치 필요할 수 있음):
   ```bash
   setsid rsync [옵션들] > rsync.log 2>&1 &
   ```

## 앞으로 백업 작업을 위한 권장사항

앞으로 장시간 실행되는 백업 작업을 할 때는 처음부터 `nohup`을 사용하는 것이 좋습니다[7][9]:

```bash
nohup ./backup_proc.sh > backup.log 2>&1 &
```

이렇게 하면 세션이 종료되어도 백업 프로세스가 계속 실행되며, 출력은 백업 로그 파일에 저장됩니다.

일반적으로, 장시간 실행되는 작업에는 처음부터 `nohup`이나 `screen`, `tmux`와 같은 도구를 사용하는 것이 가장 안정적인 방법입니다[9][10].
