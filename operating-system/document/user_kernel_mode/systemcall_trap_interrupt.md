## 핵심 개념 정리

### 시스템 콜(System Call)
- 사용자 프로그램이 운영체제 커널의 서비스를 요청하는 프로그래밍 방식
- 파일 읽기/쓰기, 메모리 할당, 프로세스 생성 등 커널의 특권 기능을 사용하기 위한 인터페이스
- 특별한 명령어(trap instruction)를 통해 호출됨
- 사용자 모드에서 커널 모드로 전환되는 방법을 제공[1][9]

### 트랩(Trap)
- 실행 중인 프로그램에서 발생하는 소프트웨어 생성 인터럽트
- 동기적(synchronous) 이벤트: 현재 실행 중인 명령어로 인해 발생
- 원인: 오류(0으로 나누기), 예외(잘못된 메모리 접근), 시스템 콜 요청
- 마스킹(비활성화) 불가능[2][15]

### 인터럽트(Interrupt)
- 하드웨어 장치나 소프트웨어에서 발생하는 신호로, OS가 현재 작업을 중단하고 다른 작업을 처리하도록 요청
- 비동기적(asynchronous) 이벤트: 현재 실행 중인, 명령어와 직접 관련 없이 발생 가능
- 타이머, 키보드, 디스크 등 외부 장치에서 주로 발생
- 마스킹(일시적 비활성화) 가능[3][13]

## 개념 간 관계와 차이점

1. **관계**:
   - 시스템 콜은 트랩을 통해 구현됨
   - 트랩은 소프트웨어 인터럽트의 한 종류
   - 모두 커널로 제어가 전달되는 메커니즘[12][6]

2. **주요 차이점**:
   - **발생 원인**: 시스템 콜은 사용자 프로그램 요청, 트랩은 소프트웨어 오류/요청, 인터럽트는 하드웨어 장치
   - **타이밍**: 시스템 콜과 트랩은 동기적, 인터럽트는 비동기적
   - **마스킹**: 트랩은 마스킹 불가, 인터럽트는 마스킹 가능
   - **처리 목적**: 시스템 콜은 서비스 요청, 트랩은 오류 처리나 서비스 요청, 인터럽트는 외부 이벤트 처리[11][13]

## 처리 메커니즘

모든 경우에 커널은 다음 단계를 수행합니다:

1. 현재 실행 컨텍스트 저장(registers, PC, SP)
2. 커널 모드로 전환하고 해당 핸들러로 제어 전달
3. 요청/이벤트 처리
4. 이전 컨텍스트로 복귀[7][14]

## 자주 틀리는 문제

### 문제 1
트랩과 인터럽트의 관계는 무엇인가?
1. 인터럽트는 서비스 루틴을 가지고, 트랩은 가지지 않는다.
2. 인터럽트는 소프트웨어가 생성한 트랩이다.
3. 트랩은 소프트웨어가 생성한 인터럽트이다.
4. 트랩과 인터럽트는 완전히 다른 개념이다.

### 문제 2
시스템 콜이 구현되는 방식으로 가장 정확한 것은?
1. 하드웨어 인터럽트를 통해 구현된다.
2. 특별한 명령어를 실행하여 트랩을 발생시킨다.
3. 커널 모드와 사용자 모드 간에 직접 전환한다.
4. 메모리 주소를 직접 접근하여 커널 함수를 호출한다.

### 문제 3
트랩과 인터럽트의 핵심적인 차이점은?
1. 트랩은 하드웨어에서, 인터럽트는 소프트웨어에서 발생한다.
2. 트랩은 동기적이고, 인터럽트는 비동기적이다.
3. 트랩은 오류만 처리하고, 인터럽트는 모든 이벤트를 처리한다.
4. 트랩은 사용자 모드에서만 발생하고, 인터럽트는 커널 모드에서만 발생한다.

### 문제 4
다음 중 트랩의 예로 가장 적절한 것은?
1. 타이머 인터럽트
2. 키보드 입력
3. 0으로 나누기 예외
4. 디스크 읽기 완료 신호

### 문제 5
커널 레벨 스레드 간의 컨텍스트 스위칭 중 커널이 수행하는 작업은?
1. 현재 스레드의 상태만 저장한다.
2. 현재 스레드의 상태를 저장하고 새 스레드의 상태를 복원한다.
3. 인터럽트를 비활성화하고 사용자 모드로 전환한다.
4. 항상 모든 프로세스의 주소 공간을 변경한다.

## 추가 연습 문제

### 문제 6
시스템 콜과 일반 함수 호출의 차이점은 무엇인가?

### 문제 7
x86 아키텍처에서 트랩 게이트(trap gate)와 인터럽트 게이트(interrupt gate)의 차이는?

### 문제 8
인터럽트 처리 중에 또 다른 인터럽트가 발생하면 어떻게 되는가?

### 문제 9
사용자 프로그램이 직접 I/O 장치에 접근하지 못하고 시스템 콜을 사용해야 하는 이유는?

### 문제 10
하나의 프로세스가 fork()를 호출하여 자식 프로세스를 생성할 때, 어떤 시스템 콜이 사용되고, 트랩이나 인터럽트는 어떻게 관여하는가?

## 답변 및 해설

### 문제 1 정답: 3
트랩은 소프트웨어가 생성한 인터럽트입니다. 트랩은 현재 실행 중인, 코드로 인해 발생하는 동기적 이벤트이며, 시스템 콜이나 예외 상황에서 발생합니다.[10][12]

### 문제 2 정답: 2
시스템 콜은 특별한 명령어(예: x86의 'int 0x80' 또는 'syscall')를 실행하여 트랩을 발생시키는 방식으로 구현됩니다. 이 트랩으로 인해 CPU는 사용자 모드에서 커널 모드로 전환하고 커널의 시스템 콜 핸들러로 제어가 넘어갑니다.[1][6]

### 문제 3 정답: 2
트랩은 동기적(현재 실행 중인 명령어로 인해 발생)이고, 인터럽트는 비동기적(현재 실행 중인 명령어와 관계없이 발생)입니다. 이것이 두 개념의 가장 중요한 차이점입니다.[13][15]

### 문제 4 정답: 3
0으로 나누기 예외는 현재 실행 중인 명령어(나눗셈 연산)로 인해 발생하는 동기적 이벤트이므로 트랩의 예입니다. 나머지 보기는 모두 외부 하드웨어에서 발생하는 비동기적 인터럽트입니다.[2][10]

### 문제 5 정답: 2
커널 레벨 스레드 간의 컨텍스트 스위칭 중 커널은 현재 스레드의 상태(레지스터, 프로그램 카운터 등)를 저장하고, 새로운 스레드의 상태를 복원합니다. 필요한 경우 주소 공간도 변경합니다.[7]

### 문제 6 해설
시스템 콜은 사용자 모드에서 커널 모드로의 전환을 요구하며, 운영체제 커널의 서비스를 요청합니다. 반면, 일반 함수 호출은 같은 권한 수준에서 실행되며 모드 전환이 필요하지 않습니다. 시스템 콜은 특별한 트랩 명령어를 통해 이루어지고, 커널의 제어를 받습니다.[1][9]

### 문제 7 해설
x86 아키텍처에서 트랩 게이트와 인터럽트 게이트의 주요 차이점은 인터럽트 플래그(IF) 처리입니다. 인터럽트 게이트는 핸들러 실행 전에 인터럽트를 비활성화(IF=0)하지만, 트랩 게이트는 인터럽트 상태를 변경하지 않습니다. 따라서 트랩 게이트를 통한 시스템 콜 처리 중에도 다른 인터럽트가 발생할 수 있습니다.[4][5]

### 문제 8 해설
인터럽트 처리 중에 다른 인터럽트가 발생하면, 현재 처리 중인 인터럽트의 우선순위와 새로운 인터럽트의 우선순위를 비교합니다. 새 인터럽트의 우선순위가 높으면 현재 인터럽트 처리를 일시 중단하고 새 인터럽트를 처리합니다(중첩 인터럽트). 그러나 많은 시스템에서는 인터럽트 핸들러가 실행되는 동안 같은 수준 또는 낮은 우선순위의 인터럽트를 마스킹(비활성화)합니다.[3][15]

### 문제 9 해설
사용자 프로그램이 직접 I/O 장치에 접근하지 못하는 이유는 보안과 자원 관리 때문입니다. 운영체제는 권한 분리를 통해 하드웨어를 보호하고, 여러 프로세스가 공유 자원을 안전하게 사용할 수 있도록 합니다. 시스템 콜은 검증된 인터페이스를 제공하여 사용자 프로그램이 커널의 중재를 통해 하드웨어 자원에 접근할 수 있게 합니다.[9][15]

### 문제 10 해설
fork() 호출 시, 프로세스는 'fork' 시스템 콜을 호출합니다. 이는 트랩 명령어를 실행하여 사용자 모드에서 커널 모드로 전환합니다. 커널은 새 프로세스를 생성하고 부모 프로세스의 메모리를 복사합니다. 이 과정에서 하드웨어 인터럽트가 발생할 수 있지만(예: 타이머 인터럽트), fork() 자체는 트랩을, 통해 구현됩니다. 작업이 완료되면 부모와 자식 프로세스 모두 사용자 모드로 돌아갑니다.[1][7][9]
