# 6번 주제: 파일 시스템 관리 문제

## 문제 1
파일의 정의와 특성을 설명하고, 파일 시스템이 운영체제에서 수행하는 주요 기능을 설명하시오.

**답변:**
파일은 생성자에 의해 정의된 관련 정보의 모음입니다. 일반적으로 프로그램(소스 및 목적 파일)과 데이터를 나타내며, 숫자, 문자, 이진 형태 등 다양한 형식을 가질 수 있습니다. 파일은 구조화되지 않은 자유 형식(예: 텍스트 파일)이거나 고정된 형식(예: MP3 음악 파일)일 수 있습니다.

파일 시스템의 주요 기능:
- 파일 생성 및 삭제
- 디렉토리 생성 및 삭제를 통한 파일 구성
- 파일과 디렉토리 조작을 위한 기본 기능 제공
- 파일을 대용량 저장장치에 매핑
- 안정적인 비휘발성 저장 매체에 파일 백업
- 파일 접근 제어 및 보호 기능 제공

**해설:**
파일 시스템은 사용자에게 저장 장치의 물리적 특성을 추상화하여 일관된 논리적 관점을 제공합니다. 운영체제는 대용량 저장 장치와 이를 제어하는 장치를 관리하여 파일이라는 추상적 개념을 구현합니다. 파일 시스템은 다양한 저장 장치(하드 디스크, SSD, 클라우드 스토리지 등)에 데이터를 체계적으로 저장하고 검색할 수 있게 해주며, 사용자와 애플리케이션이 데이터에 쉽게 접근하고 관리할 수 있도록 합니다. 여러 사용자 환경에서는 파일에 대한 접근 제어도 중요한 기능입니다.

## 문제 2
파일 접근 방식의 주요 유형(순차 접근, 직접 접근, 색인 접근)을 비교 설명하고, 각 방식이 적합한 애플리케이션 사례를 제시하시오.

**답변:**
파일 접근 방식의 주요 유형:

1. 순차 접근(Sequential Access):
   - 특징: 파일의 처음부터 시작하여 레코드를 순서대로 읽거나 씀
   - 장점: 구현 간단, 테이프와 같은 순차적 매체에 적합
   - 단점: 임의 위치 접근에 시간 소요, 이전 레코드를 모두 거쳐야 함
   - 적합한 사례: 로그 파일, 일괄 처리 시스템, 텍스트 파일 처리

2. 직접 접근(Direct Access):
   - 특징: 파일 내 임의 위치에 직접 접근 가능
   - 장점: 빠른 레코드 검색, 임의 순서로 레코드 읽기/쓰기 가능
   - 단점: 구현 복잡, 적절한 인덱싱 필요
   - 적합한 사례: 데이터베이스, 디스크 기반 파일 시스템, 게임 세이브 파일

3. 색인 접근(Indexed Access):
   - 특징: 색인을 사용하여 레코드 위치 파악 후 직접 접근
   - 장점: 효율적인 검색, 복잡한 쿼리 지원
   - 단점: 인덱스 유지 관리 오버헤드, 추가 저장 공간 필요
   - 적합한 사례: 관계형 데이터베이스, 이메일 서버, 라이브러리 카탈로그

**해설:**
파일 접근 방식은 데이터 특성과 사용 패턴에 따라 선택되며, 저장 매체의 물리적 특성과도 밀접한 관련이 있습니다. 순차 접근은 가장 단순하지만 제한적인 방식으로, 모든 데이터를 처음부터 끝까지 순서대로 처리해야 할 때 사용됩니다. 직접 접근은 하드 디스크나 SSD와 같은 임의 접근 장치의 장점을 활용하여 파일 내 어느 위치든 빠르게 접근할 수 있게 합니다. 색인 접근은 직접 접근의 확장으로, 별도의 인덱스 구조를 통해 더 효율적인 검색이 가능합니다. 현대 파일 시스템과 데이터베이스는 이러한 접근 방식을 조합하여 다양한 사용 사례에 최적화된 성능을 제공합니다.

## 문제 3
디렉토리 구조의 다양한 유형(단일 레벨, 2단계, 트리 구조, 비순환 그래프, 일반 그래프)을 비교 설명하고, 각 구조의 장단점을 논하시오.

**답변:**
디렉토리 구조의 다양한 유형:

1. 단일 레벨 디렉토리(Single-Level Directory):
   - 특징: 모든 파일이 하나의 디렉토리에 존재
   - 장점: 구현 간단, 파일 검색 용이
   - 단점: 파일 수가 많아지면 관리 어려움, 이름 충돌 문제, 다중 사용자 환경에 부적합
   
2. 2단계 디렉토리(Two-Level Directory):
   - 특징: 각 사용자별로 별도 디렉토리 제공
   - 장점: 사용자 간 파일 분리, 이름 충돌 감소
   - 단점: 사용자 간 파일 공유 어려움, 깊은 구조화 불가능

3. 트리 구조 디렉토리(Tree-Structured Directory):
   - 특징: 계층적 구조, 디렉토리가 다른 디렉토리 포함 가능
   - 장점: 효율적인 파일 구성, 그룹화 및 카테고리화 용이
   - 단점: 깊은 디렉토리 탐색 시간 증가, 파일 경로 복잡성

4. 비순환 그래프 디렉토리(Acyclic-Graph Directory):
   - 특징: 트리 구조에 링크(바로가기) 개념 추가, 순환 없음
   - 장점: 파일 공유 가능, 동일 파일에 다중 경로 제공
   - 단점: 파일 삭제 시 링크 관리 복잡, 가비지 컬렉션 필요

5. 일반 그래프 디렉토리(General Graph Directory):
   - 특징: 순환 참조 허용된 그래프 구조
   - 장점: 최대한의 유연성 제공, 복잡한 관계 표현 가능
   - 단점: 순환 참조로 인한 무한 루프 위험, 시스템 복잡도 증가

**해설:**
디렉토리 구조는 파일 시스템이 파일을 조직하고 관리하는 방식을 결정합니다. 초기 컴퓨터 시스템은 단일 레벨 구조를 사용했지만, 파일 수가 증가하고 다중 사용자 환경이 등장하면서 더 복잡한 구조가 필요해졌습니다. 현대 운영체제는 대부분 트리 구조나 비순환 그래프 디렉토리를 채택하고 있으며, 이는 계층적 구성과 파일 공유를 동시에 지원합니다. 

트리 구조는 직관적이고 관리가 용이하지만, 동일 파일을 여러 위치에서 접근해야 할 때 제한적입니다. 비순환 그래프는 링크(UNIX의 심볼릭 링크, Windows의 바로가기)를 통해 이 문제를 해결하지만, 링크 관리와 파일 삭제 시 일관성 유지가 복잡해집니다. 일반 그래프는 가장 유연하지만, 순환 참조로 인한 문제가 발생할 수 있어 대부분의 파일 시스템은 이를 제한하거나 특별한 메커니즘으로 관리합니다.

## 문제 4
파일 시스템 구현에서 사용되는 주요 할당 방법(연속 할당, 연결 할당, 색인 할당)을 비교 설명하고, 각 방법의 장단점을 논하시오.

**답변:**
파일 시스템의 주요 할당 방법:

1. 연속 할당(Contiguous Allocation):
   - 특징: 파일의 모든 블록이 디스크에 연속적으로 배치
   - 장점: 구현 간단, 순차적 접근 성능 우수, 직접 접근 용이
   - 단점: 외부 단편화 발생, 파일 크기 변경 어려움, 초기에 파일 크기 예측 필요
   - 적합한 환경: CD-ROM과 같은 읽기 전용 매체, 고정 크기 파일 시스템

2. 연결 할당(Linked Allocation):
   - 특징: 각 블록이 다음 블록의 포인터를 포함하는 연결 리스트 구조
   - 장점: 외부 단편화 없음, 파일 크기 동적 확장 용이
   - 단점: 직접 접근 성능 저하, 포인터 저장 공간 오버헤드, 신뢰성 문제(포인터 손상)
   - 적합한 환경: 순차적 접근이 주로 필요한 시스템, 파일 크기가 자주 변하는 환경

3. 색인 할당(Indexed Allocation):
   - 특징: 인덱스 블록이 모든 포인터를 저장하여 파일 블록 위치 관리
   - 장점: 직접 접근 지원, 외부 단편화 없음, 파일 크기 동적 변경 가능
   - 단점: 인덱스 블록 저장 공간 오버헤드, 작은 파일에 비효율적, 대형 파일 지원 위한 추가 구조 필요
   - 적합한 환경: 직접 접근과 순차 접근이 모두 필요한 범용 파일 시스템

**해설:**
파일 할당 방법의 선택은 파일 시스템의 성능, 공간 효율성, 지원하는 파일 접근 방식에 직접적인 영향을 미칩니다. 연속 할당은 구현이 간단하고 성능이 좋지만, 동적 환경에서 외부 단편화와 크기 변경 문제가 있습니다. 연결 할당은 단편화 문제를 해결하지만, 직접 접근 성능이 저하되고 신뢰성 문제가 있습니다. 

색인 할당은 두 방식의 단점을 보완하지만, 추가 저장 공간이 필요합니다. 대부분의 현대 파일 시스템은 색인 할당의 변형을 기본으로 사용하며, 종종, 다중 레벨 인덱싱, 결합 스키마 등 복합적인 접근법을 채택합니다. 예를 들어, UNIX의 inode 시스템은 직접, 간접, 이중 간접, 삼중 간접 블록 포인터를 혼합해 사용하며, NTFS는 마스터 파일 테이블(MFT)과 실행 목록(run list)을 사용하여 효율적인 할당을 구현합니다.

## 문제 5
파일 보호 메커니즘의 종류와 구현 방식을 설명하고, 접근 제어 목록(ACL)과 기능 기반 접근 제어의 차이점을 비교하시오.

**답변:**
파일 보호 메커니즘의 종류와 구현 방식:

1. 유형별 보호(Type-Based Protection):
   - 구현: 파일 유형에 따라 허용되는 연산 제한(예: 실행 파일은 실행만 허용)
   - 장점: 간단한 구현, 명확한 의미론적 보호
   - 단점: 세밀한 제어 부족, 사용자별 차별화 어려움

2. 패스워드/암호 보호(Password Protection):
   - 구현: 파일마다 암호 설정, 접근 시 암호 검증
   - 장점: 이해하기 쉬움, 특정 파일의 집중 보호에 적합
   - 단점: 암호 관리 복잡, 공유 어려움, 암호 기억 부담

3. 사용자 기반 보호(User-Based Protection):
   - 구현: 소유자/그룹/기타 사용자별 권한 설정(UNIX 권한 비트)
   - 장점: 직관적인 권한 관리, 효율적인 검사
   - 단점: 제한된 그룹 정의, 특정 사용자 지정 어려움

4. 접근 제어 목록(Access Control Lists, ACL):
   - 구현: 각 파일마다 사용자/그룹별 권한 목록 관리
   - 장점: 세밀한 접근 제어, 유연한 권한 설정
   - 단점: 저장 공간 오버헤드, 권한 검사 오버헤드

5. 기능 기반 접근 제어(Capability-Based Access Control):
   - 구현: 사용자가 기능(capability) 토큰을 소유, 토큰 제시로 접근 허용
   - 장점: 권한 위임 용이, 최소 권한 원칙 적용 쉬움
   - 단점: 기능 관리 복잡, 취소 메커니즘 구현 어려움

ACL과 기능 기반 접근 제어 비교:

| 특성 | 접근 제어 목록(ACL) | 기능 기반 접근 제어 |
|------|-------------------|------------------|
| 관리 주체 | 객체(파일) 중심 | 주체(사용자) 중심 |
| 권한 검사 | "이 파일에 누가 접근할 수 있는가?" | "이 사용자가 어떤 파일에 접근할 수 있는가?" |
| 권한 저장 | 파일과 함께 저장 | 사용자와 함께 저장 |
| 위임 용이성 | 관리자 개입 필요 | 직접 위임 가능 |
| 취소 용이성 | 쉬움(ACL 수정) | 어려움(모든 기능 토큰 추적 필요) |
| 검사 오버헤드 | 접근 시마다 목록 검사 | 기능 검증만 수행 |

**해설:**
파일 보호는 다중 사용자 환경에서 데이터 기밀성과 무결성을 유지하는 핵심 메커니즘입니다. 초기 시스템에서는 단순한 패스워드 보호나 유형별 제한을 사용했지만, 현대 운영체제는 더 정교한 접근 제어 시스템을 구현합니다.

UNIX/Linux 시스템은 전통적으로 사용자-그룹-기타 사용자(rwx) 권한 모델을 사용하며, 이는 간단하지만 제한적입니다. 이를 확장한 ACL은 각 파일에 대해 더 세밀한 권한 제어를 제공하지만, 관리 복잡성과 성능 오버헤드가 있습니다.

기능 기반 접근 제어는 ACL과 철학적으로 다른 접근법으로, 사용자가 "기능" 또는 "접근 토큰"을 소유하고 이를 제시하여 리소스에 접근합니다. 이는 권한 위임이 용이하고 최소 권한 원칙을 적용하기 쉽지만, 토큰 관리와 취소가 복잡합니다.

현대 시스템은 종종 이러한 접근법을 혼합하여 사용합니다. 예를 들어, Windows NTFS는 기본 ACL과 함께 혁신적인 보안 설명자를 사용하며, 일부 운영체제는 역할 기반 접근 제어(RBAC)나 강제 접근 제어(MAC) 등 추가적인 모델도 지원합니다.

## 문제 6
파일 시스템 마운팅(mounting)의 개념과 과정을 설명하고, 가상 파일 시스템(VFS)이 다양한 파일 시스템 유형을 지원하는 방식을 설명하시오.

**답변:**
파일 시스템 마운팅 개념과 과정:

마운팅은 특정 저장 장치의 파일 시스템을 운영체제의 디렉토리 트리에 연결하는 과정입니다. 이를 통해 다양한 물리적 장치와 파일 시스템 유형을 하나의 통합된 디렉토리 구조로 접근할 수 있게 됩니다.

마운팅 과정:
1. 마운트 요청: 사용자나 시스템이 특정 장치를 마운트 지점에 연결 요청
2. 파일 시스템 인식: 운영체제가 장치의 파일 시스템 유형 식별
3. 슈퍼블록 로드: 파일 시스템의 메타데이터 구조(슈퍼블록) 메모리에 로드
4. 디렉토리 연결: 마운트 지점을 파일 시스템의 루트 디렉토리에 연결
5. 디렉토리 트리 확장: 마운트된 파일 시스템이 전체 디렉토리 트리의 일부가 됨

가상 파일 시스템(VFS)의 작동 방식:

VFS는 서로 다른 파일 시스템 유형에 대한 통합 인터페이스를 제공하는 추상화 계층입니다. 이를 통해 애플리케이션이 파일 시스템 유형에 관계없이 동일한 시스템 호출을 사용할 수 있습니다.

주요 특징:
1. 공통 인터페이스: 모든 파일 시스템에 공통으로 적용되는 연산 정의
2. 객체 지향 구조: 파일, 디렉토리, 아이노드 등을 객체로 추상화
3. 파일 시스템 등록 메커니즘: 새로운 파일 시스템 유형을 등록하고 관리
4. 연산 디스패치: 특정 파일 시스템 구현으로 요청 전달

작동 방식:
1. 애플리케이션이 표준 파일 시스템 호출 실행(open, read, write 등)
2. VFS가 호출을 가로채서 어떤 파일 시스템이 관련되었는지 확인
3. 해당 파일 시스템에 맞는 구체적인 구현 함수로 요청 변환
4. 파일 시스템별 코드가 실제 저장 장치에서 작업 수행
5. 결과를 VFS를 통해 애플리케이션에 반환

**해설:**
파일 시스템 마운팅은 다양한 저장 장치와 파일 시스템을 통합된 방식으로 사용할 수 있게 하는 핵심 메커니즘입니다. UNIX 계열 시스템에서는 mount 명령을, Windows에서는 드라이브 문자 할당이나 폴더 마운트를 사용합니다. 마운팅을 통해 사용자는 물리적 장치의 경계를 의식하지 않고 파일에 접근할 수 있습니다.

가상 파일 시스템(VFS)은 현대 운영체제의 중요한 구성 요소로, 파일 시스템 다양성 문제를 해결합니다. Linux의 VFS는 ext4, XFS, Btrfs 등 다양한 네이티브 파일 시스템과 NTFS, FAT32 같은 외부 파일 시스템, 그리고 procfs, sysfs와 같은 특수 가상 파일 시스템까지 통합합니다.

VFS는 객체 지향적 설계를 통해 각 파일 시스템이 구현해야 하는 표준 인터페이스(파일 열기, 읽기, 쓰기 등)를 정의합니다. 새로운 파일 시스템을 추가할 때는 이 인터페이스에 맞는 함수들을 구현하기만 하면 됩니다. 이러한 설계 덕분에 운영체제는 파일 시스템 지원을 쉽게 확장할 수 있으며, 애플리케이션은 기반 파일 시스템을 의식하지 않고 일관된 방식으로 파일에 접근할 수 있습니다.

## 문제 7
저널링 파일 시스템(Journaling File System)의 개념과 작동 원리를 설명하고, 비저널링 파일 시스템과 비교하여 장단점을 논하시오.

**답변:**
저널링 파일 시스템의 개념과 작동 원리:

저널링 파일 시스템은 시스템 충돌이나 전원 장애 발생 시 파일 시스템의 무결성을 보호하기 위해 변경 사항을 미리 저널(로그)에 기록하는 방식입니다. 이를 통해 비정상 종료 후 빠르고 안정적인 복구가 가능합니다.

작동 원리:
1. 트랜잭션 시작: 파일 시스템 변경 작업 시작 전 트랜잭션 생성
2. 저널 기록: 수행할 변경 사항을 저널 영역에 먼저 기록(로깅)
3. 저널 커밋: 저널 기록이 완료되었음을 표시하는 커밋 기록
4. 실제 변경 적용: 파일 시스템에 실제 변경 사항 적용
5. 트랜잭션 완료: 변경이 완전히 적용되면 트랜잭션 완료 표시

저널링 수준:
- 메타데이터 저널링: 파일 시스템 구조 정보만 저널에 기록
- 전체 데이터 저널링: 메타데이터와 파일 내용 모두 저널에 기록

저널링 vs 비저널링 파일 시스템 비교:

| 특성 | 저널링 파일 시스템 | 비저널링 파일 시스템 |
|------|-------------------|-------------------|
| 복구 속도 | 빠름 (저널 기반 복구) | 느림 (전체 검사 필요) |
| 데이터 안전성 | 높음 (특히 전체 데이터 저널링) | 낮음 (충돌 시 손상 위험) |
| 성능 오버헤드 | 있음 (이중 쓰기 발생) | 없음 (직접 쓰기) |
| 디스크 수명 | 추가 쓰기로 인한 영향 | 상대적으로 적은 쓰기 횟수 |
| 구현 복잡성 | 높음 | 낮음 |

장점:
- 시스템 충돌 후 빠른 복구 (fsck 과정 최소화)
- 데이터 일관성 향상
- 복잡한 트랜잭션 지원 가능

단점:
- 성능 오버헤드 (특히 전체 데이터 저널링)
- 추가적인 디스크 공간 필요
- 쓰기 작업 증가로 SSD 수명에 영향 가능

**해설:**
저널링 파일 시스템은 데이터베이스의 트랜잭션 로깅 개념을 파일 시스템에 적용한 것으로, 시스템 장애 발생 시 파일 시스템 복구 과정을 크게 개선합니다. 전통적인 비저널링 파일 시스템은 충돌 후 전체 파일 시스템을 검사(fsck)해야 하므로, 대용량 저장 장치에서는 복구에 수 시간이 걸릴 수 있습니다.

대표적인 저널링 파일 시스템으로는 Linux의 ext3/ext4, XFS, 및 JFS, Windows의 NTFS, macOS의 APFS 등이 있습니다. 이들은 일반적으로 메타데이터만 저널링하는 방식을 기본으로 채택하여 성능과 안정성 사이의 균형을 맞춥니다.

저널링은 추가적인 쓰기 작업을 발생시키므로 이론적으로는 성능 저하를 가져올 수 있지만, 현대 저장 장치의 속도와 최적화된 구현으로 실제 체감 성능 차이는 크지 않습니다. 오히려 시스템 안정성과 신뢰성 향상 효과가 더 중요하게 여겨져, 대부분의 현대 파일 시스템은 기본적으로 저널링을 지원합니다.

최근에는 저널링을 넘어 CoW(Copy-on-Write)나 로그 구조화된 파일 시스템(Log-structured File System) 등 더 발전된 일관성 보장 방식이 등장하고 있습니다.

## 문제 8
분산 파일 시스템(Distributed File System)의 개념과 주요 설계 목표를 설명하고, 네트워크 파일 시스템(NFS)과 앤드류 파일 시스템(AFS)의 차이점을 비교하시오.

**답변:**
분산 파일 시스템의 개념과 설계 목표:

분산 파일 시스템은 네트워크로 연결된 여러 컴퓨터에 저장된 파일을 마치 로컬 파일처럼 투명하게 접근하고 관리할 수 있게 해주는 파일 시스템입니다. 사용자와 애플리케이션은 파일의 물리적 위치나 복제 여부를 의식하지 않고 일관된 방식으로 파일에 접근할 수 있습니다.

주요 설계 목표:
1. 투명성(Transparency): 위치, 접근, 복제, 장애 등 다양한 측면에서 투명한 접근 제공
2. 확장성(Scalability): 사용자, 파일, 서버 수의 증가에 효율적으로 대응
3. 내결함성(Fault Tolerance): 서버 장애에도 서비스 계속 제공
4. 일관성(Consistency): 여러 사용자가 동시에 접근할 때 데이터 일관성 보장
5. 보안(Security): 인증, 권한 부여, 데이터 보호 등 제공
6. 성능(Performance): 로컬 파일 시스템에 준하는 성능 제공

NFS와 AFS 비교:

| 특성 | 네트워크 파일 시스템(NFS) | 앤드류 파일 시스템(AFS) |
|------|--------------------------|------------------------|
| 아키텍처 | 클라이언트-서버 모델 | 분산된 셀 기반 모델 |
| 캐싱 방식 | 제한적 클라이언트 캐싱 | 강력한 클라이언트 캐싱 중심 |
| 일관성 모델 | 느슨한 일관성(서버 중심) | 콜백 기반 일관성 관리 |
| 확장성 | 제한적 (서버 중심) | 높음 (셀 구조로 확장) |
| 인증 | 기본적 인증 (AUTH_SYS) | Kerberos 기반 강력한 인증 |
| 복제 지원 | 제한적 | 내장된 복제 기능 |
| 오프라인 작업 | 제한적 지원 | 적극적 지원 |
| 성능 특성 | 단일 서버에 의존, 네트워크 트래픽 많음 | 로컬 캐싱으로 네트워크 트래픽 감소 |
| 구현 복잡성 | 상대적으로 단순 | 복잡함 |

**해설:**
분산 파일 시스템은 오늘날 기업 환경, 클라우드 컴퓨팅, 대규모 데이터 센터에서 핵심적인 역할을 합니다. 이러한 시스템은 데이터 접근성, 가용성, 확장성을 높이면서도 관리를 간소화합니다.

NFS(Network File System)는 Sun Microsystems에서 개발한 가장 오래되고 널리 사용되는 분산 파일 시스템 중 하나입니다. NFS는 비교적 단순한 클라이언트-서버 모델을 사용하며, UNIX 계열 시스템 간의 파일 공유에 최적화되어 있습니다. NFS는 네트워크 지연 시간에 민감하고 대규모 확장에 제한이 있지만, 구현이 간단하고 다양한 플랫폼에서 지원됩니다.

AFS(Andrew File System)는 카네기 멜론 대학에서 개발되었으며, 대규모 환경을 위해 설계되었습니다. AFS는 강력한 클라이언트 캐싱, 셀 기반 구조, 콜백 메커니즘을 통한 일관성 관리 등 혁신적인 기능을 도입하여 확장성과 성능을 크게 개선했습니다. 특히 WAN 환경에서 효율적이며, 오프라인 작업과 강력한 보안 기능을 제공합니다.

현대 분산 파일 시스템은 이 두 시스템의 개념을 기반으로 발전했으며, Google의 GFS(Google File System), Hadoop의 HDFS(Hadoop Distributed File System), Ceph와 같은 시스템은 클라우드 환경과 대규모 데이터 처리에 최적화된 새로운 접근 방식을 도입했습니다.

## 문제 9
디스크 스케줄링 알고리즘(FCFS, SSTF, SCAN, C-SCAN, LOOK)을 비교 설명하고, 각 알고리즘의 장단점과 적합한 사용 환경을 논하시오.

**답변:**
디스크 스케줄링 알고리즘 비교:

1. FCFS(First-Come, First-Served):
   - 작동 방식: 요청이 도착한 순서대로 처리
   - 장점: 구현 간단, 공정성 보장
   - 단점: 디스크 헤드 이동 최적화 없음, 평균 탐색 시간 증가
   - 적합한 환경: 부하가 적은 시스템, 요청이 균일하게 분포된 경우

2. SSTF(Shortest Seek Time First):
   - 작동 방식: 현재 위치에서 가장 가까운 요청 먼저 처리
   - 장점: 평균 탐색 시간 감소, 처리량 증가
   - 단점: 기아 상태 발생 가능, 원거리 요청 지연
   - 적합한 환경: 높은 처리량이 필요한 시스템

3. SCAN(Elevator):
   - 작동 방식: 디스크 한쪽 끝에서 다른 쪽 끝으로 이동하며 요청 처리, 방향 전환
   - 장점: 기아 방지, 합리적인 탐색 시간, 높은 처리량
   - 단점: 디스크 끝단 부근 대기 시간 길어질 수 있음
   - 적합한 환경: 부하가 많고 요청이 전체 디스크에 고르게 분포된 경우

4. C-SCAN(Circular SCAN):
   - 작동 방식: 한쪽 방향으로만 이동하며 요청 처리, 끝에 도달하면 반대쪽 끝으로 이동
   - 장점: 균일한 대기 시간, SCAN보다 공정한 서비스
   - 단점: 빈 공간 탐색으로 인한 추가 이동
   - 적합한 환경: 요청이 디스크 전체에 균일하게 분포된 다중 사용자 환경

5. LOOK/C-LOOK:
   - 작동 방식: SCAN/C-SCAN과 유사하나 요청이 없는 방향으로는 이동하지 않음
   - 장점: SCAN의 장점 유지하면서 불필요한 이동 제거
   - 단점: 구현 복잡성 증가
   - 적합한 환경: 부하가 크고 요청 패턴 예측이 가능한 경우

디스크 스케줄링 알고리즘 선택 고려 요소:
- 평균 응답 시간: 개별 요청의 평균 대기 시간
- 처리량: 단위 시간당 처리할 수 있는 요청 수
- 공정성: 모든 요청이 합리적인 시간 내에 처리되는지
- 구현 복잡성: 알고리즘 구현 및 유지보수의 어려움
- 워크로드 특성: 요청 패턴의 분포 및 빈도

**해설:**
디스크 스케줄링 알고리즘은 파일 시스템 성능에 중요한 영향을 미칩니다. 전통적인 하드 디스크 드라이브(HDD)에서는 물리적 디스크 헤드 이동(탐색)이 가장 큰 병목이었기 때문에, 이를 최소화하는 것이 중요했습니다.

FCFS는 가장 단순하지만 최악의 성능을 보일 수 있으며, SSTF는 지역성 원리를 활용하여 성능을 향상시키지만 기아 문제가 있습니다. SCAN(일명 엘리베이터 알고리즘)은 이러한 단점을 보완하여 균형 잡힌 성능을 제공하며, C-SCAN은 방향성 공정성을 개선합니다. LOOK과 C-LOOK은 SCAN과 C-SCAN의 변형으로, 실제 구현에서 더 효율적입니다.

현대 SSD(Solid State Drive)에서는 물리적 탐색 시간이 없어 이러한 알고리즘의 중요성이 감소했지만, 여전히 I/O 스케줄링 원칙은 중요합니다. 특히 SSD의 특성(예: 쓰기 증폭, 웨어 레벨링)을 고려한 새로운 스케줄링 방식이 개발되었습니다.

실제 운영체제에서는 이러한 기본 알고리즘을 변형하거나 하이브리드 방식을 사용하며, Linux의 CFQ(Completely Fair Queuing), Deadline, NOOP 스케줄러와 같은 고급 스케줄링 알고리즘을 제공합니다. 최신 시스템에서는 워크로드 특성을 동적으로 분석하여 적응적으로 스케줄링 정책을 변경하는 방식도 도입되고 있습니다.

## 문제 10
파일 시스템 성능 최적화 기법(버퍼링, 캐싱, 블록 미리 읽기, 지연 쓰기)을 설명하고, 이러한 기법들이 파일 시스템 성능에 어떤 영향을 미치는지 설명하시오.

**답변:**
파일 시스템 성능 최적화 기법:

1. 버퍼링(Buffering):
   - 개념: 디스크와 애플리케이션 간의 데이터 전송을 위한 중간 메모리 영역 사용
   - 구현: 시스템 메모리에 입출력 버퍼 할당
   - 효과: 데이터 전송 크기 최적화, 애플리케이션과 디스크의 속도 차이 완화
   - 성능 영향: 작은 I/O 요청 병합으로 디스크 접근 횟수 감소, CPU와 I/O 작업 병렬화

2. 캐싱(Caching):
   - 개념: 자주 접근하는 디스크 데이터를 메모리에 유지
   - 구현: 페이지 캐시, 버퍼 캐시, 다이노드/아이노드 캐시 등
   - 효과: 디스크 읽기 작업 감소, 접근 지연시간 단축
   - 성능 영향: 캐시 히트 시 디스크 접근 회피로 수백~수천 배 성능 향상

3. 블록 미리 읽기(Read-ahead):
   - 개념: 요청된 데이터 이상으로 추가 데이터를 미리 읽어 캐시에 저장
   - 구현: 순차적 접근 패턴 감지 시 미리 읽기 크기 동적 조정
   - 효과: 순차적 파일 접근 성능 향상, 지역성 원리 활용
   - 성능 영향: 순차 읽기 작업에서 2-10배 처리량 향상, 랜덤 접근에는 효과 제한적

4. 지연 쓰기(Delayed Write):
   - 개념: 디스크 쓰기 작업을 즉시 수행하지 않고 캐시에 유지 후 나중에 일괄 처리
   - 구현: 더티 페이지(수정된 페이지) 관리, 주기적 동기화, fsync() 지원
   - 효과: 쓰기 작업 최적화, 다수의 작은 쓰기 작업 병합
   - 성능 영향: 쓰기 처리량 대폭 향상, 응답 시간 감소, 디스크 수명 연장

5. 파일 시스템 저널링:
   - 개념: 변경 사항을 먼저 저널에 기록 후 실제 적용
   - 구현: 트랜잭션 로그 관리, 메타데이터 또는 데이터 저널링
   - 효과: 시스템 충돌 후 빠른 복구, 일관성 보장
   - 성능 영향: 쓰기 작업에 약간의 오버헤드, 하지만 충돌 복구 시간 대폭 감소

성능 최적화 기법의 종합적 영향:
- 응답 시간 개선: 캐싱과 지연 쓰기로 인한 즉각적인 응답
- 처리량 증가: 버퍼링과, 블록 미리 읽기로 효율적인 디스크 사용
- I/O 작업 감소: 중복 읽기/쓰기 작업 제거로 디스크 부하 감소
- 자원 효율성: CPU와 디스크 활용도 향상

트레이드오프와 고려사항:
- 메모리 사용량: 버퍼와 캐시에 상당한 메모리 필요
- 데이터 일관성: 지연 쓰기로 인한 충돌 시 데이터 손실 위험
- 캐시 관리 오버헤드: 캐시 데이터 무효화 및 동기화 비용

**해설:**
파일 시스템 성능 최적화는 저장 장치(특히 하드 디스크)와 메인 메모리 간의 큰 속도 차이를 극복하기 위한 기법들을 포함합니다. 메모리 접근은 나노초 단위로 이루어지지만, 디스크 접근은 밀리초 단위로 수천~수만 배 느립니다. 따라서 디스크 접근을 최소화하는 것이 성능 향상의 핵심입니다.

Linux와 같은 현대 운영체제는 통합 페이지 캐시를 사용하여 파일 시스템 캐싱을 메모리 관리와 통합합니다. 이는 메모리를 효율적으로 사용하고, 파일 I/O와 메모리 매핑 파일 간의 일관성을 유지합니다. Windows에서는 시스템 작업 관리자가 캐시된 메모리를 표시하며, 이는 필요 시 다른 용도로 재할당될 수 있습니다.

최적화 기법들은 상호 보완적으로 작동합니다. 예를 들어, 블록 미리 읽기는 캐시를 미리 채우고, 지연 쓰기는 여러 쓰기 작업을 병합하여 캐시에서 효율적으로 관리합니다. 이러한 기법들은 파일 시스템 설계의 핵심 요소가 되었으며, 특히 대용량 데이터를 다루는 현대 애플리케이션에서 필수적입니다.

최근에는 SSD와 NVMe 장치의 등장으로 이러한 기법들의 중요성과 구현이 변화하고 있습니다. 낮은 지연 시간과 높은 대역폭을 제공하는 이러한 장치들은 기존과 다른 최적화 전략을 요구하며, 파일 시스템도 이에 맞게 발전하고 있습니다.

## 문제 11
파일 시스템 일관성 검사(fsck) 및 복구 메커니즘의 작동 원리를 설명하고, 저널링 파일 시스템이 이를 어떻게 개선하는지 설명하시오.

**답변:**
파일 시스템 일관성 검사 및 복구 메커니즘:

일관성 검사(fsck) 작동 원리:
1. 슈퍼블록 검사: 파일 시스템 기본 정보의 무결성 확인
2. 아이노드 검사: 모든 아이노드의 형식 및 값 검증
3. 디렉토리 검사: 디렉토리 구조와 엔트리의 유효성 확인
4. 연결성 검사: 모든 파일이 디렉토리에서 접근 가능한지 확인
5. 블록 참조 검사: 각 블록이 정확히 할당되었는지 확인
6. 사용량 정보 재계산: 블록 및 아이노드 사용량 정보 갱신

일관성 검사 단계별 복구 방식:
1. 손상된 슈퍼블록: 백업 슈퍼블록 복원
2. 비정상 아이노드: 손상된 아이노드 정리 또는 분실+발견 디렉토리로 이동
3. 디렉토리 오류: 잘못된 엔트리 제거, 누락된 '.' 및 '..' 복구
4. 연결 해제된 아이노드: 분실+발견(lost+found) 디렉토리에 연결
5. 중복 할당 블록: 복사본 생성 또는 소유권 재할당
6. 미사용 블록 및 아이노드: 사용 가능 목록에 재추가

저널링 파일 시스템의 개선 방식:

1. 트랜잭션 로깅:
   - 파일 시스템 변경 전 저널에 의도된 작업 기록
   - 변경 작업의 원자성 보장
   - 충돌 발생 시 저널을 통한 재생 또는 롤백

2. 복구 프로세스 개선:
   - 전체 파일 시스템 스캔 대신 저널만 검사
   - 마지막 완료된 트랜잭션 지점 식별
   - 미완료 트랜잭션 롤백, 부분 완료된 트랜잭션 재생

3. 복구 시간 단축:
   - 기존 fsck: 전체 파일 시스템 검사 (TB 단위 디스크에서 수 시간 소요)
   - 저널링 복구: 저널 검사만 수행 (수 초~수 분 내 완료)

4. 메타데이터 vs 전체 데이터 저널링:
   - 메타데이터 저널링: 구조 정보만 보호, 성능 우수, 데이터 손상 가능성 존재
   - 전체 데이터 저널링: 모든 데이터 보호, 성능 저하, 완전한 일관성 보장

저널링과 일관성 검사 비교:
- 기존 fsck: 사후 복구 메커니즘, 전체 파일 시스템 검사, 시간 소모적
- 저널링: 예방적 안전 메커니즘, 문제 발생 가능성 최소화, 빠른 복구

**해설:**
파일 시스템 일관성 검사(fsck)는 시스템 충돌이나 하드웨어 오류 후 파일 시스템의 무결성을 복원하는 중요한 도구입니다. 전통적인 fsck는 파일 시스템의 모든 메타데이터를 검사하고 불일치를 수정하는 광범위한 작업입니다. 이는 대형 저장 장치에서 매우 시간이 많이 소요될 수 있으며, 완전한 복구를 보장하지 않습니다.

저널링 파일 시스템은 이런 문제를 해결하기 위해 데이터베이스 트랜잭션 개념을 적용했습니다. 모든 파일 시스템 변경 작업은 먼저 저널에 기록되고, 성공적으로 저널에 커밋된 후에만 실제 파일 시스템에 적용됩니다. 시스템 충돌이 발생하면, 복구 과정은 단순히 저널을 검사하여 미완료 작업을 롤백하거나 완료되지 않은 작업을 마무리합니다.

ext3/ext4, XFS, JFS, NTFS와 같은 현대 파일 시스템은 모두 저널링을 지원합니다. 이들은 대부분 기본적으로 메타데이터 저널링만 활성화하여 성능과 안정성 사이의 균형을 유지합니다. 데이터 무결성이 특히 중요한 환경에서는 전체 데이터 저널링을 활성화할 수 있지만, 이는 성능 저하를 가져옵니다.

최근에는 저널링을 넘어선 CoW(Copy-on-Write), ZFS의 트랜잭션 모델, Btrfs의 CoW+체크섬과 같은 더 발전된 데이터 보호 메커니즘이 등장하고 있습니다. 이러한 접근 방식은 저널링의 이점을 유지하면서 추가적인 데이터 무결성 보장을 제공합니다.

## 문제 12
파일 시스템의 디스크 공간 관리 기법(비트맵, 연결 리스트, 그룹화)을 설명하고, 각 방식의 장단점을 논하시오.

**답변:**
파일 시스템의 디스크 공간 관리 기법:

1. 비트맵(Bitmap) 관리:
   - 구현 방식: 각 블록/아이노드마다 1비트 할당, 사용(1)/미사용(0) 표시
   - 메모리 구조: 연속된 비트 배열로 디스크 블록 상태 표현
   - 공간 요구: n개 블록 관리에 n/8 바이트 필요
   
   장점:
   - 간단한 구현과 효율적인 메모리 사용
   - 연속된 여유 블록 찾기 용이
   - 전체 디스크 상태 빠르게 파악 가능
   
   단점:
   - 대용량 디스크에서 전체 비트맵을 메모리에 유지하기 어려움
   - 단편화된 여유 공간 관리에 비효율적
   - 비트맵 자체의 I/O 오버헤드

2. 연결 리스트(Linked List) 관리:
   - 구현 방식: 빈 블록들이 다음 빈 블록 주소를 포함하는, 연결 구조
   - 메모리 구조: 첫 번째 빈 블록 포인터만 유지, 나머지는 디스크에 저장
   - 공간 요구: 최소화된 메모리 사용
   
   장점:
   - 메모리 요구량 최소화
   - 대용량 디스크 관리에 적합
   - 할당/해제 작업 단순
   
   단점:
   - 연속된 빈 블록 찾기 어려움
   - 리스트 순회에 많은 디스크 I/O 필요
   - 포인터 손상 시 전체 시스템 영향

3. 그룹화(Grouping)/인덱싱 관리:
   - 구현 방식: 블록 그룹별로 관리 정보 유지, 각 그룹에 로컬 비트맵/리스트 사용
   - 메모리 구조: 그룹 디스크립터 테이블과 그룹별 메타데이터
   - 공간 요구: 중간 수준(그룹 수에 비례)
   
   장점:
   - 지역성 활용으로 성능 향상
   - 메타데이터와 데이터 근접 배치 가능
   - 부분적 디스크 손상 시 영향 제한
   
   단점:
   - 구현 복잡성 증가
   - 그룹 경계 넘는 대용량 파일 관리 복잡
   - 그룹 간 불균형 발생 가능

4. 익스텐트(Extent) 기반 관리:
   - 구현 방식: 연속된 블록 범위(시작 블록+길이)로 할당 관리
   - 메모리 구조: 익스텐트 트리 또는 맵 형태로 관리
   - 공간 요구: 파일당 메타데이터 크기 감소
   
   장점:
   - 대용량 연속 공간 효율적 관리
   - 메타데이터 오버헤드 감소
   - 단편화 최소화 및 순차 접근 성능 향상
   
   단점:
   - 단편화 발생 시 관리 복잡
   - 작은 파일 많은 경우 이점 감소
   - 구현 복잡성

현대 파일 시스템의 접근 방식:
- ext2/ext3: 블록 그룹과 비트맵 조합
- ext4: 그룹 관리 + 익스텐트 추가
- XFS: 익스텐트 + B+ 트리 인덱싱
- NTFS: 마스터 파일 테이블(MFT)과 실행 리스트

**해설:**
디스크 공간 관리는 파일 시스템의 핵심 기능 중 하나로, 할당 방식에 따라 성능, 공간 효율성, 단편화 처리 능력이 크게 달라집니다. 초기 파일 시스템은 단순한 비트맵이나 연결 리스트를 사용했지만, 저장 장치 용량이 증가함에 따라 더 정교한 방식이 필요해졌습니다.

비트맵은 개념적으로 가장 단순하며, 연속된 빈 블록을 찾기 쉽지만 대용량 디스크에서는 비트맵 자체의 크기가 커지는 문제가 있습니다. 연결 리스트는 메모리 요구량이 적지만, 연속된 공간을 찾기 위해 많은 디스크 I/O가 필요합니다.

이러한 한계를 극복하기 위해 현대 파일 시스템은 그룹화와 익스텐트 기반 할당을 결합합니다. ext 파일 시스템 계열은 디스크를 블록 그룹으로 나누고 각 그룹 내에서 비트맵을 사용합니다. 이는 지역성을 활용하고 메타데이터 분산으로 안정성을 높입니다. ext4, XFS, NTFS와 같은 최신 파일 시스템은 익스텐트 기반 할당을 도입하여 메타데이터 오버헤드를 줄이고 대용량 파일 처리 성능을 향상시켰습니다.

또한 많은 파일 시스템이 B-트리나 B+ 트리와 같은 고급 데이터 구조를 활용하여 빈 공간과 할당된 공간을 효율적으로 관리합니다. 특히 ZFS, Btrfs와 같은 차세대 파일 시스템은 CoW(Copy-on-Write) 기법과 결합된 트리 구조를 사용하여 성능과 안정성을 모두 개선했습니다.

## 문제 13
파일 시스템 백업 전략(전체 백업, 증분 백업, 차등 백업)을 비교 설명하고, 백업 및 복구 시 고려해야 할 핵심 요소들을 논하시오.

**답변:**
파일 시스템 백업 전략 비교:

1. 전체 백업(Full Backup):
   - 방식: 모든 파일과 디렉토리를 완전히 백업
   - 장점: 간단한 복구 프로세스, 단일 백업 세트만 필요
   - 단점: 많은 시간과 저장 공간 필요, 중복 데이터 발생
   - 복구 속도: 가장 빠름 (단일 백업 세트만 복원)

2. 증분 백업(Incremental Backup):
   - 방식: 마지막 백업(전체 또는 증분) 이후 변경된 파일만 백업
   - 장점: 빠른 백업 시간, 최소 저장 공간 사용
   - 단점: 복잡한 복구 프로세스, 모든 증분 백업 필요
   - 복구 속도: 가장 느림 (전체 + 모든 증분 백업 필요)

3. 차등 백업(Differential Backup):
   - 방식: 마지막 전체 백업 이후 변경된 모든 파일 백업
   - 장점: 증분보다 간단한 복구, 전체보다 적은 공간/시간
   - 단점: 증분보다 더 많은 중복 데이터, 시간이 지날수록 크기 증가
   - 복구 속도: 중간 (전체 + 최신 차등 백업만 필요)

일반적인 백업 전략 조합:
- 주간 전체 백업 + 일일 증분 백업
- 월간 전체 백업 + 주간 차등 백업 + 일일 증분 백업
- 전체 백업 + 영구 증분 백업 (현대 백업 시스템)

백업 및 복구 시 고려 요소:

1. 데이터 관련 요소:
   - 백업 대상: 중요 데이터 식별 및 우선순위 설정
   - 데이터 크기: 총 용량 및 변경 비율
   - 보존 기간: 규제 및 비즈니스 요구사항 준수
   - 데이터 중요도: 가용성 및 무결성 요구사항

2. 기술적 요소:
   - 백업 창(Backup Window): 백업 수행 가능 시간
   - RTO(Recovery Time Objective): 목표 복구 시간
   - RPO(Recovery Point Objective): 허용 가능한 데이터 손실 시간
   - 백업 매체: 테이프, 디스크, 클라우드 등 선택
   - 압축 및 중복 제거: 저장 공간 최적화
   - 암호화: 백업 데이터 보안

3. 운영 요소:
   - 백업 검증: 백업 무결성 및 복원 가능성 확인
   - 오프사이트 저장: 재해 대비 원격지 백업 유지
   - 문서화: 백업 구성 및 복구 절차 문서화
   - 정기적 복구 테스트: 백업 데이터의 실제 복원 가능성 확인
   - 자동화: 백업 프로세스 자동화 및 모니터링

4. 특수 고려사항:
   - 오픈 파일 백업: 사용 중인 파일 처리 방법
   - 애플리케이션 일관성: 데이터베이스 등 트랜잭션 애플리케이션 처리
   - 메타데이터 보존: 권한, 속성, 링크 등 보존
   - 증분/차등 베이스라인 관리: 기준점 설정 및 관리

**해설:**
효과적인 백업 전략은 데이터 보호의 기본이지만, 단순히 파일을 복사하는 것 이상의 의미를 갖습니다. 백업은 시스템 실패, 사용자 오류, 악의적인 공격, 자연 재해 등 다양한 위험으로부터 데이터를 보호하는 종합적인 접근이 필요합니다.

전통적인 백업 모델(전체, 증분, 차등)은 오랫동안 사용되어 왔지만, 현대 데이터 환경에서는 이를 발전시킨 다양한 접근법이 등장했습니다. 예를 들어, 스냅샷 기반 백업은 특정 시점의 시스템 상태를 캡처하여 빠른 복구를 지원하며, 연속 데이터 보호(CDP)는 모든 변경 사항을 실시간으로 기록하여 임의 시점으로의 복구를 가능하게 합니다.

현대적인 백업 시스템은 중복 제거(deduplication)와 압축을 통해 저장 공간을 최적화하고, 클라우드 통합으로 확장성과 지리적 분산을 제공합니다. 또한 가상화 환경을 위한 특화된 백업 기술(예: VM 스냅샷)이 발전하고 있습니다.

백업 데이터의 보안도 중요한 고려사항입니다. 랜섬웨어와 같은 위협이 증가함에 따라, 불변 백업(immutable backup) 및 에어갭(air-gapped) 솔루션과 같은 접근법이 중요해지고 있습니다. 이는 백업 데이터 자체가 공격 대상이 될 수 있기 때문입니다.

효과적인 백업 전략은 기술적 측면뿐만 아니라 비즈니스 요구사항, 규제 준수, 비용 등 여러 요소의 균형을 맞추는 것이 중요합니다. 특히 RTO와 RPO는 비즈니스 연속성 계획의 핵심 지표로, 백업 및 복구 전략을 설계할 때 명확히 정의되어야 합니다.

## 문제 14
파일 시스템에서 심볼릭 링크와 하드 링크의 차이점을 설명하고, 각각의 구현 방식 및 사용 시 주의사항을 설명하시오.

**답변:**
심볼릭 링크와 하드 링크의 차이점:

1. 기본 개념:
   - 하드 링크: 파일 시스템 내의 파일 데이터(inode)에 대한 직접 참조
   - 심볼릭 링크: 다른 파일이나 디렉토리의 경로를 가리키는 특수 파일

2. 구현 방식:
   - 하드 링크: 
     * 동일한 inode 번호를 가리키는 디렉토리 엔트리 생성
     * 원본 파일의 링크 카운트 증가
     * 데이터 블록 공유, 메타데이터 공유
   
   - 심볼릭 링크:
     * 특수 파일 형식(파일 유형 필드로 식별)으로 생성
     * 대상 파일의 경로를 내용으로 저장
     * 독립된 inode와 데이터 블록 사용

3. 주요 특성 비교:

| 특성 | 하드 링크 | 심볼릭 링크 |
|------|-----------|------------|
| 파일 시스템 경계 | 동일 파일 시스템 내에서만 생성 가능 | 다른 파일 시스템 간에도 생성 가능 |
| 디렉토리 링크 | 디렉토리에 대한 하드 링크 생성 불가 | 디렉토리에 대한 링크 생성 가능 |
| 원본 삭제 시 | 링크 카운트가 0이 될 때까지 데이터 유지 | 깨진 링크(dangling link)가 됨 |
| 크기 | 디렉토리 엔트리만 추가 | 링크 자체가 파일로 저장 공간 차지 |
| inode 번호 | 원본과 동일한 inode 번호 | 고유한 inode 번호 |
| 접근 방식 | 직접 접근(추가 inode 검색 없음) | 간접 접근(경로 해석 필요) |

4. 사용 시 주의사항:

   하드 링크:
   - 파일 시스템 간에는 생성 불가능
   - 디렉토리에 대한 하드 링크 생성 제한(파일 시스템 순환 참조 방지)
   - 원본 파일 식별 어려움(모든 링크가 동등)
   - 파일 속성 변경 시 모든 링크에 영향(동일 inode)
   - 특정 운영체제에서 지원하지 않을 수 있음

   심볼릭 링크:
   - 원본 파일 삭제 시 링크 손상(깨진 링크)
   - 상대 경로 사용 시 링크 위치 변경 시 문제 발생 가능
   - 심볼릭 링크 체인/순환 참조 시 성능 저하 및 오류 가능성
   - 접근 시 추가적인 경로 해석 오버헤드
   - 보안 문제 발생 가능성(심볼릭 링크 공격)

