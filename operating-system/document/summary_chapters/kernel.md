1. 커널과 인터페이스 구성 요소 (Kernel and Interface Components)
커널 공간과 사용자 공간의 차이는 무엇인가요?

사용자 프로그램이 직접 하드웨어 자원에 접근할 수 없는 이유를 설명하세요.

시스템 호출이 필요한 상황을 예시로 들어 설명하세요.

파일 읽기/쓰기 시 커널의 개입이 필요한 이유는?

다음 중 커널의 핵심 기능이 아닌 것은?
a) 프로세스 스케줄링
b) 메모리 관리
c) 웹 브라우저 실행
d) 인터럽트 처리

디바이스 드라이버가 커널에 포함되는 이유는 무엇인가요?

사용자 공간에서 디바이스 드라이버를 실행하면 발생할 수 있는 문제는?

마이크로커널과 모놀리식 커널의 차이를 설명하고, 전자의 장단점을 논하세요.

2. 이중 모드 연산 (Dual-mode Operation)
사용자 모드에서 커널 모드로 전환되는 상황 3가지를 설명하세요.

시스템 호출, 인터럽트, 예외 중 어떤 경우에 전환되나요?

사용자 모드 프로세스가 권한 있는 명령어를 실행하려고 할 때 발생하는 현상은?

CPU가 어떻게 대응하는지 설명하세요.

**모드 비트(mode bit)**의 역할은 무엇인가요?

해당 비트가 0일 때와 1일 때의 차이를 설명하세요.

커널 모드에서 실행되는 코드가 사용자 모드보다 더 강력한 이유는 무엇인가요?

예를 들어 메모리 보호 기능과 연결지어 설명하세요.

시스템 호출 과정에서 **트랩(Trap)**이 어떤 역할을 하나요?

트랩 벡터 테이블과의 관계를 설명하세요.

3. 시스템 호출과 API (System Calls and API)
API와 시스템 호출의 차이를 예시와 함께 설명하세요.

printf() 함수가 write() 시스템 호출을 사용하는 과정을 설명하세요.

다음 중 직접 시스템 호출이 아닌 것은?
a) fork()
b) open()
c) printf()
d) execve()

표준 C 라이브러리가 시스템 호출을 감싸는 이유는 무엇인가요?

사용자가 직접 시스템 호출을 사용하지 않는 장점은?

시스템 호출 번호가 필요한 이유는 무엇인가요?

커널이 해당 번호를 어떻게 처리하는지 설명하세요.

가상 파일 시스템(VFS)이 시스템 호출과 어떻게 연관되는지 설명하세요.

4. 프로세스 제어 시스템 호출 (Process Control System Calls)
fork()와 exec()의 차이를 설명하고, 두 호출이 함께 사용되는 이유를 예시로 설명하세요.

fork() 후 exec()를 호출하지 않으면 어떤 문제가 발생하나요?

좀비 프로세스가 생성되는 상황과 이를 해결하는 방법을 설명하세요.

wait() 시스템 호출의 역할은?

다음 코드의 실행 결과를 예측하세요:

c
int main() {
    if (fork() == 0) 
        printf("Child PID: %d\n", getpid());
    else 
        printf("Parent PID: %d\n", getpid());
}
exec() 함수가 성공하면 원래 프로세스의 코드는 어떻게 되나요?

반환 값이 없는 이유는 무엇인가요?

프로세스 그룹과 kill() 시스템 호출의 관계를 설명하세요.

kill(0, SIGTERM)을 실행하면 어떤 일이 발생하나요?

5. 파일 관리 호출 (File Management Calls)
파일 디스크립터와 파일 이름의 차이를 설명하세요.

open() 함수가 반환하는 파일 디스크립터의 역할은?

O_CREAT | O_EXCL 플래그를 사용해 파일을 생성할 때 이미 파일이 존재하는 경우 발생하는 현상은?

해당 플래그의 중요성을 설명하세요.

lseek() 함수를 사용해 파일 오프셋을 끝으로 이동시킨 후 write()를 호출하면 어떤 일이 발생하나요?

파일 크기가 어떻게 변경되나요?

하드 링크와 소프트 링크의 차이를 link()와 symlink() 시스템 호출과 연결지어 설명하세요.

read() 시스템 호출이 **블로킹(blocking)**되는 상황을 예시로 들어 설명하세요.

논블로킹 모드에서의 동작과 차이점은?

6. 디바이스 관리 (Device Management)
문자 디바이스와 블록 디바이스의 차이를 예시와 함께 설명하세요.

키보드와 하드 디스크는 각각 어떤 유형에 속하나요?

디바이스 드라이버가 커널 모드에서 실행되어야 하는 이유는 무엇인가요?

사용자 공간에서 드라이버를 실행할 경우의 위험성은?

**DMA(Direct Memory Access)**의 역할을 설명하세요.

CPU에 대한 부하를 어떻게 줄여주나요?

인터럽트 기반 IO와 폴링(polling) 기반 IO의 차이를 설명하세요.

각 방식의 장단점은?

디바이스 파일이 /dev 디렉토리에 존재하는 이유는 무엇인가요?

mknod() 시스템 호출로 생성되는 파일의 역할은?

7. 정보 유지 (Information Maintenance)
getpid()와 getppid() 시스템 호출의 반환 값을 설명하세요.

프로세스 트리에서 부모-자식 관계를 추적하는 데 어떻게 사용되나요?

시스템 시간을 얻기 위해 time() 대신 gettimeofday()를 사용하는 이유는 무엇인가요?

두 함수의 정밀도 차이를 설명하세요.

uname() 시스템 호출이 반환하는 정보의 종류를 나열하세요.

커널 버전을 확인하는 데 어떻게 활용되나요?

시스템 리소스 사용량을 확인하는 sysinfo() 호출 예제를 작성하세요.

메모리 사용량을 출력하는 코드를 작성해보세요.

times() 시스템 호출이 반환하는 tms 구조체의 필드를 설명하세요.

사용자 CPU 시간과 커널 CPU 시간의 차이는?

8. 통신 (Communications)
**파이프(Pipe)**를 사용한 IPC의 한계를 설명하세요.

익명 파이프와 이름 있는 파이프(FIFO)의 차이점은?

공유 메모리 기반 IPC에서 동기화 문제가 발생하는 이유는 무엇인가요?

세마포어나 뮤텍스 없이 공유 메모리를 사용할 때의 위험성을 설명하세요.

메시지 큐가 파이프보다 유리한 상황을 예시로 들어 설명하세요.

메시지의 우선순위를 지정할 수 있는 경우를 생각해보세요.

socket() 시스템 호출을 사용한 네트워크 통신과 로컬 IPC의 차이점은 무엇인가요?

UNIX 도메인 소켓의 사용 사례를 설명하세요.

**RPC(Remote Procedure Call)**의 동작 원리를 시스템 호출과 연결지어 설명하세요.

스텁(stub)의 역할은 무엇인가요?

9. 보호 메커니즘 (Protection Mechanisms)
파일 권한 644(rw-r--r--)의 의미를 설명하세요.

chmod 755 file 명령어를 실행하면 어떤 변화가 발생하나요?

setuid 비트가 설정된 실행 파일의 동작 방식을 설명하세요.

passwd 명령어가 setuid를 사용하는 이유는?

**접근 제어 목록(ACL)**이 기존 UNIX 권한 모델보다 강력한 이유는 무엇인가요?

복잡한 권한 설정 예시를 들어 설명하세요.

커널 모드에서만 실행 가능한 작업을 3가지 나열하세요.

예: 인터럽트 활성화/비활성화, 페이지 테이블 수정 등.

**보안 커널(Security Kernel)**의 역할을 설명하세요.

참조 모니터(Reference Monitor) 개념과의 관계는?

10. 테이블을 통한 매개변수 전달 (Parameter Passing via Table)
시스템 호출 시 매개변수 전달 방법 3가지를 설명하세요.

레지스터, 스택, 메모리 블록 중 어떤 방식이 가장 효율적일까요?

블록 방식으로 매개변수를 전달할 때의 장단점은 무엇인가요?

커널이 사용자 메모리 영역에 직접 접근하는 위험성을 설명하세요.

시스템 호출 open()의 매개변수인 flags와 mode를 전달하는 구체적인 방법은?

RISC-V 아키텍처에서의 레지스터 사용 예시를 들어 설명하세요.

가변 길이 매개변수를 처리하기 위한 커널의 접근 방식을 설명하세요.

예: execve()에서 인자 배열을 어떻게 전달하나요?

시스템 호출 번호가 매개변수 전달과 어떻게 연관되는지 설명하세요.

eax 레지스터의 역할은?

11. OS 아키텍처 모델 (OS Architecture Models)
모놀리식 커널의 장단점을 마이크로커널과 비교해 설명하세요.

성능과 신뢰성 측면에서의 차이는?

계층형 구조(Layered) OS 설계의 단점을 설명하세요.

계층 간 통신의 오버헤드 문제를 예시로 들어보세요.

하이브리드 커널이 모놀리식과 마이크로커널의 요소를 어떻게 결합하나요?

Windows NT 커널을 예시로 설명하세요.

모듈형 커널의 유연성을 설명하세요.

동적 모듈 로딩이 가능한 경우와 불가능한 경우를 비교하세요.

Exokernel 아키텍처의 핵심 아이디어는 무엇인가요?

전통적 커널과의 차이점을 강조하세요.

각 문제는 해당 주제의 핵심 개념과 흔히 오해하기 쉬운 부분을 다루고 있습니다. 문제 풀이를 통해 운영체제의 구조와 동작 원리를 심층적으로 이해할 수 있을 것입니다.

---

# 스레드, 프로세스 및 병렬 컴퓨팅

## Amdahl 이론 (Amdahl's Law)

Amdahl 이론은 시스템의 일부를 개선할 때 얻을 수 있는 전체 성능 향상의 이론적 한계를 계산합니다. 이는 병렬 컴퓨팅에서 특히 중요한 개념입니다.

```
SpeedUp = 1 / [(1-p) + (p/N)]
```
- p: 프로그램에서 병렬화 가능한 부분의 비율 (0~1)
- N: 처리 코어(프로세서)의 개수
- (1-p): 순차적으로만 실행 가능한 부분의 비율

이 공식의 핵심 통찰은 프로그램의 순차적 부분이 전체 성능 향상에 근본적인 제약을 가한다는 것입니다. 아무리 많은 프로세서를 추가해도 순차적인 부분으로 인해 속도 향상은 제한됩니다.

## fork() 시스템 콜을 통한 프로세스 생성

fork() 시스템 콜은 Unix 계열 운영체제에서 새로운 프로세스를 생성하는 기본 메커니즘입니다[1][2].

### 작동 방식

1. 프로세스가 fork()를 호출하면 커널은 호출한 프로세스(부모)의 복제본(자식)을 생성합니다[1]
2. 부모와 자식 프로세스 모두 fork() 호출 지점 이후의 코드를 실행합니다[1]
3. 반환값을 통해 부모와 자식을 구분합니다:
   - 부모 프로세스: 자식의 PID 값(양수) 반환
   - 자식 프로세스: 0 반환[2][10]
4. 생성 실패 시: -1 반환[10]

### 최적화 기법

현대 운영체제는 copy-on-write 기법을 사용하여 프로세스 생성을 최적화합니다[2]:
- 초기에는 부모와 자식이 동일한 물리적 메모리 페이지를 공유합니다
- 한쪽에서 메모리 수정 시도 시에만 실제로 복사가 이루어집니다
- 이는 특히 fork() 후 바로 exec()를 호출하는 경우에 효율적입니다[2][11]

```c
pid_t pid = fork();
if (pid == 0) {
    // 자식 프로세스 코드
    execve("/usr/bin/ls", ls_args, environ);
} else {
    // 부모 프로세스 코드
    fprintf(stderr, "%s\n", "Parent process");
}
```

## 커널 스레드 간의 Context Switching

커널 스레드 간 컨텍스트 스위칭은 다음과 같은 단계로 이루어집니다[4][8]:

1. **상태 저장**: 현재 스레드의 실행 컨텍스트(레지스터, 프로그램 카운터, 스택 포인터 등)를 Thread Control Block(TCB)에 저장합니다[4][14]

2. **스케줄링**: 스케줄러가 다음에 실행할 스레드를 선택합니다[4]

3. **상태 복원**: 선택된 스레드의 컨텍스트를 해당 TCB에서 로드합니다[4]

4. **주소 공간 전환**: 스레드가 다른 프로세스에 속한 경우, 가상 메모리 매핑을 변경하고 TLB(Translation Lookaside Buffer)를 비웁니다[4]

5. **실행 재개**: 저장된 프로그램 카운터 위치부터 실행을 재개합니다[4]

### 주요 특징

- 커널 스레드 전환은 커널 모드 권한이 필요합니다[7]
- 프로세스 전환보다는 빠르지만 사용자 레벨 스레드 전환보다는 느립니다[4][7]
- 동일 프로세스 내 스레드 전환은 주소 공간 전환이 필요 없어 더 빠릅니다[4]
- 현대 CPU는 컨텍스트 스위치 오버헤드를 줄이기 위한 최적화 기능이 포함되어 있습니다[4]

## 프로세스와 스레드의 리소스 요구사항

### 스레드 리소스
- 스레드 식별자(TID)[14]
- 레지스터 세트(프로그램 카운터, 스택 포인터 등 CPU 레지스터)[14]
- 스택(로컬 변수와 함수 호출용)[9]
- Thread Control Block(TCB)[14]
- 스레드 로컬 스토리지(Thread-Local Storage, TLS)[9]

### 스레드의 스택과 TLS
- **스택**: 함수 호출 정보와 지역 변수를 저장하는 LIFO 구조의 메모리 영역으로, 스레드마다 독립적으로 할당됩니다[9]
- **TLS**: 스레드별 독립적인 저장 공간으로, 전역 변수처럼 사용할 수 있지만 해당 스레드만 접근 가능합니다[9]

### 프로세스 리소스
- 프로세스 식별자(PID)[2][10]
- 메모리 공간(텍스트, 데이터, 힙 세그먼트)[5]
- Process Control Block(PCB)[6]
- 파일 디스크립터 테이블[2]
- 보안 컨텍스트(사용자 ID, 그룹 ID)[5]
- 최소 하나의 스레드(메인 스레드)[5]

## 사용자 레벨 스레드 vs 커널 레벨 스레드

### 사용자 레벨 스레드(User-level Threads)
사용자 공간에서 구현되며 커널 지원 없이 스레드 라이브러리를 통해 관리됩니다[7][9][12].

**특징**:
- 스레드 작업에 시스템 콜이 필요 없음[7]
- 컨텍스트 스위칭이 빠름[7][12]
- 스레딩을 지원하지 않는 OS에서도 사용 가능[7]
- 커널은 이러한 스레드의 존재를 인식하지 못함[7][12]
- 한 스레드가 I/O에 블록되면 동일 프로세스의 모든 스레드가 블록됨[12][17]
- 사용자 라이브러리에 의해 스케줄링되어 유연성 제공[7]
- 생성과 관리가 커널 레벨 스레드보다 빠름[12][17]

**예**: POSIX Threads, Java의 green 스레드[9][12]

### 커널 레벨 스레드(Kernel-level Threads)
OS에 의해 직접 지원되고 관리되는 스레드입니다[8][12].

**특징**:
- 스레드 작업에 시스템 콜이 필요함[7][12]
- 커널이 모든 스레드를 인식하고 관리[8][12]
- 한 스레드가 블록되어도 다른 스레드들은 정상 작동[12][17]
- 멀티프로세서 시스템에서 진정한 병렬 실행 가능[8][12]
- 스레드당 더 많은 시스템 리소스 필요[8][12]
- 생성과 관리가 사용자 레벨 스레드보다 느림[12][17]

**예**: Linux의 POSIX 스레드, Windows 스레드[9][12]

### 주요 차이점

|매개변수|사용자 레벨 스레드|커널 레벨 스레드|
|---|---|---|
|구현 주체|사용자 라이브러리에 의해 구현|운영체제에 의해 구현|
|인식|OS가 직접 인식하지 못함|OS가 직접 인식함|
|컨텍스트 스위치 시간|적음|많음|
|하드웨어 지원|필요 없음|필요함|
|블로킹 연산|한 스레드가 블록되면 전체 프로세스 블록|한 스레드가 블록돼도 다른 스레드 실행 가능|
|멀티프로세싱|멀티프로세서 활용 어려움|멀티프로세서 활용 가능|
|이식성|높음|낮음(OS 종속적)|
|장점|생성/관리 빠름, 이식성 높음|진정한 병렬 실행, 블로킹 연산에 강함|
|단점|블로킹 연산에 취약, 멀티프로세서 활용 못함|생성/관리 느림, 오버헤드 큼|


---

이중 모드 운영(Dual-Mode Operation)이 필요한 주된 이유는 운영체제와 사용자 프로그램을 잘못된 또는 악의적인 프로그램으로부터 보호하기 위함입니다[2][4]. 이는 시스템의 안정성과 보안을 유지하는 핵심 메커니즘으로, 사용자가 직접 하드웨어에 접근하거나 다른 사용자의 프로그램을 방해하는 것을 방지합니다.

## 이중 모드 운영의 하드웨어적 지원

이중 모드 운영을 구현하기 위해 하드웨어는 다음과 같은 지원을 제공합니다:

1. **모드 비트(Mode Bit)**
   - CPU의 하드웨어 레지스터에 있는 특별한 비트로, 현재 실행 중인 코드가 커널 모드(0) 또는 사용자 모드(1)인지를 나타냅니다[4][5]
   - 모드 비트가 0이면 커널 모드(특권 모드), 1이면 사용자 모드를 의미합니다[4]

2. **특권 명령어(Privileged Instructions)**
   - 시스템의 중요한 상태를 변경하거나 하드웨어 자원에 직접 접근할 수 있는 명령어[5]
   - 커널 모드에서만 실행할 수 있으며, 사용자 모드에서 이를 실행하려고 하면 트랩이 발생합니다[5]

3. **메모리 보호 메커니즘**
   - MMU(Memory Management Unit)를 통해 메모리 접근을 제한하고 권한을 검사합니다[5]
   - 각 프로세스는 독립된 가상 주소 공간을 가지며, 다른 프로세스의 메모리에 접근할 수 없습니다[5]

4. **인터럽트 처리 하드웨어**
   - 인터럽트가 발생하면 자동으로 커널 모드로 전환됩니다[4][7]
   - 인터럽트 벡터 테이블을 통해 적절한 핸들러로 제어를 이동합니다

## 이중 모드 전환 메커니즘

이중 모드 전환에는 다음과 같은 핵심 메커니즘이 있습니다:

### 1. 시스템 콜(System Call)

시스템 콜은 사용자 프로그램이 운영체제 커널의 서비스를 요청하는 인터페이스입니다[6][7]. 사용자 모드에서 실행되는 프로그램이 하드웨어 자원에 접근해야 할 때 사용됩니다.

- 사용자 프로그램이 시스템 콜 번호와 필요한 매개변수를 준비합니다[6]
- 특별한 트랩 명령어(syscall, int 0x80 등)를 실행합니다[3][6]
- 하드웨어가 사용자 모드에서 커널 모드로 전환합니다[4]
- 커널은 시스템 콜 번호를 확인하고 해당 서비스 루틴으로 제어를 이동합니다[4]
- 작업 완료 후 사용자 모드로 돌아가 프로그램 실행을 계속합니다[4]

### 2. 인터럽트(Interrupt)

인터럽트는 하드웨어 장치에 의해 생성되는 비동기적 신호입니다[3][7]:

- 하드웨어 장치(타이머, I/O 장치 등)에 의해 발생합니다[3][7]
- 현재 실행 중인 명령어와 직접적인 관련 없이 발생합니다[3]
- 인터럽트 발생 시 자동으로 커널 모드로 전환됩니다[7]
- 인터럽트 처리 후 원래 실행 중이던 프로그램으로 제어가 반환됩니다[3]

### 3. 트랩(Trap)

트랩은 소프트웨어에 의해 의도적으로 생성되는 동기적 이벤트입니다[3][7]:

- 프로그램 실행 중 오류(0으로 나누기, 페이지 폴트, 잘못된 메모리 접근 등)로 인해 발생합니다[3][7]
- 시스템 콜을 호출할 때도 트랩 메커니즘이 사용됩니다[3][6]
- 트랩 발생 시 커널 모드로 전환되어 해당 상황을 처리합니다[7]
- 현재 실행 중인 명령어의 문제로 발생하는 동기적 이벤트입니다[3]

## 하드웨어 접근 추상화의 이점

하드웨어 접근을 추상화함으로써 얻는 이점은 다음과 같습니다:

1. **보안 강화**
   - 사용자 프로그램이 직접 하드웨어를 제어하거나 손상시키는 것을 방지합니다[2]
   - 모든 중요한 시스템 작업이 검증된 커널 코드를 통해서만 수행되도록 보장합니다[5]

2. **시스템 안정성 향상**
   - 사용자 프로그램의 오류가 전체 시스템에 영향을 미치지 않도록 격리합니다[2]
   - 하나의 프로그램이 시스템 자원을 독점하거나 손상시키는 것을 방지합니다[2]

3. **구현 단순화**
   - 개발자는 하드웨어의 복잡한 세부 사항을 알 필요 없이 표준화된 API를 통해 기능을 사용할 수 있습니다[4]
   - 운영체제가 하드웨어 접근을 중재하고 관리하므로 애플리케이션 개발이 단순해집니다[5]

이중 모드 운영은 현대 운영체제의 필수적인 메커니즘으로, 보안과 안정성을 유지하면서도 하드웨어 자원을 효율적으로 공유하고 관리할 수 있게 합니다.
