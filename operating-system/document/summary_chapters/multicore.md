운영체제: 멀티코어 프로그래밍과 스레드 관련 개념 심화 학습 문제집
이 문제집은 운영체제에서 다루는 멀티코어 프로그래밍, 스레드 모델, 병렬 처리와 관련된 개념들에 대한 이해를 심화시키기 위해 준비되었습니다. 각 주제별로 틀리기 쉽거나 헷갈리기 쉬운 개념들에 관한 문제들을 모았습니다.

1. 멀티코어 프로그래밍 (Multicore Programming)
문제 1.1
Q: 멀티코어 프로그래밍에서 '데이터 병렬(Data parallelism)'과 '테스크 병렬(Task parallelism)'의 차이점으로 올바른 것은?

데이터 병렬은 같은 일을 나누어 실행하고, 테스크 병렬은 서로 다른 일을 나누어 실행한다.

데이터 병렬은 서로 다른 일을 나누어 실행하고, 테스크 병렬은 같은 일을 나누어 실행한다.

데이터 병렬은 단일 코어에서만 실행되고, 테스크 병렬은 다중 코어에서 실행된다.

데이터 병렬과 테스크 병렬은 동일한 개념으로 구분이 없다.

A: 1번. 데이터 병렬은 동일한 연산을 다른 데이터에 적용하는 방식이고, 테스크 병렬은 서로 다른 작업을 분배하여 실행하는 방식입니다.

문제 1.2
Q: 멀티코어 시스템에서 코어 수를 무한정 증가시키면 프로그램의 실행 속도도 그에 비례하여 무한정 증가한다. (참/거짓)

A: 거짓. 암달의 법칙에 따르면, 병렬로 실행될 수 없는 순차적 부분이 있기 때문에 코어 수를 아무리 증가시켜도 일정 수준 이상의 성능 향상은 이루어지지 않습니다.

문제 1.3
Q: 멀티코어 프로그래밍에서 응용을 분석해 독립된 병행 가능 테스크로 나누는 작업을 무엇이라고 하는가?

A: 실행 분리(Dividing activities). 이것은 테스크 식별이라고도 합니다.

문제 1.4
Q: 멀티코어 프로그래밍에서 '데이터 종속성(Data dependency)'이란 무엇이며, 이것이 병렬 처리 성능에 어떤 영향을 미치는지 설명하시오.

A: 데이터 종속성은 테스크가 접근하는 데이터가 여러 테스크 사이에 종속성을 가지는 상황을 의미합니다. 이러한 종속성이 있으면 한 테스크가 데이터를 처리한 후에야 다른 테스크가 처리를 시작할 수 있어 병렬 처리의 효율성이 떨어지고, 동기화 오버헤드가 발생하여 성능이 저하됩니다.

문제 1.5
Q: 다음 중 멀티코어 프로그래밍의 도전 과제가 아닌 것은?

실행 분리(Dividing activities)

균형(Balance)

데이터 종속성(Data dependency)

사용자 인터페이스 설계(User interface design)

A: 4번. 사용자 인터페이스 설계는 멀티코어 프로그래밍의 주요 도전 과제가 아닙니다. 주요 도전 과제는 실행 분리, 균형, 데이터 분리, 데이터 종속성, 시험 및 디버깅입니다.

2. 다중 스레드 모델 (Multithreading Models)
문제 2.1
Q: 다음 중 다대일(Many-to-One) 스레드 모델의 특징으로 올바른 것은?

한 스레드가 봉쇄되면 전체 프로세스가 봉쇄된다.

다중 처리기에서 병렬 실행이 가능하다.

커널 스레드 생성 오버헤드가 크다.

사용자 스레드와 커널 스레드가 1:1로 매핑된다.

A: 1번. 다대일 모델에서는 많은 사용자 스레드가 하나의 커널 스레드로 매핑되므로, 하나의 스레드가 봉쇄형 시스템 콜을 호출하면 전체 프로세스가
봉쇄됩니다.

문제 2.2
Q: 일대일(One-to-One) 스레드 모델에서는 하나의 사용자 스레드가 하나의 커널 스레드와 연결되므로, 한 스레드가 봉쇄되더라도 다른 스레드는 독립적으로 실행될 수 있다. (참/거짓)

A: 참. 일대일 모델에서는 각 사용자 스레드가 자신만의 커널 스레드와 연결되어 있어, 한 스레드가 봉쇄되더라도 다른 스레드는 계속 실행될 수 있습니다.

문제 2.3
Q: 다중 처리기에서 병렬 실행을 가능하게 하면서도 사용자 스레드와 커널 스레드 간의 오버헤드를 줄이기 위해 설계된 스레드 모델은 무엇인가?

A: 다대다(Many-to-Many) 모델. 이 모델은 다수의 사용자 스레드를 다수의 커널 스레드에 매핑함으로써 병렬 처리의 장점과 오버헤드 감소의 장점을 모두 취합니다.

문제 2.4
Q: 다대다(Many-to-Many) 스레드 모델과 두 수준(Two-level) 스레드 모델의 차이점을 설명하시오.

A: 다대다 모델은 다수의 사용자 스레드를 다수의 커널 스레드에 매핑하는 반면, 두 수준 모델은 다대다 모델을 기반으로 하되 일부 사용자 스레드를 특정 커널 스레드에 1:1로 매핑할 수 있는 기능을 추가한 모델입니다. 두 수준 모델은 다대다 모델에서 일대일 연결도 가능하게 만든 것으로, 더 유연한 스레드 관리가 가능합니다.

문제 2.5
Q: 현대 운영체제에서 가장 널리 사용되는 스레드 모델은?

다대일(Many-to-One) 모델

일대일(One-to-One) 모델

다대다(Many-to-Many) 모델

무대무(Zero-to-Zero) 모델

A: 2번. 현대 운영체제에서는 일대일 모델이 가장 널리 사용됩니다. Windows, Linux, Solaris 등 많은 운영체제가 이 모델을 채택하고 있습니다.

3. 스레드 라이브러리 (Thread Libraries)
문제 3.1
Q: 스레드 라이브러리의 구현 방식 중 라이브러리 함수 호출이 시스템 콜이 아닌 사용자 공간의 지역 함수를 호출하는 방식은?

커널 수준 라이브러리

사용자 수준 라이브러리

혼합 수준 라이브러리

동적 수준 라이브러리

A: 2번. 사용자 수준 라이브러리는 커널의 지원 없이 완전히 사용자 공간에서 제공되며, 함수 호출이 시스템 콜이 아닌 사용자 공간의 지역 함수를 호출하는 방식입니다.

문제 3.2
Q: POSIX Pthreads는 항상 사용자 수준 라이브러리로만 구현된다. (참/거짓)

A: 거짓. POSIX Pthreads는 사용자 수준 또는 커널 수준 라이브러리로 구현될 수 있습니다.

문제 3.3
Q: 윈도우 운영체제에서 주로 사용되는 스레드 라이브러리 유형은 무엇인가? (사용자 수준 또는 커널 수준)

A: 커널 수준 라이브러리. 윈도우는 커널 수준 스레드 라이브러리를 사용합니다.

문제 3.4
Q: 비동기 스레딩(asynchronous threading)과 동기 스레딩(synchronous threading)의 차이점을 설명하고, 각각 어떤 상황에서 주로 사용되는지 설명하시오.

A: 비동기 스레딩은 부모가 자식 스레드를 생성한 후 부모는 자신의 실행을 재개하여 부모와 자식 스레드가 서로 독립적으로 병행하게 실행되는 방식입니다. 스레드 간 데이터 공유가 거의 없으며, 다중 스레드 서버나 반응형 사용자 인터페이스 설계에 사용됩니다.

동기 스레딩은 부모 스레드가 하나 이상의 자식 스레드를 생성하고 자식 스레드 모두가 종료할 때까지 기다렸다가 자신의 실행을 재개하는 방식입니다. 스레드 간 상당한 양의 데이터 공유를 수반하며, 계산 집약적 작업의 병렬 처리에 주로 사용됩니다.

문제 3.5
Q: 다음 중 Java 스레드의 특징으로 옳지 않은 것은?

Java 프로그램에서 직접 스레드 생성과 관리가 가능하다.

Java Virtual Machine에서 진행된다.

호스트 시스템에서 사용 가능한 스레드 라이브러리와 무관하게 독립적으로 동작한다.

Windows, UNIX, Linux, macOS 등 다양한 플랫폼에서 사용할 수 있다.

A: 3번. Java 스레드는 호스트 시스템에서 사용 가능한 스레드 라이브러리와 무관하게 독립적으로 동작하지 않습니다. Java Virtual Machine에서 진행되기 때문에 호스트 운영체제에 따라 달라지며, 호스트 시스템에서 사용 가능한 스레드 라이브러리를 이용하여 구현됩니다.

4. 암묵적 스레딩 (Implicit Threading)
문제 4.1
Q: 암묵적 스레딩(Implicit Threading)의 주요 목적으로 가장 적절한 것은?

스레드 생성과 관리의 책임을 개발자에게 부여하여 더 정밀한 제어를 가능하게 한다.

스레드 생성과 관리의 책임을 컴파일러와 런타임 라이브러리에게 넘겨 개발자의 부담을 줄인다.

스레드 사용을 최소화하여 오버헤드를 줄인다.

멀티코어 시스템에서만 동작하는 스레드 모델을 제공한다.

A: 2번. 암묵적 스레딩은 스레드의 생성과 관리 책임을 앱 개발자로부터 컴파일러와 실행시간 라이브러리에게 넘기는 것으로, 응용 프로그램 설계의 어려움을 극복하고 병행 및 병렬 앱 설계를 도와줍니다.

문제 4.2
Q: 스레드 풀(Thread Pool)은 필요할 때마다 새로운 스레드를 생성하여 작업을 수행하는 방식으로, 스레드 생성 오버헤드를 줄이는 데 도움이 된다. (참/거짓)

A: 거짓. 스레드 풀은 프로세스를 시작할 때 일정한 수의 스레드를 미리 풀로 만들어두는 것으로, 필요할 때마다 새로운 스레드를 생성하는 대신 이미 생성된 스레드를 활용하여 스레드 생성 오버헤드를 줄입니다.

문제 4.3
Q: 암묵적 스레딩에서 개발자가 병렬로 실행할 수 있는 작업을 식별하면, 이를 별도의 스레드에 매핑하는 모델은 무엇인가?

A: 다대다(Many-to-Many) 모델. 암묵적 스레딩에서는 응용 프로그램 개발자가 병렬로 실행할 수 있는 작업을 식별하면, 런타임 라이브러리가 다대다 모델을 사용하여 이를 별도의 스레드에 매핑합니다.

문제 4.4
Q: 스레드 풀(Thread Pool)의 장점과 스레드 풀 크기를 결정할 때 고려해야 할 요소들을 설명하시오.

A: 스레드 풀의 장점:

스레드 생성보다 기존 스레드를 재사용하는 것이 더 빠름

존재할 수 있는 스레드 개수에 제한을 둠

작업 생성 방법과 실행 방법을 분리하여 다양한 실행 정책 적용 가능

스레드 풀 크기 결정 시 고려 요소:

CPU의 수

물리 메모리 양

동시 요청 클라이언트 최대 개수

I/O 집약적 작업과 CPU 집약적 작업의 비율

시스템 부하에 따른 동적 조절 가능성

문제 4.5
Q: 다음 중 Windows API에서 스레드 풀과 관련된 함수로 옳은 것은?

CreateThread()

QueueUserWorkItem()

pthread_create()

fork()

A: 2번. Windows API에서는 QueueUserWorkItem() 함수를 통해 스레드 풀에 작업을 제출할 수 있습니다.

5. 프로세스 vs 스레드 비교 (Process vs Thread comparison)
문제 5.1
Q: 다음 중 프로세스와 스레드의 차이점으로 옳지 않은 것은?

프로세스는 독립적인 주소 공간을 가지지만, 스레드는 프로세스의 주소 공간을 공유한다.

프로세스 간 통신은 IPC 메커니즘이 필요하지만, 스레드 간 통신은 공유 메모리를 통해 직접 가능하다.

프로세스는 최소 하나 이상의 스레드를 포함한다.

스레드는 프로세스보다 컨텍스트 스위칭 비용이 더 크다.

A: 4번. 스레드는 프로세스보다 컨텍스트 스위칭 비용이 더 작습니다. 스레드는 프로세스 내에서 자원을 공유하기 때문에 컨텍스트 스위칭 시 교체해야 할 정보가 적어 더 빠르게 처리됩니다.

문제 5.2
Q: 멀티 프로세스 방식은 프로세스 간 독립성을 보장하여 하나의 프로세스가 문제를 일으켜도 다른 프로세스에 영향을 주지 않지만, 멀티 스레드 방식은 하나의 스레드에 문제가 생기면 같은 프로세스의 다른 스레드들도 영향을 받을 수 있다. (참/거짓)

A: 참. 멀티 프로세스는 각 프로세스가 독립적인 주소 공간을 가지므로 한 프로세스의 오류가 다른 프로세스에 영향을 주지 않습니다. 반면 멀티 스레드는 같은 프로세스 내의 모든 스레드가 주소 공간을 공유하므로 한 스레드의 오류가 같은 프로세스의 다른 스레드에도 영향을 미칠 수 있습니다.

문제 5.3
Q: 프로세스는 운영체제로부터 할당받는 작업의 단위이고, 스레드는 이 할당받은 자원을 이용하는 무엇의 단위인가?

A: 실행(execution)의 단위. 스레드는 할당받은 자원을 이용하는 실행의 단위입니다.

문제 5.4
Q: 멀티 프로세스 방식과 멀티 스레드 방식의 장단점을 메모리 사용, 통신 방법, 컨텍스트 스위칭 비용 측면에서 비교 설명하시오.

A: 1. 메모리 사용:

멀티 프로세스: 각 프로세스는 독립적인 메모리 공간을 가져 메모리 사용량이 많음

멀티 스레드: 스레드는 프로세스의 메모리를 공유하여 메모리 사용이 효율적

통신 방법:

멀티 프로세스: IPC(파이프, 소켓, 공유 메모리 등)를 통해 통신해야 함

멀티 스레드: 공유 메모리를 통해 직접 통신 가능

컨텍스트 스위칭 비용:

멀티 프로세스: 프로세스 간 전환 시 전체 상태를 저장/복원해야 해서 비용이 큼

멀티 스레드: 스레드는 프로세스 내 자원을 공유하므로 전환 비용이 작음

문제 5.5
Q: 다음 중 스레드가 프로세스로부터 공유하지 않는 자원은?

코드 영역(Code Section)

데이터 영역(Data Section)

스택(Stack)

힙(Heap)

A: 3번. 스택(Stack). 각 스레드는 독립적인 스택을 가지지만, 코드 영역, 데이터 영역, 힙 영역은 프로세스 내의 모든 스레드가 공유합니다.

6. 병렬성 vs 동시성 (Parallelism vs Concurrency)
문제 6.1
Q: 다음 중 '병렬성(Parallelism)'에 대한 설명으로 가장 정확한 것은?

여러 작업이 동시에 실행되는 것처럼 보이지만 실제로는 시분할로 번갈아 실행된다.

여러 작업이 물리적으로 동시에 실행된다.

단일 코어에서만 구현 가능한 개념이다.

테스크가 진행하게끔 함으로써 하나 이상의 테스크를 수행하는 방식이다.

A: 2번. 병렬성(Parallelism)은 여러 작업을 실제로 동시에 처리하는 것을 의미합니다.

문제 6.2
Q: 동시성(Concurrency)은 단일 코어 시스템에서도 구현할 수 있지만, 진정한 병렬성(Parallelism)은 멀티코어 시스템에서만 가능하다. (참/거짓)

A: 참. 동시성은 작업들이 동시에 실행되는 것처럼 보이게 하는 개념으로 단일 코어에서도 컨텍스트 스위칭을 통해 구현 가능합니다. 반면 병렬성은 여러 작업이 물리적으로 동시에 실행되므로 멀티코어 환경에서만 진정한 의미의 병렬 처리가 가능합니다.

문제 6.3
Q: 티비를 보면서 공부하는 것은 동시성의 예라면, 어떤 예가 병렬성의 좋은 예시가 될 수 있는가?

A: 노래를 들으면서 공부를 하는 것. 티비를 보면서 공부하는 것은 시간을 나눠서 번갈아 하는 동시성의 예이고, 노래를 들으면서 공부를 하는 것은 두 작업이 실제로 동시에 처리되는 병렬성의 예입니다.

문제 6.4
Q: 동시성(Concurrency)과 병렬성(Parallelism)의 차이점을 CPU 활용 방식과 작업 처리 관점에서 설명하시오.

A: CPU 활용 측면:

동시성: 단일 CPU에서 시분할을 통해 여러 작업을 번갈아 처리함으로써 동시에 실행되는 것처럼 보이게 함

병렬성: 여러 CPU 코어에서 작업들이 물리적으로 동시에 처리됨

작업 처리 관점:

동시성: 여러 작업이 진행 중이지만 특정 시점에는 하나의 작업만 실행됨

병렬성: 여러 작업이 같은 시점에 실제로 동시에 실행됨

동시성은 작업 관리에 관한 것이고, 병렬성은 실제 동시 실행에 관한 것입니다.

문제 6.5
Q: 다음 중 병렬성(Parallelism)이 동시성(Concurrency)보다 더 효과적인 상황은?

대화형 사용자 인터페이스를 갖춘 단일 코어 시스템

I/O 작업이 많은 웹 서버

대규모 데이터 처리가 필요한 멀티코어 시스템

빈번한 인터럽트 처리가 필요한 임베디드 시스템

A: 3번. 대규모 데이터 처리는 여러 코어에서 데이터를 분할하여 동시에 처리할 수 있어 병렬성의 이점을 극대화할 수 있습니다.

7. 사용자 스레드 vs 커널 스레드 (User threads vs Kernel threads)
문제 7.1
Q: 사용자 수준 스레드의 장점으로 올바른 것은?

커널의 스케줄링 결정에 직접 영향을 받아 더 효율적으로 실행된다.

한 스레드가 블록되어도 다른 스레드는 실행을 계속할 수 있다.

컨텍스트 스위칭 오버헤드가 적다.

멀티프로세서 시스템에서 병렬 실행이 가능하다.

A: 3번. 사용자 수준 스레드는 스케줄링 결정이나 동기화를 위해 커널을 호출하지 않기 때문에 컨텍스트 스위칭 오버헤드가 적습니다.

문제 7.2
Q: 커널 수준 스레드는 운영체제에 의해 직접 관리되므로 한 스레드가 블록되어도 다른 스레드가 실행될 수 있지만, 컨텍스트 스위칭 오버헤드가 발생한다. (참/거짓)

A: 참. 커널 수준 스레드는 운영체제에 의해 직접 관리되므로 한 스레드가 블록되어도 다른 스레드는 독립적으로 실행될 수 있습니다. 그러나 스레드 전환 시 커널 모드로의 전환이 필요해 컨텍스트 스위칭 오버헤드가 발생합니다.

문제 7.3
Q: 사용자 수준 스레드에서 커널 레벨의 스케줄링 없이 스레드 전환이 가능한 이유는 무엇인가?

A: 사용자 수준 스레드는 라이브러리에 의해 사용자 공간에서 관리되므로, 스레드 전환 시 커널 스케줄러를 호출할 필요 없이 라이브러리 함수로 전환이 가능하기 때문입니다.

문제 7.4
Q: 사용자 수준 스레드와 커널 수준 스레드의 장단점을 보안, 성능, 확장성 측면에서 비교 설명하시오.

A: 보안 측면:

사용자 수준 스레드: 커널 레벨의 보안 기능 없이 라이브러리가 공유 변수 보호를 구현해야 해서 취약함

커널 수준 스레드: 운영체제의 보안 메커니즘을 활용할 수 있어 더 안전함

성능 측면:

사용자 수준 스레드: 커널 호출과 모드 전환이 적어 컨텍스트 스위칭 오버헤드가 작음

커널 수준 스레드: 커널 모드 전환이 필요해 오버헤드가 크지만, 시스템 콜 차단 시 전체 프로세스가 블록되지 않음

확장성 측면:

사용자 수준 스레드: 멀티코어 활용이 제한적이어서 확장성이 낮음

커널 수준 스레드: 멀티프로세서 활용이 가능해 확장성이 높음

문제 7.5
Q: 다음 중 커널 수준 스레드의 단점으로 올바른 것은?

한 스레드가 블록되면 전체 프로세스가 블록된다.

멀티프로세서 시스템에서 병렬 실행이 불가능하다.

시스템 콜이 필요하여 오버헤드가 크다.

스레드 간 통신이 어렵다.

A: 3번. 커널 수준 스레드는 생성과 관리를 위해 시스템 콜이 필요하며, 컨텍스트 스위칭 시 프로세서 모드가 사용자 모드와 커널 모드 사이를 전환해야 하므로 오버헤드가 큽니다.

8. 스레드 모델: 다대일, 일대일, 다대다, 두 수준 (Thread models)
문제 8.1
Q: 다음 중 '다대일(Many-to-One)' 스레드 모델의 단점으로 올바른 것은?

각 사용자 스레드마다 커널 스레드를 생성해야 하므로 오버헤드가 크다.

한 스레드가 봉쇄되면 전체 프로세스가 봉쇄된다.

스레드 간 동기화가 어렵다.

커널 스레드의 수가 고정되어 확장성이 제한된다.

A: 2번. 다대일 모델에서는 여러 사용자 스레드가 하나의 커널 스레드에 매핑되므로, 하나의 사용자 스레드가 봉쇄형 시스템 콜을 호출하면 전체 프로세스가 봉쇄됩니다.

문제 8.2
Q: 일대일(One-to-One) 모델은 각 사용자 스레드에 대응하는 커널 스레드가 있어 병렬 실행이 가능하지만, 사용자 스레드 수에 따라 커널 스레드 수가 증가하여 시스템 성능에 부담을 줄 수 있다. (참/거짓)

A: 참. 일대일 모델은 각 사용자 스레드마다 커널 스레드를 생성해야 하므로, 사용자 스레드가 많아지면 그만큼 커널 스레드도 많아져 시스템 성능에 부담을 줄 수 있습니다.

문제 8.3
Q: 다대다(Many-to-Many) 모델과 일대일(One-to-One) 모델의 장점을 결합한 스레드 모델은 무엇인가?

A: 두 수준(Two-level) 모델. 이 모델은 다대다 모델을 기본으로 하되, 특정 사용자 스레드를 특정 커널 스레드에 1:1로 바인딩할 수 있는 기능을 추가한 모델입니다.

문제 8.4
Q: '다대다(Many-to-Many)' 스레드 모델이 어떻게 다대일 모델의 봉쇄 문제와 일대일 모델의 오버헤드 문제를 동시에 해결하는지 설명하시오.

A: 다대다 모델은 다수의 사용자 스레드를 다수의 커널 스레드에 매핑함으로써 두 모델의 문제를 해결합니다:

다대일 모델의 봉쇄 문제 해결: 여러 커널 스레드가 있어 한 스레드가 봉쇄되어도 다른 커널 스레드를 통해 사용자 스레드들이 계속 실행될 수 있습니다.

일대일 모델의 오버헤드 문제 해결: 사용자 스레드 수보다 적은 수의 커널 스레드를 사용하여 매핑함으로써 과도한 커널 스레드 생성으로 인한 오버헤드를 줄일 수 있습니다.

따라서 다대다 모델은 적절한 수의 커널 스레드로 다수의 사용자 스레드를 효율적으로 실행할 수 있는 균형점을 제공합니다.

문제 8.5
Q: 다음 중 현대 운영체제에서 대부분 지원하는 스레드 모델은?

다대일(Many-to-One) 모델

일대일(One-to-One) 모델

다대다(Many-to-Many) 모델

세 수준(Three-level) 모델

A: 2번. 현대 운영체제에서는 대부분 일대일(One-to-One) 모델을 지원합니다. Windows, Linux, Solaris 등 많은 운영체제가 이 모델을 채택하고 있습니다.

9. 병렬 처리를 위한 암달의 법칙 (Amdahl's Law)
문제 9.1
Q: 암달의 법칙(Amdahl's Law)이 설명하는 핵심 개념은?

프로세서 개수를 늘릴수록 시스템 성능이 선형적으로 증가한다.

병렬화할 수 없는 프로그램 부분이 전체 성능 향상의 한계를 설정한다.

메모리 용량이 증가할수록 시스템 성능이 향상된다.

동시 사용자 수에 따라 시스템 성능이 결정된다.

A: 2번. 암달의 법칙에 따르면, 프로그램의 병렬화할 수 없는 순차적 부분이 전체 성능 향상의 한계를 결정합니다.

문제 9.2
Q: 암달의 법칙에 따르면, 프로그램의 40%가 순차적으로 실행되어야 한다면, 이론적으로 최대 2.5배까지만 성능을 향상시킬 수 있다. (참/거짓)

A: 참. 암달의 법칙에 따르면, 순차적으로 실행되어야 하는 부분이 40%라면 1/(1-0.6) = 1/0.4 = 2.5배가 최대 성능 향상의 한계입니다.

문제 9.3
Q: 암달의 법칙에서 N이 무한대로 갈 때 성능 향상의 최대치는 무엇에 의해 결정되는가?

A: 순차적으로 실행되어야 하는 부분(S)의 비율. 암달의 법칙에서 N이 무한대로 갈 때, 성능 향상은 1/S로 수렴합니다. 즉, 병렬화할 수 없는 순차적 부분의 비율이 성능 향상의 최대치를 결정합니다.

문제 9.4
Q: 프로그램의 80%를 병렬화할 수 있을 때, 코어 수를 2개, 4개, 8개, 16개로 늘릴 경우 각각 얼마만큼의 성능 향상을 기대할 수 있는지 암달의 법칙을 사용하여 계산하고 설명하시오.

A: 암달의 법칙: 속도 향상 = 1 / ((1-P) + P/N)
P = 병렬화 가능 비율 = 0.8
S = 순차 실행 비율 = 0.2

코어 2개: 1 / (0.2 + 0.8/2) = 1 / 0.6 = 1.67배
코어 4개: 1 / (0.2 + 0.8/4) = 1 / 0.4 = 2.5배
코어 8개: 1 / (0.2 + 0.8/8) = 1 / 0.3 = 3.33배
코어 16개: 1 / (0.2 + 0.8/16) = 1 / 0.25 = 4배

코어 수를 늘릴수록 성능 향상이 있지만, 그 증가율은 점점 감소합니다. 이론적 최대 성능 향상은 1/0.2 = 5배로, 코어를 무한히 늘려도 5배 이상의 성능 향상은 불가능합니다.

문제 9.5
Q: 다음 중 암달의 법칙과 관련된 설명으로 옳지 않은 것은?

병렬화 가능한 부분이 클수록 성능 향상의 잠재력이 커진다.

코어 수가 증가할수록 성능 향상 곡선은 평탄해진다.

병렬화할 수 없는 부분이 전체 성능의 병목이 된다.

항상 코어 수에 비례하여 성능이 향상된다.

A: 4번. 암달의 법칙에 따르면 성능은 코어 수에 비례하여 향상되지 않습니다. 코어 수가 증가할수록 성능 향상 폭은 점점 줄어들며, 순차적 부분의 비율에 의해 최대 성능 향상이 제한됩니다.

10. 스레드 상태 전이 (Thread state transitions)
문제 10.1
Q: 스레드가 sleep() 메서드를 호출한 후 전이되는 상태는?

RUNNABLE

WAITING

TIMED_WAITING

BLOCKED

A: 3번. sleep() 메서드를 호출하면 스레드는 TIMED_WAITING 상태로 전이됩니다.

문제 10.2
Q: 스레드가 join() 메서드를 호출할 때, 시간을 명시하지 않으면 WAITING 상태로 전이되고, 시간을 명시하면 TIMED_WAITING 상태로 전이된다. (참/거짓)

A: 참. join() 메서드를 호출할 때 시간을 명시하지 않으면 WAITING 상태로, 시간을 명시하면 TIMED_WAITING 상태로 전이됩니다.

문제 10.3
Q: 스레드가 I/O 작업이나 Lock 획득을 기다리는 동안 머무는 상태는 무엇인가?

A: BLOCKED 상태. 스레드가 I/O 작업이나 Lock 획득을 기다리는 동안에는 BLOCKED 상태에 머무릅니다.

문제 10.4
Q: 스레드의 RUNNABLE, BLOCKED, WAITING, TIMED_WAITING 상태 간의 전이 과정을 설명하고, 각 상태에서 다른 상태로 전이되는 조건을 설명하시오.

A: - RUNNABLE → BLOCKED: 스레드가 synchronized 블록/메서드에 진입하려고 할 때 lock을 획득하지 못하거나, I/O 작업을 기다릴 때

BLOCKED → RUNNABLE: 스레드가 lock을 획득하거나 I/O 작업이 완료될 때

RUNNABLE → WAITING: 스레드가 Object.wait(), Thread.join() 등을 호출할 때

WAITING → RUNNABLE: Object.notify()/notifyAll()이 호출되거나, 기다리던 스레드가 종료될 때

RUNNABLE → TIMED_WAITING: 스레드가 Thread.sleep(time), Object.wait(time), Thread.join(time) 등을 호출할 때

TIMED_WAITING → RUNNABLE: 지정된 시간이 경과하거나, notify()/notifyAll()이 호출되거나, 인터럽트가 발생할 때

문제 10.5
Q: 다음 중 스레드의 '준비(Ready)' 상태에 대한 설명으로 가장 적절한 것은?

스레드가 CPU를 할당받아 실행 중인 상태이다.

스레드가 I/O 작업을 기다리는 상태이다.

스레드가 CPU를 할당받기 위해 기다리고 있는 상태이다.

스레드가 종료된 상태이다.

A: 3번. 준비(Ready) 상태는 스레드가 실행될 준비가 되어 CPU를 할당받기 위해 기다리고 있는 상태를 의미합니다.

11. 스레드 생성 및 성능 고려 사항 (Thread creation and performance considerations)
문제 11.1
Q: 다음 중 스레드 풀(Thread Pool)을 사용하는 주된 이유로 가장 적절한 것은?

스레드 간 통신을 단순화하기 위해

스레드 생성 및 소멸의 오버헤드를 줄이기 위해

스레드의 우선순위를 쉽게 관리하기 위해

스레드 동기화 문제를 해결하기 위해

A: 2번. 스레드 풀의 주된 목적은 스레드를 미리 생성해두고 재사용함으로써 스레드 생성 및 소멸에 따른 오버헤드를 줄이는 것입니다.

문제 11.2
Q: 스레드 수를 CPU 코어 수보다 훨씬 많이 생성하면 컨텍스트 스위칭 오버헤드가 증가하여 성능이 저하될 수 있다. (참/거짓)

A: 참. 스레드 수가 CPU 코어 수보다 훨씬 많으면 스레드 간 컨텍스트 스위칭이 자주 발생하게 되어 오버헤드가 증가하고 CPU 캐시 효율성이 감소하여 성능이 저하될 수 있습니다.

문제 11.3
Q: CPU 집약적 작업을 위한 이상적인 스레드 풀 크기는 보통 무엇을 기준으로 결정하는가?

A: CPU 코어의 수. CPU 집약적 작업은 CPU 자원을 주로 사용하므로, 일반적으로 스레드 풀 크기를 CPU 코어 수와 비슷하게 설정하는 것이 효율적입니다.

문제 11.4
Q: I/O 집약적 작업과 CPU 집약적 작업에서 최적의 스레드 수를 결정하는 방법의 차이점을 설명하시오.

A: I/O 집약적 작업:

스레드가 주로 I/O 작업을 대기하는 시간이 많아 CPU를 효율적으로 사용하지 못함

CPU 코어 수보다 더 많은 스레드를 사용하는 것이 유리함

일반적으로 코어 수의 몇 배(예: 2배~4배)로 설정하거나, I/O 작업의 특성과 지연 시간에 따라 결정

CPU 집약적 작업:

스레드가 대부분의 시간을 CPU 연산에 사용함

CPU 코어 수와 비슷하거나 약간 많게 스레드 수를 설정하는 것이 효율적

코어 수보다 너무 많은 스레드를 사용하면 컨텍스트 스위칭 오버헤드로 성능이 저하됨

문제 11.5
Q: 다음 중 동시에 활성화된 스레드 수가 많을 때 발생할 수 있는 문제가 아닌 것은?

메모리 사용량 증가

컨텍스트 스위칭 오버헤드 증가

CPU 캐시 효율성 감소

스레드 간 데이터 공유 속도 향상

A: 4번. 동시에 활성화된 스레드 수가 많을 때는 스레드 간 데이터 공유 속도가 향상되는 것이 아니라, 오히려 캐시 일관성 유지를 위한 추가 작업으로 인해 공유 데이터 접근 속도가 저하될 수 있습니다.

문제 해결을 위한 도전 과제
각 주제별로 제시된 문제들은 운영체제에서 다루는 멀티코어 프로그래밍과 스레드 관련 개념의 이해를 돕기 위한 것입니다. 이러한 개념들은 현대 운영체제와 응용 프로그램에서 매우 중요한 역할을 합니다.

이론적 이해를 바탕으로 Linux 환경에서 직접 스레드 프로그래밍을 해보고, 다양한 스레드 모델과 동기화 기법을 실습해 보는 것이 학습에 큰 도움이 될 것입니다. 문제에서 다룬 개념들이 실제로 어떻게 구현되고 적용되는지 확인함으로써 더 깊은 이해를 얻을 수 있습니다.

