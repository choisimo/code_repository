# 운영체제 IPC 및 네트워크 통신 심화 학습 문제집

운영체제의 프로세스 간 통신(IPC)과 네트워크 통신에 관한 개념들 중 헷갈리기 쉬운 부분들을 문제 형태로 정리했습니다. 각 주제별로 심화 이해가 필요한 문제들을 통해 개념을 명확히 할 수 있습니다.

## 1. Interprocess Communication (IPC) 모델

### 문제 1
다음 중 커널의 관여 없이 진행되는 IPC 모델은?
- A) Message Passing
- B) Shared Memory
- C) Pipe
- D) Socket

**정답: B) Shared Memory**

**설명**: Shared Memory 모델에서는 초기 설정 시에만 커널이 관여하고, 이후에는 커널의 관여 없이 프로세스들이 직접 공유 메모리 영역에 접근하여 통신합니다[1].

### 문제 2
Shared Memory 모델에서 프로세스 A가 공유 메모리에 데이터를 전달했을 때, 프로세스 B가 이를 인식하지 못하는 문제를 해결하기 위해 필요한 것은?
- A) 통신 프로토콜
- B) 더 큰 메모리 할당
- C) 동기화 메커니즘
- D) 커널 개입

**정답: C) 동기화 메커니즘**

**설명**: Shared Memory 모델에서는 데이터를 읽어야 하는 시점을 알 수 없기 때문에 별도의 동기화 기술이 필요합니다[1].

### 문제 3
시스템 V IPC와 POSIX IPC의 차이점으로 가장 적절하지 않은 것은?
- A) POSIX IPC는 파일 시스템 기반 네이밍을 사용한다
- B) POSIX IPC는 기능적으로 더 많은 옵션을 제공한다
- C) System V IPC는 더 오래된 코드에서 많이 사용된다
- D) POSIX IPC는 성능이 항상 System V보다 느리다

**정답: D) POSIX IPC는 성능이 항상 System V보다 느리다**

**설명**: POSIX IPC는 System V에 비해 기능적으로 좋지만, 성능이 항상 느리다는 것은 사실이 아닙니다. 각각 상황에 따라 성능 차이가 있을 수 있습니다[8].

### 문제 4
IPC 모델 중 가장 빠른 성능을 제공하지만 구현이 복잡한 것은?
- A) Pipes
- B) Shared Memory
- C) Message Queues
- D) Signals

**정답: B) Shared Memory**

**설명**: Shared Memory는 커널의 관여 없이 메모리를 직접 사용하여 속도가 빠르지만, 여러 프로세스가 사용하므로 구현이 어렵고 관리가 힘듭니다[17].

### 문제 5
메시지큐에서 메시지는 어디에 저장되어 관리되는가?
- A) 각 프로세스의 힙 메모리에 저장된다
- B) 가상 파일 시스템에 저장된다
- C) 커널 메모리에 저장된다
- D) 프로세스 간 공유된 메모리 블록에 저장된다

**정답: C) 커널 메모리에 저장된다**

**설명**: 메시지는 커널에서 보관하기 때문에 프로세스가 종료되어도 사라지지 않으며, 큐의 용량이 허용하는 한 계속 쌓이고 읽은 메시지는 큐에서 삭제됩니다[9].

## 2. Cooperating Processes 개념

### 문제 1
독립적 프로세스(Independent Process)와 협력적 프로세스(Cooperating Process)의 차이점으로 옳은 것은?
- A) 독립적 프로세스는 항상 더 빠르게 실행된다
- B) 협력적 프로세스는 다른 프로세스의 실행에 영향을 주거나 받는다
- C) 독립적 프로세스는 항상 하나의 CPU 코어만 사용한다
- D) 협력적 프로세스는 항상 같은 메모리 영역에서 실행된다

**정답: B) 협력적 프로세스는 다른 프로세스의 실행에 영향을 주거나 받는다**

**설명**: Cooperating process는 다른 process의 실행에 영향을 주거나 받으며, 정보 공유, 연산 속도 증가, 모듈화 등의 목적으로 사용됩니다[2].

### 문제 2
다음 중 프로세스 협력을 위한 IPC 방식으로 물리적 링크와 논리적 링크의 관계가 올바르게 설명된 것은?
- A) 물리적 링크와 논리적 링크는 항상 동일한 방식으로 구현된다
- B) 물리적 링크는 shared memory일 수 있고, 논리적 링크는 message passing을 사용할 수 있다
- C) 물리적 링크는 항상 message passing이고 논리적 링크는 항상 shared memory이다
- D) 논리적 링크는 물리적 링크보다 항상 더 빠른 성능을 제공한다

**정답: B) 물리적 링크는 shared memory일 수 있고, 논리적 링크는 message passing을 사용할 수 있다**

**설명**: physical link는 shared memory를 사용하더라도, logical link는 message passing을 이용하는 경우가 있습니다. 즉, 구현과 인터페이스가 다를 수 있습니다[2].

### 문제 3
협력 프로세스에서 race condition이 발생하는 주된 원인은?
- A) 프로세스들의 CPU 사용량이 너무 높을 때
- B) 여러 프로세스가 공유 데이터에 동시에 접근할 때
- C) 프로세스 간 통신이 전혀 없을 때
- D) 모든 프로세스가 동일한 우선순위를 가질 때

**정답: B) 여러 프로세스가 공유 데이터에 동시에 접근할 때**

**설명**: Race condition은 두개 이상의 프로세스가 공유변수에 동시에 참여해서 공유변수의 값이 꼬이게 되는 문제입니다[20].

### 문제 4
협력 프로세스가 필요한 상황이 아닌 것은?
- A) 정보 공유가 필요할 때
- B) 연산 속도를 높일 때
- C) 모듈화를 위해
- D) 하나의 독립적인 태스크만 처리할 때

**정답: D) 하나의 독립적인 태스크만 처리할 때**

**설명**: 협력 프로세스는 정보 공유, 계산 속도 향상, 모듈화, 편의성 등을 위해 사용됩니다. 독립적인 하나의 태스크만 처리할 때는 협력 프로세스가 필요하지 않습니다[2].

### 문제 5
다음 중 협력 프로세스의 장점이 아닌 것은?
- A) 자원 공유를 통한 효율성 증가
- B) 계산 속도 증가
- C) 모듈화를 통한 프로그램 구조 개선
- D) 프로세스 간 동기화 필요성 제거

**정답: D) 프로세스 간 동기화 필요성 제거**

**설명**: 협력 프로세스는 오히려 프로세스 간 동기화의 필요성을 증가시킵니다. 자원을 공유하기 때문에 동기화를 올바르게 구현해야 race condition과 같은 문제를 피할 수 있습니다[2][14].

## 3. Shared Memory 메커니즘

### 문제 1
다음 중 Shared Memory 사용 시 반드시 필요한 것은?
- A) 네트워크 연결
- B) 키(key) 또는 이름 식별자
- C) 파일 시스템 마운트
- D) 루트 권한

**정답: B) 키(key) 또는 이름 식별자**

**설명**: 공유 메모리를 사용하기 위해서는 key_t 키값 또는 POSIX에서는 이름을 통해 공유 메모리 세그먼트를 식별합니다[3][8].

### 문제 2
다음 중 공유 메모리에서 shmget() 함수의 역할로 옳은 것은?
- A) 공유 메모리에 데이터를 쓴다
- B) 공유 메모리 ID를 가져오거나 생성한다
- C) 공유 메모리에서 데이터를 읽는다
- D) 공유 메모리를 프로세스 주소 공간에 맵핑한다

**정답: B) 공유 메모리 ID를 가져오거나 생성한다**

**설명**: shmget()은 shared memory id 값을 가져오는 함수로, 필요에 따라 생성도 가능합니다[3][8].

### 문제 3
공유 메모리를 사용하는 프로세스가 기존 공유 메모리를 새로 생성하지 않고 기존 것을 사용하고 싶을 때 적절한 플래그 조합은?
- A) IPC_CREAT | IPC_EXCL
- B) IPC_CREAT만 사용
- C) IPC_EXCL만 사용
- D) 플래그 없이 사용

**정답: B) IPC_CREAT만 사용**

**설명**: IPC_CREAT만 사용하면 key에 해당하는 메시지큐가 없으면 새로 생성하고, 있으면 이미 존재하는 msqid를 반환합니다[8][9].

### 문제 4
다음 중 공유 메모리 사용 시 발생할 수 있는 문제가 아닌 것은?
- A) 데이터 읽어야 하는 시점을 알 수 없음
- B) 동시에 같은 메모리 위치에 접근 시 충돌
- C) 네트워크 지연으로 인한 데이터 손실
- D) 별도의 동기화 메커니즘 필요

**정답: C) 네트워크 지연으로 인한 데이터 손실**

**설명**: 공유 메모리는 네트워크를 사용하지 않고 동일 시스템 내에서 메모리를 직접 공유하므로 네트워크 지연 문제가 발생하지 않습니다[1][8].

### 문제 5
POSIX 공유 메모리에서 shm_open() 이후 반드시 수행해야 하는 작업은?
- A) close()
- B) ftruncate()
- C) mmap()
- D) munmap()

**정답: B) ftruncate()**

**설명**: POSIX 공유 메모리에서는 shm_open() 후 반드시 ftruncate()를 통해 공유 메모리의 크기를 설정해야 하며, 그 후 mmap()을 통해 메모리를 맵핑합니다[18].

## 4. Message Passing 기법

### 문제 1
Message Passing 모델의 단점으로 가장 적절한 것은?
- A) 메시지 크기가 제한적이다
- B) 서로 다른 시스템 간에 사용할 수 없다
- C) 커널을 통해 데이터를 주고받기 때문에 Shared Memory보다 느리다
- D) 항상 동기화 문제가 발생한다

**정답: C) 커널을 통해 데이터를 주고받기 때문에 Shared Memory보다 느리다**

**설명**: 메시지 전달 모델은 커널을 통해서 데이터를 주고받기 때문에 Shared Memory 모델보다 느립니다[1].

### 문제 2
Direct Communication에서 프로세스 간 링크의 특성으로 옳지 않은 것은?
- A) 프로세스 간 링크는 유일하다
- B) 대부분 양방향으로 구성된다
- C) 한 링크가 여러 프로세스를 연결할 수 있다
- D) 통신하려는 프로세스의 이름을 명시적으로 표시해야 한다

**정답: C) 한 링크가 여러 프로세스를 연결할 수 있다**

**설명**: Direct Communication에서는 프로세스 간 링크가 유일하며, 한 링크가 정확히 두 프로세스 사이에만 연관됩니다[6].

### 문제 3
Message Passing에서 메시지의 크기가 지정된 크기보다 클 경우, 지정된 크기만큼만 메시지를 전송하도록 하는 msgsnd() 플래그는?
- A) IPC_NOWAIT
- B) MSG_NOERROR
- C) IPC_EXCL
- D) MSG_TRUNCATE

**정답: B) MSG_NOERROR**

**설명**: MSG_NOERROR를 사용하면 메시지 크기가 지정된 크기보다 클 경우, 지정된 크기(msgsz)만큼만 메시지를 전송합니다[9].

### 문제 4
다음 중 POSIX 메시지 큐에서 mq_open() 함수 사용 시 비차단 방식으로 메시지 큐를 열기 위한 플래그는?
- A) O_CREAT
- B) O_RDWR
- C) O_NONBLOCK
- D) O_EXCL

**정답: C) O_NONBLOCK**

**설명**: O_NONBLOCK 플래그를 사용하면 비블록 형식으로 메시지큐를 열어 mq_send나 mq_receive 시 메시지가 없으면 기다리지 않고 바로 반환됩니다[19].

### 문제 5
다음 중 Indirect Communication의 특징으로 옳지 않은 것은?
- A) 메일박스나 포트를 통해 메시지를 주고받는다
- B) 통신하는 프로세스들 사이에 여러 다른 연결이 존재할 수 있다
- C) 연결(link)은 항상 한 쌍의 프로세스 사이에만 존재한다
- D) 프로세스는 공유 메일박스를 가질 때 연결이 구축된다

**정답: C) 연결(link)은 항상 한 쌍의 프로세스 사이에만 존재한다**

**설명**: Indirect Communication에서 연결(link)은 두 개 이상의 프로세스들과 연관될 수 있으며, 여러 다른 프로세스가 같은 메일박스를 통해 통신할 수 있습니다[6].

## 5. Producer-Consumer Problem

### 문제 1
생산자-소비자 문제에서 다음 중 발생할 수 있는 문제 상황이 아닌 것은?
- A) 생산자가 가득 찬 버퍼에 데이터를 추가하려는 상황
- B) 소비자가 빈 버퍼에서 데이터를 가져오려는 상황
- C) 여러 생산자가 동시에 버퍼에 데이터를 추가하려는 상황
- D) 소비자가 항상 생산자보다 빠르게 데이터를 소비하는 상황

**정답: D) 소비자가 항상 생산자보다 빠르게 데이터를 소비하는 상황**

**설명**: 소비자가 생산자보다 빠른 것은 단순히 처리 속도의 문제이며, 동기화 문제를 일으키지 않습니다. 나머지 상황들은 모두 동기화 문제를 일으킬 수 있습니다[5][15].

### 문제 2
생산자-소비자 문제를 세마포어로 해결할 때, 생산자 코드에서 가장 먼저 실행해야 할 세마포어 연산은?
- A) wait(full)
- B) wait(empty)
- C) wait(mutex)
- D) signal(full)

**정답: B) wait(empty)**

**설명**: 생산자는 먼저 버퍼에 빈 공간이 있는지 확인해야 하므로 wait(empty) 연산을 먼저 수행해야 합니다[5][15].

### 문제 3
생산자-소비자 문제에서 busy wait을 피하기 위해 사용하는 방법은?
- A) 더 큰 버퍼 사용하기
- B) 더 많은 생산자와 소비자 생성하기
- C) 세마포어와 같은 동기화 기법 사용하기
- D) 더 빠른 CPU 사용하기

**정답: C) 세마포어와 같은 동기화 기법 사용하기**

**설명**: busy wait을 회피하기 위해 세마포어를 사용합니다. 버퍼가 가득차면 생산자에게 세마포어가 block 처리를 하여 CPU가 무한루프를 돌지 않도록 합니다[15].

### 문제 4
다음 중 생산자-소비자 문제에서 race condition이 발생할 수 있는 시나리오는?
- A) 소비자가 버퍼가 비어있는지 확인하는 도중 스케줄링이 발생하여 생산자가 데이터를 추가하는 경우
- B) 생산자만 실행되고 소비자는 전혀 실행되지 않는 경우
- C) 소비자의 처리 속도가 생산자보다 매우 느린 경우
- D) 메모리 부족으로 버퍼를 할당할 수 없는 경우

**정답: A) 소비자가 버퍼가 비어있는지 확인하는 도중 스케줄링이 발생하여 생산자가 데이터를 추가하는 경우**

**설명**: 이는 전형적인 race condition 상황으로, 소비자가 공유 변수에 접근하여 확인하는 도중 스케줄링이 발생하여 생산자가 상태를 변경하게 되는 경우입니다[20].

### 문제 5
생산자-소비자 문제에서 사용되는 세마포어 중 버퍼에 대한 상호배제를 위한 세마포어의 초기값은?
- A) 0
- B) 1
- C) 버퍼 크기
- D) -1

**정답: B) 1**

**설명**: 버퍼 풀을 접근하기 위한 상호 배제 기능을 제공하는 Mutex 세마포어는 1로 초기화됩니다[5].

## 6. Bounded and Unbounded Buffer

### 문제 1
유한 버퍼(Bounded Buffer)가 가득 찬 상태에서 생산자가 더 많은 데이터를 생산하려 할 때 발생하는 현상은?
- A) 버퍼가 자동으로 확장된다
- B) 가장 오래된 데이터가 자동으로 삭제된다
- C) 예외가 발생하거나 생산자가 차단된다
- D) 새 데이터가 이전 데이터를 덮어쓴다

**정답: C) 예외가 발생하거나 생산자가 차단된다**

**설명**: 유한 버퍼가 가득 차면 생산자는 더 이상 생산할 수 없고, 세마포어를 사용하는 경우 block 처리되어 소비자가 버퍼에서 항목을 제거할 때까지 기다립니다[5][14][15].

### 문제 2
무한 버퍼(Unbounded Buffer)와 유한 버퍼(Bounded Buffer)의 차이점으로 옳지 않은 것은?
- A) 무한 버퍼는 생산자가 항상 차단되지 않는다
- B) 유한 버퍼는 메모리 사용량이 제한적이다
- C) 무한 버퍼는 실제로는 시스템 메모리 제한까지만 확장 가능하다
- D) 유한 버퍼는 소비자 차단 문제가 발생하지 않는다

**정답: D) 유한 버퍼는 소비자 차단 문제가 발생하지 않는다**

**설명**: 유한 버퍼든 무한 버퍼든 버퍼가 비어있으면 소비자는 차단됩니다. 차이점은 생산자 측면에서 유한 버퍼는 가득 차면 차단되지만, 무한 버퍼는 그렇지 않다는 점입니다[5].

### 문제 3
한정 버퍼 문제(Bounded-Buffer Problem)를 해결하기 위한 세마포어 설정으로 옳은 것은?
- A) Mutex: 0, Full: 버퍼 크기, Empty: 0
- B) Mutex: 1, Full: 0, Empty: 버퍼 크기
- C) Mutex: 버퍼 크기, Full: 0, Empty: 1
- D) Mutex: 1, Full: 버퍼 크기, Empty: 0

**정답: B) Mutex: 1, Full: 0, Empty: 버퍼 크기**

**설명**: Mutex는 상호 배제를 위해 1로, Full은 처음에는 채워진 버퍼가 없으므로 0으로, Empty는 모든 버퍼가 비어있으므로 버퍼 크기로 초기화합니다[5].

### 문제 4
다음 중 유한 버퍼 구현 시 고려해야 할 사항이 아닌 것은?
- A) 버퍼가 가득 찼을 때 생산자의 처리 방법
- B) 버퍼가 비었을 때 소비자의 처리 방법
- C) 여러 생산자/소비자의 동시 접근 제어
- D) 버퍼의 자동 확장 메커니즘

**정답: D) 버퍼의 자동 확장 메커니즘**

**설명**: 유한 버퍼는 정의상 크기가 제한되어 있으므로 자동 확장 메커니즘은 고려 대상이 아닙니다. 대신 버퍼가 가득 찼을 때의 처리가 중요합니다[5][14].

### 문제 5
유한 버퍼에서 생산자와 소비자가 모두 잠들어 버리는 상황(deadlock)이 발생할 수 있는 경우는?
- A) 생산자가 버퍼가 가득 차서 잠들고, 동시에 소비자도 버퍼가 비어서 잠드는 경우
- B) 생산자가 소비자보다 훨씬 빠르게 데이터를 생산하는 경우
- C) 소비자가 생산자보다 훨씬 빠르게 데이터를 소비하는 경우
- D) 버퍼 크기가 1인 경우

**정답: A) 생산자가 버퍼가 가득 차서 잠들고, 동시에 소비자도 버퍼가 비어서 잠드는 경우**

**설명**: 이는 논리적 오류 상황으로, 실제로는 버퍼가 가득 차 있으면서 동시에 비어 있을 수 없습니다. 이런 모순된 상황이 발생한다면 코드에 심각한 오류가 있다는 의미입니다[20].

## 7. Direct vs Indirect Communication

### 문제 1
Direct Communication에서 통신에 필요한 것으로 올바른 것은?
- A) 통신하려는 프로세스의 이름 지정
- B) 통신을 위한 메일박스 또는 포트 생성
- C) 항상 제3자를 통한 라우팅
- D) 커널에 의한 모든 메시지 검증

**정답: A) 통신하려는 프로세스의 이름 지정**

**설명**: 직접 통신에서는 통신을 원하는 각 프로세스가 통신의 수신자 또는 송신자의 이름을 명시해야 합니다[6].

### 문제 2
Indirect Communication의 가장 큰 장점은?
- A) 항상 Direct Communication보다 빠르다
- B) 통신하는 프로세스들이 서로를 알 필요가 없다
- C) 커널 자원을 사용하지 않는다
- D) 메시지 크기에 제한이 없다

**정답: B) 통신하는 프로세스들이 서로를 알 필요가 없다**

**설명**: Indirect Communication에서는 메일박스나 포트를 지정하므로 통신하는 프로세스들이 서로의 이름을 몰라도 됩니다. 이를 통해 다대다 통신이 가능해집니다[6].

### 문제 3
다음 중 Direct Communication의 단점으로 가장 적절한 것은?
- A) 통신 속도가 느리다
- B) 보안에 취약하다
- C) 프로세스 정의의 제한된 모듈성
- D) 다대다 통신이 불가능하다

**정답: C) 프로세스 정의의 제한된 모듈성**

**설명**: Direct Communication의 단점으로는 프로세스 정의의 제한된 모듈성이 있으며, 프로세스 이름을 바꾸면 모든 다른 프로세스의 정의를 검사할 필요가 있을 수 있습니다[6].

### 문제 4
Indirect Communication에서 메세지를 메일박스 A로부터 수신하는 함수의 형태로 올바른 것은?
- A) Receive(A, message)
- B) Read(A, message)
- C) Get(A, message)
- D) Extract(A, message)

**정답: A) Receive(A, message)**

**설명**: Indirect Communication에서는 Send(A, message)와 Receive(A, message) 형태의 프리미티브를 사용합니다[6].

### 문제 5
여러 프로세스가 하나의 메일박스를 통해 통신할 때, 두 개의 프로세스가 동시에 메시지 수신을 시도할 경우 어떻게 처리되는가?
- A) 항상 먼저 대기한 프로세스가 메시지를 받는다
- B) 프로세스 우선순위에 따라 결정된다
- C) 구현에 따라 다르며, 명시적인 규칙이 필요하다
- D) 메시지가 복제되어 두 프로세스 모두 받는다

**정답: C) 구현에 따라 다르며, 명시적인 규칙이 필요하다**

**설명**: 프로세스 a,b,c가 메일박스 A를 모두 공유하고 있을 때, 둘 이상의 프로세스가 동시에 receive()를 하면 어느 프로세스가 메시지를 수신할지 구현에 따라 다르므로 명시적인 규칙이 필요합니다[6].

## 8. Synchronous vs Asynchronous communication

### 문제 1
비동기 통신의 주요 특징으로 옳은 것은?
- A) 메시지를 보낼 때 항상 받는 쪽이 준비되어 있어야 한다
- B) 메시지를 보내고 응답을 기다리지 않고 계속 진행할 수 있다
- C) 항상 동기 통신보다 느리다
- D) 모든 메시지는 순서대로 전달된다

**정답: B) 메시지를 보내고 응답을 기다리지 않고 계속 진행할 수 있다**

**설명**: 비동기 통신은 non-blocking으로, 메시지를 보내고 응답을 기다리지 않고 다른 작업을 계속할 수 있습니다[7].

### 문제 2
동기 통신의 장단점으로 옳지 않은 것은?
- A) 설계가 간단하고 직관적이다
- B) 결과가 주어질 때까지 다른 작업을 할 수 없다
- C) 메시지 전달이 항상 보장된다
- D) 순차적 처리가 필요한 경우에 적합하다

**정답: C) 메시지 전달이 항상 보장된다**

**설명**: 동기 통신이 메시지 전달을 항상 보장하지는 않습니다. 네트워크 문제나 상대 시스템의 오류 등으로 인해 메시지가 손실될 수 있습니다[7].

### 문제 3
다음 중 동기 통신의 예가 될 수 없는 것은?
- A) HTTP 요청 후 응답을 기다리는 웹 브라우저
- B) 데이터베이스 쿼리 후 결과를 기다리는 애플리케이션
- C) 이메일 발송 시스템
- D) 전화 통화

**정답: C) 이메일 발송 시스템**

**설명**: 이메일 발송은 전형적인 비동기 통신의 예로, 이메일을 보내고 수신자가 받았는지 즉시 확인하지 않고 다른 작업을 계속합니다[7].

### 문제 4
비동기 통신이 동기 통신보다 유리한 상황은?
- A) 데이터의 일관성이 매우 중요한 금융 거래
- B) 높은 정확도를 요구하는 실시간 제어 시스템
- C) 여러 요청을 동시에 처리해야 하는 웹 서버
- D) 정확한 순서대로 처리해야 하는 작업 큐

**정답: C) 여러 요청을 동시에 처리해야 하는 웹 서버**

**설명**: 비동기 방식은 하나의 요청에 대한 응답을 기다리지 않고 다른 요청을 처리할 수 있어 다수의 요청을 동시에 처리해야 하는 웹 서버와 같은 상황에 적합합니다[7].

### 문제 5
동기/비동기 통신의 본질적 차이에 대한 설명으로 가장 적절한 것은?
- A) 동기는 항상 빠르고, 비동기는 항상 느리다
- B) 동기는 안전하고, 비동기는 위험하다
- C) 동기는 같은 목적이 동시에 이루어지고, 비동기는 목적이 다를 수 있고 동시에 이루어지지 않는다
- D) 동기는 로컬 통신에만, 비동기는 네트워크 통신에만 사용된다

**정답: C) 동기는 같은 목적이 동시에 이루어지고, 비동기는 목적이 다를 수 있고 동시에 이루어지지 않는다**

**설명**: 동기는 추구하는 같은 행위(목적)가 동시에 이루어지며, 비동기는 추구하는 행위(목적)가 다를 수도 있고, 동시에 이루어지지도 않습니다[7].

## 9. Buffering 전략

### 문제 1
메시지 큐의 버퍼링 방식에 대한 설명으로 옳지 않은 것은?
- A) Zero capacity: 메시지를 버퍼링하지 않고 직접 전달한다
- B) Bounded capacity: 제한된 크기의 버퍼를 사용한다
- C) Unbounded capacity: 이론적으로 무제한 버퍼를 사용한다
- D) 모든 메시지 큐는 기본적으로 zero capacity이다

**정답: D) 모든 메시지 큐는 기본적으로 zero capacity이다**

**설명**: 메시지 큐는 기본적으로 bounded capacity를 가지며, 설정에 따라 버퍼링 방식이 달라집니다[9].

### 문제 2
버퍼 오버플로우 상황에서 IPC_NOWAIT 플래그를 사용했을 때의 동작은?
- A) 버퍼가 공간이 생길 때까지 무한 대기한다
- B) 새로운 버퍼 공간을 동적으로 할당한다
- C) 오래된 메시지를 자동으로 삭제한다
- D) 차단하지 않고 실패(-1)를 반환한다

**정답: D) 차단하지 않고 실패(-1)를 반환한다**

**설명**: IPC_NOWAIT 플래그를 사용하면 blocking하지 않고 실패 처리(-1 반환)합니다. 기본적으로는 큐에 공간이 없을 때 block 상태가 되어 기다립니다[9].

### 문제 3
메시지 큐의 버퍼링과 관련하여, MSG_NOERROR 플래그의 역할은?
- A) 메시지 전송 오류 발생 시 알림을 표시하지 않는다
- B) 메시지의 크기가 지정된 크기보다 클 경우, 지정된 크기만큼만 메시지를 전송한다
- C) 오류가 발생하더라도 프로그램을 중단하지 않는다
- D) 메시지 큐가 가득 찬 경우 가장 오래된 메시지를 자동으로 삭제한다

**정답: B) 메시지의 크기가 지정된 크기보다 클 경우, 지정된 크기만큼만 메시지를 전송한다**

**설명**: MSG_NOERROR를 사용하면 메시지의 크기가 지정된 크기보다 클 경우, 지정된 크기(msgsz)만큼만 메시지를 전송합니다[9].

### 문제 4
POSIX 메시지 큐에서 큐의 최대 메시지 수와 메시지 크기를 설정하는 구조체는?
- A) msg_attr
- B) mq_attr
- C) msgbuf
- D) mq_info

**정답: B) mq_attr**

**설명**: POSIX 메시지 큐에서는 mq_attr 구조체를 통해 최대 메시지 수(mq_maxmsg)와 최대 메시지 크기(mq_msgsize) 등을 설정합니다[19].

### 문제 5
파이프(pipe)의 버퍼링 방식에 대한 설명으로 올바른 것은?
- A) 파이프는 항상 unbounded buffer를 사용한다
- B) 파이프는 항상 zero capacity buffer를 사용한다
- C) 파이프는 운영체제에 의해 설정된 고정 크기의 버퍼를 사용한다
- D) 파이프는 동적으로 버퍼 크기를 조절한다

**정답: C) 파이프는 운영체제에 의해 설정된 고정 크기의 버퍼를 사용한다**

**설명**: 파이프는 운영체제에서 정의된 제한된 크기의 버퍼를 사용하며, 일반적으로 이 크기는 시스템에 따라 다릅니다[16][17].

## 10. POSIX 구현 (Shared Memory, Message Queue)

### 문제 1
POSIX 공유 메모리에서 shm_open() 함수를 사용한 후 반드시 필요한 작업은?
- A) shm_close()
- B) ftruncate()
- C) mmap()
- D) munmap()

**정답: B) ftruncate()**

**설명**: POSIX 공유 메모리에서는 shm_open() 후 반드시 ftruncate()를 호출하여 공유 메모리의 크기를 설정해야 합니다. mmap()은 그 후에 수행됩니다[18].

### 문제 2
POSIX 메시지 큐를 비차단 모드로 열기 위한 플래그 조합은?
- A) O_RDWR | O_CREAT
- B) O_RDWR | O_NONBLOCK
- C) O_RDONLY | O_EXCL
- D) O_WRONLY | O_CREAT

**정답: B) O_RDWR | O_NONBLOCK**

**설명**: O_RDWR는 읽기/쓰기 모두를 위한 플래그이고, O_NONBLOCK은 비차단 모드로 설정하는 플래그입니다[19].

### 문제 3
POSIX 공유 메모리를 사용할 때 여러 프로세스 간 동기화를 위한 적절한 메커니즘이 아닌 것은?
- A) POSIX 세마포어
- B) POSIX 조건 변수
- C) File locking
- D) UDP 소켓 통신

**정답: D) UDP 소켓 통신**

**설명**: UDP 소켓 통신은 네트워크 통신 방식이며 공유 메모리 동기화를 위한 일반적인 메커니즘이 아닙니다. 나머지는 모두 공유 메모리 동기화에 사용될 수 있습니다[18].

### 문제 4
POSIX IPC 객체의 이름 지정 규칙으로 올바른 것은?
- A) 임의의 문자열을 사용할 수 있다
- B) 반드시 "/tmp/" 디렉토리에 있어야 한다
- C) 슬래시(/)로 시작해야 한다
- D) 절대 경로를 포함해야 한다

**정답: C) 슬래시(/)로 시작해야 한다**

**설명**: POSIX IPC 객체(공유 메모리, 메시지 큐, 세마포어)의 이름은 슬래시(/)로 시작해야 합니다[18][19].

### 문제 5
다음 중 POSIX 메시지 큐에서 메시지를 수신하는 함수는?
- A) mq_read()
- B) mq_recv()
- C) mq_receive()
- D) mq_get()

**정답: C) mq_receive()**

**설명**: POSIX 메시지 큐에서는 메시지 수신을 위해 mq_receive() 함수를 사용합니다. mq_send()는 메시지 전송에 사용됩니다[19].

## 11. Pipes (Ordinary and Named)

### 문제 1
일반 파이프(Ordinary Pipe)와 명명된 파이프(Named Pipe)의 차이점으로 옳지 않은 것은?
- A) 일반 파이프는 부모-자식 프로세스 간에만, 명명된 파이프는 관련 없는 프로세스 간에도 사용 가능하다
- B) 일반 파이프는 프로세스 실행 중에만 존재하고, 명명된 파이프는 프로세스 종료 후에도 존재할 수 있다
- C) 일반 파이프는 양방향 통신이 가능하고, 명명된 파이프는 단방향 통신만 가능하다
- D) 명명된 파이프는 파일 시스템 내에 실제 파일로 존재한다

**정답: C) 일반 파이프는 양방향 통신이 가능하고, 명명된 파이프는 단방향 통신만 가능하다**

**설명**: 일반적으로 일반 파이프는 단방향 통신(Unidirectional)이며, 양방향 통신을 위해서는 두 개의 파이프가 필요합니다. 명명된 파이프도 기본적으로 단방향이지만 특정 구현에서는 양방향도 가능합니다[16][17].

### 문제 2
명명된 파이프(Named Pipe)를 생성하는 Linux 명령어는?
- A) pipe()
- B) mkpipe
- C) mkfifo
- D) create_pipe

**정답: C) mkfifo**

**설명**: Linux에서 명명된 파이프(FIFO)를 생성하기 위해 mkfifo 명령어를 사용합니다[16].

### 문제 3
다음 중 파이프의 데이터 흐름 특성으로 옳은 것은?
- A) 데이터는 임의 순서로 읽을 수 있다
- B) 데이터는 LIFO(Last In First Out) 방식으로 처리된다
- C) 데이터는 FIFO(First In First Out) 방식으로 처리된다
- D) 데이터는 우선순위에 따라 처리된다

**정답: C) 데이터는 FIFO(First In First Out) 방식으로 처리된다**

**설명**: 파이프의 데이터는 FIFO(First In First Out) 방식으로 처리되며, 명명된 파이프는 동작에서 FIFO로 부르기도 합니다[16].

### 문제 4
파이프를 통한 프로세스 간 통신에서 발생할 수 있는 문제가 아닌 것은?
- A) 읽기 측이 없는 상태에서 쓰기를 시도하면 SIGPIPE 시그널이 발생한다
- B) 쓰기 측이 모두 파이프를 닫으면 읽기 측은 EOF를 받는다
- C) 파이프가 가득 차면 추가 쓰기 작업은 차단된다
- D) 파이프를 통한 통신은 항상 네트워크 지연을 발생시킨다

**정답: D) 파이프를 통한 통신은 항상 네트워크 지연을 발생시킨다**

**설명**: 파이프는 일반적으로 같은 시스템 내의 프로세스 간 통신에 사용되므로 네트워크 지연이 발생하지 않습니다. 네트워크 지연은 네트워크 소켓을 통한 통신에서 발생합니다[16][17].

### 문제 5
파이프(pipe)의 특성으로 옳지 않은 것은?
- A) 반이중(Half-duplex) 통신이 가능하다
- B) 명명된 파이프는 파일 시스템에 실제 항목으로 존재한다
- C) 일반 파이프는 fork()를 통해 생성된 프로세스 간에만 사용할 수 있다
- D) 명명된 파이프는 항상 비동기적으로 동작한다

**정답: D) 명명된 파이프는 항상 비동기적으로 동작한다**

**설명**: 명명된 파이프는 기본적으로 동기적으로 동작하며, 특별한 설정 없이는 읽기/쓰기 작업이 차단(blocking)됩니다. 비동기 동작을 위해서는 O_NONBLOCK 플래그를 사용해야 합니다[16][17].

## 12. 네트워크 통신을 위한 소켓

### 문제 1
소켓 통신에서 서버 소켓이 클라이언트 소켓과 다른 점은?
- A) 서버 소켓은 listen()과 accept()를 호출하고, 클라이언트 소켓은 connect()를 호출한다
- B) 서버 소켓은 읽기만 가능하고, 클라이언트 소켓은 쓰기만 가능하다
- C) 서버 소켓은 UDP만 사용하고, 클라이언트 소켓은 TCP만 사용한다
- D) 서버 소켓은 IPv4만 지원하고, 클라이언트 소켓은 IPv6도 지원한다

**정답: A) 서버 소켓은 listen()과 accept()를 호출하고, 클라이언트 소켓은 connect()를 호출한다**

**설명**: 서버 소켓은 연결 요청을 수락하기 위해 listen()과 accept()를 호출하고, 클라이언트 소켓은 서버에 연결하기 위해 connect()를 호출합니다[11][13].

### 문제 2
소켓 통신에서 실제 데이터 송수신은 어떤 소켓을 통해 이루어지는가?
- A) 서버 소켓
- B) 클라이언트 소켓
- C) accept()로 생성된 새로운 소켓
- D) bind()로 생성된 소켓

**정답: C) accept()로 생성된 새로운 소켓**

**설명**: 서버 소켓은 클라이언트 소켓의 연결 요청을 받아들이는 역할만 수행하며, 실제 데이터의 송수신은 서버 소켓이 연결 요청을 수락한 결과로 생성된 새로운 소켓을 통해 이루어집니다[11].

### 문제 3
소켓의 주요 구성 요소가 아닌 것은?
- A) IP 주소
- B) 포트 번호
- C) 프로토콜
- D) 파일 디스크립터 번호

**정답: D) 파일 디스크립터 번호**

**설명**: 소켓은 IP 주소와 포트 번호를 조합하여 통신 상대를 식별합니다. 파일 디스크립터는 소켓 자체의 구성 요소가 아니라 시스템에서 소켓을 참조하기 위한 식별자입니다[11].

### 문제 4
TCP 소켓과 UDP 소켓의 차이점으로 옳지 않은 것은?
- A) TCP는 연결 지향적이고, UDP는 비연결 지향적이다
- B) TCP는 데이터 전송 보장을 하고, UDP는 보장하지 않는다
- C) TCP는 스트림 방식으로 데이터를 전송하고, UDP는 데이터그램 방식으로 전송한다
- D) TCP는 항상 UDP보다 느리다

**정답: D) TCP는 항상 UDP보다 느리다**

**설명**: TCP가 연결 설정과 신뢰성 보장을 위한 오버헤드로 인해 일반적으로 UDP보다 느리지만, "항상" 그런 것은 아닙니다. 네트워크 상황이나 데이터 특성에 따라 성능 차이가 달라질 수 있습니다[11][13].

### 문제 5
소켓 통신에서 클라이언트가 서버에 연결할 때 필요한 정보는?
- A) 서버의 IP 주소만
- B) 서버의 포트 번호만
- C) 서버의 IP 주소와 포트 번호
- D) 서버의 IP 주소, 포트 번호, 그리고 프로토콜

**정답: C) 서버의 IP 주소와 포트 번호**

**설명**: 클라이언트가 서버에 연결하기 위해서는 서버의 IP 주소와 포트 번호를 알아야 합니다. 이 둘을 조합하여 소켓이 특정 서버 애플리케이션과 통신할 수 있습니다[11][13].

## 13. 클라이언트-서버 통신 모델

### 문제 1
클라이언트-서버 통신에서 "Request(요청)"와 "Response(응답)"의 관계를 가장 잘 설명한 것은?
- A) 클라이언트는 요청만 보내고, 서버는 응답만 보낸다
- B) 클라이언트와 서버는 항상 교대로 요청과 응답을 주고받는다
- C) 클라이언트가 요청을 보내면 서버는 해당 요청에 대한 응답을 보낸다
- D) 서버가 요청을 보내면 클라이언트는 응답해야 한다

**정답: C) 클라이언트가 요청을 보내면 서버는 해당 요청에 대한 응답을 보낸다**

**설명**: 클라이언트-서버 통신에서는 클라이언트가 요청을 보내고 서버가 응답하는 형태로 통신이 이루어집니다[12].

### 문제 2
서버 없이 앱을 개발할 때 생기는 문제점이 아닌 것은?
- A) 새로운 컨텐츠 업데이트를 위해 앱 전체를 업데이트해야 한다
- B) 결제와 같은 외부 서비스 연동이 어렵다
- C) 데이터 일관성 유지가 어렵다
- D) 네트워크 대역폭 사용량이 증가한다

**정답: D) 네트워크 대역폭 사용량이 증가한다**

**설명**: 서버 없는 앱은 오히려 네트워크 통신이 없거나 적으므로 대역폭 사용량이
 증가하지 않습니다. 실제로는 서버가 있는 앱이 서버와의 통신으로 인해 대역폭 사용량이 증가합니다[12].

### 문제 3
클라이언트-서버 아키텍처에서 3-티어 아키텍처의 구성 요소를 올바르게 나열한 것은?
- A) 클라이언트 - 미들웨어 - 서버
- B) 웹 서버 - 애플리케이션 서버 - 데이터베이스 서버
- C) 클라이언트 - 서버 - 데이터베이스
- D) 프런트엔드 - 백엔드 - 스토리지

**정답: C) 클라이언트 - 서버 - 데이터베이스**

**설명**: 3-티어 아키텍처는 일반적으로 클라이언트, 서버, 데이터베이스로 구성됩니다. 서버는 클라이언트에 리소스를 전달해주는 역할을 담당하고, 데이터베이스는 리소스를 저장하는 공간입니다[12].

### 문제 4
클라이언트와 서버가 통신할 때 지켜야 하는 약속(규약)을 무엇이라고 하는가?
- A) API
- B) 프로토콜
- C) 인터페이스
- D) 패킷

**정답: B) 프로토콜**

**설명**: 클라이언트와 서버 간의 통신 규약을 프로토콜이라고 하며, 대표적으로 HTTP, HTTPS, FTP 등이 있습니다[12].

### 문제 5
다음 중 클라이언트-서버 모델에서 API의 역할로 가장 적절한 것은?
- A) 클라이언트의 요청을 암호화하는 도구
- B) 서버가 클라이언트에게 리소스를 잘 활용할 수 있도록 제공하는 인터페이스
- C) 통신 속도를 높이기 위한 압축 메커니즘
- D) 서버 과부하를 방지하기 위한 요청 제한 장치

**정답: B) 서버가 클라이언트에게 리소스를 잘 활용할 수 있도록 제공하는 인터페이스**

**설명**: API는 서버가 클라이언트에게 리소스를 잘 활용할 수 있도록 제공하는 인터페이스이며, 클라이언트와 서버는 API를 통해 요청과 응답을 주고받습니다[12].

## 14. Java 소켓 프로그래밍 예제

### 문제 1
Java 소켓 프로그래밍에서 서버 소켓을 생성하는 클래스는?
- A) Socket
- B) ServerSocket
- C) SocketServer
- D) JavaSocket

**정답: B) ServerSocket**

**설명**: Java에서 서버 소켓은 java.net.ServerSocket 클래스를 사용하여 생성하며, 이 클래스는 연결 요청을 기다리면서 연결 수락을 담당합니다[13].

### 문제 2
Java 소켓 통신에서 소켓으로부터 데이터를 읽거나 쓰기 위해 사용하는 것은?
- A) DataInputStream과 DataOutputStream
- B) SocketReader와 SocketWriter
- C) BufferedSocket
- D) SocketChannel

**정답: A) DataInputStream과 DataOutputStream**

**설명**: Java 소켓 프로그래밍에서는 일반적으로 InputStream과 OutputStream을 통해 소켓으로부터 데이터를 읽거나 쓰며, 이를 DataInputStream과 DataOutputStream으로 감싸서 사용할 수 있습니다[13].

### 문제 3
다음 중 Java 소켓 프로그래밍에서 클라이언트 소켓을 생성할 때 서버에 연결하기 위해 필요한 정보는?
- A) 서버의 IP 주소만
- B) 서버의 포트 번호만
- C) 서버의 IP 주소와 포트 번호
- D) 서버의 소켓 객체

**정답: C) 서버의 IP 주소와 포트 번호**

**설명**: Java에서 클라이언트 소켓을 생성할 때는 Socket(String host, int port) 생성자를 사용하여 서버의 IP 주소와 포트 번호를 지정합니다[13].

### 문제 4
Java 소켓 프로그래밍에서 발생할 수 있는 예외 중 소켓 설정에 문제가 있거나 소켓이 닫혀있는 경우 발생하는 예외는?
- A) IOException
- B) SocketException
- C) ConnectionException
- D) NetworkException

**정답: B) SocketException**

**설명**: SocketException은 소켓 관련 예외로, 소켓 설정에 문제가 있거나 소켓이 닫혀 있는 경우에 발생할 수 있습니다[13].

### 문제 5
Java에서 다중 클라이언트를 처리하기 위한, 서버 소켓의 일반적인 패턴은?
- A) 단일 스레드에서 모든 클라이언트 요청을 순차적으로 처리
- B) 각 클라이언트 연결마다 새 스레드를 생성하여 독립적으로 처리
- C) 모든 클라이언트 요청을 한 번에 병렬 처리
- D) 클라이언트 요청을 큐에 저장한 후 일괄 처리

**정답: B) 각 클라이언트 연결마다 새 스레드를 생성하여 독립적으로 처리**

**설명**: Java에서 다중 클라이언트를 처리하기 위한 일반적인 패턴은 각 클라이언트 연결마다 새로운 스레드를 생성하여 독립적으로 처리하는 것입니다. 이를 통해 여러 클라이언트의 요청을 동시에, 독립적으로 처리할 수 있습니다[13].

## 종합 문제 - 심화 개념 이해도 확인

### 문제 1
생산자-소비자 문제를 공유 메모리와 메시지 큐 중 어떤 방식으로 구현하는 것이 더 적합한지 설명하고, 그 이유를 제시하시오.

**답변 가이드**: 
공유 메모리는 속도가 빠르지만 동기화 문제를 별도로 해결해야 합니다. 메시지 큐는 자체적으로 동기화 메커니즘을 포함하고 있어 구현이 더 간단할 수 있습니다. 생산자-소비자 문제는 본질적으로 버퍼 관리와 동기화가 중요하므로, 동기화 메커니즘이 내장된 메시지 큐가 더 적합할 수 있으나, 성능이 중요한 경우 세마포어와 함께 공유 메모리를 사용하는 것이 좋을 수 있습니다[1][5][15].

### 문제 2
동기 통신과 비동기 통신의 장단점을 비교하고, 각각이 적합한 응용 사례를 제시하시오.

**답변 가이드**: 
동기 통신은 설계가 간단하고 직관적이지만 응답을 기다려야 하는 단점이 있습니다. 금융 거래나 실시간 제어 시스템 등 데이터 일관성이 중요한 경우에 적합합니다. 비동기 통신은 응답을 기다리지 않고 다른 작업을 할 수 있어 효율적이지만, 설계가 복잡하고 에러 처리가 어려울 수 있습니다. 웹 서버, UI 업데이트, 알림 시스템 등 여러 작업을 동시에 처리해야 하는 경우에 적합합니다[7].

### 문제 3
클라이언트-서버 모델에서 서버 과부하를 방지하기 위한 방법을 세 가지 이상 제시하고 각각의 장단점을 설명하시오.

**답변 가이드**: 
1) 로드 밸런싱: 여러 서버에 부하를 분산. 장점은 확장성이 좋고 가용성이 높지만, 구성이 복잡하고 추가 하드웨어가 필요함
2) 캐싱: 자주 요청되는 데이터를 임시 저장. 장점은 응답 시간 단축과 서버 부하 감소, 단점은 데이터 일관성 문제 가능성
3) 비동기 처리: 요청을 큐에 넣고 순차적으로 처리. 장점은 서버가 한 번에 처리할 요청 수 제한 가능, 단점은 응답 지연 가능성
4) 서버 확장(스케일 업/아웃): 서버 성능 향상 또는 서버 수 증가. 장점은 직접적인 성능 향상, 단점은 비용 증가[11][12]

### 문제 4
POSIX IPC와 System V IPC의 주요 차이점을 세 가지 이상 설명하고, 어떤 상황에서 어떤 구현이 더 적합한지 제시하시오.

**답변 가이드**: 
1) 인터페이스: POSIX는 파일 디스크립터 기반 API, System V는 ID 기반 API
2) 네이밍: POSIX는 파일 시스템 경로 기반 이름, System V는 key_t 타입의 키
3) 권한 관리: POSIX는 파일 권한 모델 사용, System V는 자체 권한 체계
4) 가용성: System V는 오래된 유닉스 시스템에서도 사용 가능, POSIX는 더 현대적인 시스템에서 사용

레거시 시스템과의 호환성이 필요한 경우 System V가 적합하며, 새로운 개발이나 표준 준수가 중요한 경우 POSIX가 적합합니다[8][9][18][19].

### 문제 5
소켓 통신과 공유 메모리 방식의 차이점을 설명하고, 네트워크 분산 환경과 단일 시스템 환경에서 각각 어떤 방식이 더 효율적인지 이유와 함께 설명하시오.

**답변 가이드**: 
소켓 통신은 네트워크를 통한 데이터 전송을 지원하며, 다른 시스템 간 통신이 가능합니다. 공유 메모리는 같은 시스템 내 프로세스 간 데이터 공유를 지원하며 속도가 빠르지만 네트워크 통신은 불가능합니다.

네트워크 분산 환경에서는 소켓 통신이 필수적입니다. 물리적으로 분리된 시스템 간 통신을 지원하며, TCP/IP와 같은 프로토콜을 통해 신뢰성 있는 데이터 전송이 가능합니다.

단일 시스템 환경에서는 공유 메모리가 더 효율적입니다. 커널을 거치지 않고 직접 메모리에 접근하므로 속도가 빠르며, 대량의 데이터 교환에 적합합니다. 단, 동기화 문제를 해결해야 합니다