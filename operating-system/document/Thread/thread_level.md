# 스레드, 프로세스 및 병렬 컴퓨팅

## Amdahl 이론 (Amdahl's Law)

Amdahl 이론은 시스템의 일부를 개선할 때 얻을 수 있는 전체 성능 향상의 이론적 한계를 계산합니다. 이는 병렬 컴퓨팅에서 특히 중요한 개념입니다.

```
SpeedUp = 1 / [(1-p) + (p/N)]
```
- p: 프로그램에서 병렬화 가능한 부분의 비율 (0~1)
- N: 처리 코어(프로세서)의 개수
- (1-p): 순차적으로만 실행 가능한 부분의 비율

이 공식의 핵심 통찰은 프로그램의 순차적 부분이 전체 성능 향상에 근본적인 제약을 가한다는 것입니다. 아무리 많은 프로세서를 추가해도 순차적인 부분으로 인해 속도 향상은 제한됩니다.

## fork() 시스템 콜을 통한 프로세스 생성

fork() 시스템 콜은 Unix 계열 운영체제에서 새로운 프로세스를 생성하는 기본 메커니즘입니다[1][2].

### 작동 방식

1. 프로세스가 fork()를 호출하면 커널은 호출한 프로세스(부모)의 복제본(자식)을 생성합니다[1]
2. 부모와 자식 프로세스 모두 fork() 호출 지점 이후의 코드를 실행합니다[1]
3. 반환값을 통해 부모와 자식을 구분합니다:
   - 부모 프로세스: 자식의 PID 값(양수) 반환
   - 자식 프로세스: 0 반환[2][10]
4. 생성 실패 시: -1 반환[10]

### 최적화 기법

현대 운영체제는 copy-on-write 기법을 사용하여 프로세스 생성을 최적화합니다[2]:
- 초기에는 부모와 자식이 동일한 물리적 메모리 페이지를 공유합니다
- 한쪽에서 메모리 수정 시도 시에만 실제로 복사가 이루어집니다
- 이는 특히 fork() 후 바로 exec()를 호출하는 경우에 효율적입니다[2][11]

```c
pid_t pid = fork();
if (pid == 0) {
    // 자식 프로세스 코드
    execve("/usr/bin/ls", ls_args, environ);
} else {
    // 부모 프로세스 코드
    fprintf(stderr, "%s\n", "Parent process");
}
```

## 커널 스레드 간의 Context Switching

커널 스레드 간 컨텍스트 스위칭은 다음과 같은 단계로 이루어집니다[4][8]:

1. **상태 저장**: 현재 스레드의 실행 컨텍스트(레지스터, 프로그램 카운터, 스택 포인터 등)를 Thread Control Block(TCB)에 저장합니다[4][14]

2. **스케줄링**: 스케줄러가 다음에 실행할 스레드를 선택합니다[4]

3. **상태 복원**: 선택된 스레드의 컨텍스트를 해당 TCB에서 로드합니다[4]

4. **주소 공간 전환**: 스레드가 다른 프로세스에 속한 경우, 가상 메모리 매핑을 변경하고 TLB(Translation Lookaside Buffer)를 비웁니다[4]

5. **실행 재개**: 저장된 프로그램 카운터 위치부터 실행을 재개합니다[4]

### 주요 특징

- 커널 스레드 전환은 커널 모드 권한이 필요합니다[7]
- 프로세스 전환보다는 빠르지만 사용자 레벨 스레드 전환보다는 느립니다[4][7]
- 동일 프로세스 내 스레드 전환은 주소 공간 전환이 필요 없어 더 빠릅니다[4]
- 현대 CPU는 컨텍스트 스위치 오버헤드를 줄이기 위한 최적화 기능이 포함되어 있습니다[4]

## 프로세스와 스레드의 리소스 요구사항

### 스레드 리소스
- 스레드 식별자(TID)[14]
- 레지스터 세트(프로그램 카운터, 스택 포인터 등 CPU 레지스터)[14]
- 스택(로컬 변수와 함수 호출용)[9]
- Thread Control Block(TCB)[14]
- 스레드 로컬 스토리지(Thread-Local Storage, TLS)[9]

### 스레드의 스택과 TLS
- **스택**: 함수 호출 정보와 지역 변수를 저장하는 LIFO 구조의 메모리 영역으로, 스레드마다 독립적으로 할당됩니다[9]
- **TLS**: 스레드별 독립적인 저장 공간으로, 전역 변수처럼 사용할 수 있지만 해당 스레드만 접근 가능합니다[9]

### 프로세스 리소스
- 프로세스 식별자(PID)[2][10]
- 메모리 공간(텍스트, 데이터, 힙 세그먼트)[5]
- Process Control Block(PCB)[6]
- 파일 디스크립터 테이블[2]
- 보안 컨텍스트(사용자 ID, 그룹 ID)[5]
- 최소 하나의 스레드(메인 스레드)[5]

## 사용자 레벨 스레드 vs 커널 레벨 스레드

### 사용자 레벨 스레드(User-level Threads)
사용자 공간에서 구현되며 커널 지원 없이 스레드 라이브러리를 통해 관리됩니다[7][9][12].

**특징**:
- 스레드 작업에 시스템 콜이 필요 없음[7]
- 컨텍스트 스위칭이 빠름[7][12]
- 스레딩을 지원하지 않는 OS에서도 사용 가능[7]
- 커널은 이러한 스레드의 존재를 인식하지 못함[7][12]
- 한 스레드가 I/O에 블록되면 동일 프로세스의 모든 스레드가 블록됨[12][17]
- 사용자 라이브러리에 의해 스케줄링되어 유연성 제공[7]
- 생성과 관리가 커널 레벨 스레드보다 빠름[12][17]

**예**: POSIX Threads, Java의 green 스레드[9][12]

### 커널 레벨 스레드(Kernel-level Threads)
OS에 의해 직접 지원되고 관리되는 스레드입니다[8][12].

**특징**:
- 스레드 작업에 시스템 콜이 필요함[7][12]
- 커널이 모든 스레드를 인식하고 관리[8][12]
- 한 스레드가 블록되어도 다른 스레드들은 정상 작동[12][17]
- 멀티프로세서 시스템에서 진정한 병렬 실행 가능[8][12]
- 스레드당 더 많은 시스템 리소스 필요[8][12]
- 생성과 관리가 사용자 레벨 스레드보다 느림[12][17]

**예**: Linux의 POSIX 스레드, Windows 스레드[9][12]

### 주요 차이점

|매개변수|사용자 레벨 스레드|커널 레벨 스레드|
|---|---|---|
|구현 주체|사용자 라이브러리에 의해 구현|운영체제에 의해 구현|
|인식|OS가 직접 인식하지 못함|OS가 직접 인식함|
|컨텍스트 스위치 시간|적음|많음|
|하드웨어 지원|필요 없음|필요함|
|블로킹 연산|한 스레드가 블록되면 전체 프로세스 블록|한 스레드가 블록돼도 다른 스레드 실행 가능|
|멀티프로세싱|멀티프로세서 활용 어려움|멀티프로세서 활용 가능|
|이식성|높음|낮음(OS 종속적)|
|장점|생성/관리 빠름, 이식성 높음|진정한 병렬 실행, 블로킹 연산에 강함|
|단점|블로킹 연산에 취약, 멀티프로세서 활용 못함|생성/관리 느림, 오버헤드 큼|

이러한 개념들은 현대 운영체제와 병렬 프로그래밍의 핵심 요소로, 시스템 설계 및 성능 최적화에 중요한 역할을 합니다.
