# fork() 시스템 콜을 통한 프로세스 생성 분석

이 코드에서 fork() 시스템 콜이 여러 번 호출되면서 다양한 프로세스가 생성됩니다. 각 프로세스가 어떻게 생성되고 무엇을 포함하는지 단계별로 살펴보겠습니다.

## 프로세스 생성 과정

### 초기 상태
처음에는 하나의 프로세스(원본 프로세스)만 존재합니다.

### 첫 번째 fork()
```c
pid = fork();
```
- 원본 프로세스가 fork()를 호출하여 자식 프로세스를 생성합니다.
- 원본 프로세스(부모): pid 변수에는 자식의 PID(양수)가 저장됩니다.
- 새로 생성된 자식 프로세스: pid 변수에는 0이 저장됩니다.
- 이 시점에서 두 개의 프로세스가 존재합니다.

### if(pid == 0) 분기
```c
if(pid == 0){ /* child process */ 
```
- 원본 프로세스: pid가 0이 아니므로 if 블록을 실행하지 않습니다.
- 자식 프로세스: pid가 0이므로 if 블록의 코드를 실행합니다.

### if 블록 내부의 fork()
```c
fork();
```
- 자식 프로세스만 이 코드를 실행합니다.
- 자식 프로세스가 fork()를 호출하여 새로운 프로세스(손자 프로세스)를 생성합니다.
- 이 시점에서 총 3개의 프로세스가 존재합니다.

### thread create() 호출
```c
thread create( . . . );
```
- 자식 프로세스와 손자 프로세스가 각각 스레드를 생성합니다.
- 스레드는 프로세스와 달리 부모 프로세스의 메모리 공간을 공유합니다[1].
- 각 프로세스 내에서 스레드가 생성되었지만, 프로세스 수는 여전히 3개입니다.

### 마지막 fork()
```c
fork();
```
- 모든 프로세스(원본, 자식, 손자)가 이 코드를 실행합니다.
- 각 프로세스가 새로운 자식을 생성하여 3개의 프로세스가 추가됩니다.
- 최종적으로 총 6개의 프로세스가 존재하게 됩니다.

## 각 프로세스의 내용

### 원본 프로세스(P1)
- pid 변수에는 양수값(첫 번째 자식의 PID)이 저장됨
- if 블록을 실행하지 않음
- 스레드를 생성하지 않음
- 마지막 fork()에서 P4를 생성

### 첫 번째 자식 프로세스(P2)
- pid 변수에는 0이 저장됨
- if 블록을 실행함
- if 블록 내에서 P3를 생성
- 스레드를 하나 생성함
- 마지막 fork()에서 P5를 생성

### 손자 프로세스(P3)
- P2의 if 블록 내 fork()에서 생성됨
- 스레드를 하나 생성함
- 마지막 fork()에서 P6를 생성

### 나머지 프로세스들(P4, P5, P6)
- P4: 원본 프로세스의 마지막 fork()에서 생성됨
- P5: P2의 마지막 fork()에서 생성됨
- P6: P3의 마지막 fork()에서 생성됨
- 이 프로세스들은 더 이상의 코드를 실행하지 않음(프로그램이 끝나기 때문)

## 중요 사항

- fork() 시스템 콜은 호출한 프로세스의 완전한 복제본을 생성합니다[1].
- 복제 시 모든 메모리 이미지, 열린 파일 디스크립터, 레지스터 값 등이 복사됩니다[1].
- 자식 프로세스는 부모 프로세스와 독립적인 메모리 공간을 가집니다[1].
- 반면 스레드는 프로세스 내에서 생성되며 프로세스의 메모리 공간을 공유합니다[1].
- Linux에서 프로세스 ID(PID)는 각 프로세스를 식별하는 고유한 번호입니다[1][2].

이 코드는 fork()를 사용한 프로세스 생성과 스레드 생성을 함께 보여주는 예시로, 총 6개의 프로세스와 2개의 스레드가 생성됩니다.
