# C 프로그램 메모리 레이아웃 관련 문제

## 문제 1
이미지에서 보이는 메모리 레이아웃에서, 다음 중 `malloc()`을 통해 할당된 메모리가 저장되는 영역은?
- A) Stack 영역
- B) Text 영역
- C) Heap 영역
- D) Initialized data 영역

**정답: C**

**해설:** `malloc()` 함수는 동적 메모리 할당에 사용되며, 이렇게 할당된 메모리는 힙(Heap) 영역에 저장됩니다. 이미지에서 볼 수 있듯이 `values = (int *)malloc(sizeof(int)*5);` 라인이 힙 영역을 가리키고 있습니다. 지역 변수와 달리 힙 메모리는 명시적으로 해제하지 않으면 프로그램 종료 시까지 유지되며, 메모리 누수의 원인이 될 수 있습니다.

## 문제 2
다음 중 BSS 영역(Uninitialized data)에 저장되는 변수는?
- A) `int x = 10;` (전역 변수)
- B) `static int y;` (정적 지역 변수, 초기화되지 않음)
- C) `int z;` (함수 내 지역 변수)
- D) `char *str = "hello";` (전역 변수)

**정답: B**

**해설:** BSS(Block Started by Symbol) 영역은 초기화되지 않은 전역 변수와 정적(static) 변수를 저장합니다. 초기화되지 않은 `static int y;`는 BSS 영역에 저장되며, 0으로 자동 초기화됩니다. 반면, 초기화된 전역 변수는 initialized data 영역에, 지역 변수는 스택에, 문자열 리터럴 "hello"는 read-only data 영역에 저장됩니다.

## 문제 3
이미지에서 Stack과 Heap의 성장 방향으로 올바른 것은?
- A) Stack은 위로, Heap은 아래로 성장
- B) Stack과 Heap 모두 위로 성장
- C) Stack은 아래로, Heap은 위로 성장
- D) Stack과 Heap 모두 아래로 성장

**정답: C**

**해설:** 일반적인 메모리 레이아웃에서 Stack은 높은 주소에서 낮은 주소로(아래로) 성장하고, Heap은 낮은 주소에서 높은 주소로(위로) 성장합니다. 이미지에서도 스택 영역에 아래로 향하는 화살표와 위로 향하는 화살표가 있어 이를 나타내고 있습니다. 이러한 설계는 두 영역이 서로를 향해 성장하면서 메모리 공간을 효율적으로 활용할 수 있게 합니다.

## 문제 4
함수 내에서 선언된 정적 변수(예: `static int counter = 0;`)는 메모리의 어느 영역에 저장되는가?
- A) Stack 영역
- B) Heap 영역
- C) Initialized data 영역
- D) Text 영역

**정답: C**

**해설:** 함수 내에서 선언된 정적 변수(static 키워드 사용)는 일반 지역 변수와 달리 스택이 아닌 데이터 영역에 저장됩니다. 초기화된 정적 변수는 initialized data 영역에, 초기화되지 않은 정적 변수는 BSS 영역에 저장됩니다. 정적 변수는 프로그램 시작 시 할당되어 종료 시까지 유지되며, 함수 호출 간에도 값이 보존됩니다.

## 문제 5
이미지에서 보이는 `size memory` 명령의 출력 결과에서, `dec` 값 1450은 무엇을 나타내는가?
- A) 텍스트 영역의 크기
- B) 데이터 영역의 크기
- C) 텍스트, 데이터, BSS 영역의 합계
- D) 힙과 스택을 포함한 전체 메모리 사용량

**정답: C**

**해설:** `size memory` 명령 출력에서 `dec` 값 1450은 텍스트 영역(1158), 데이터 영역(284), BSS 영역(8)의 합계를 10진수로 나타낸 것입니다. 이미지 하단에 설명된 대로 dec와 hex 값은 세 영역의 합을 각각 10진수와 16진수로 표시합니다. 스택과 힙 영역은 프로그램 실행 중에 동적으로 변하므로 이 값에 포함되지 않습니다.

## 문제 6
다음 코드에서 변수 값이 저장되는 메모리 영역이 다른 하나는?
```c
int global = 100;       // A
void func() {
    static int count = 0;  // B
    int local = 200;      // C
    int *ptr = malloc(sizeof(int)); // D
}
```

- A) global 변수
- B) count 변수
- C) local 변수
- D) malloc으로 할당된 메모리

**정답: C**

**해설:** 이 코드에서 `local` 변수만 스택 영역에 저장됩니다. `global` 변수는 초기화된 전역 변수로 initialized data 영역에, `count` 변수는 초기화된 정적 변수로 역시 initialized data 영역에 저장됩니다. `malloc()`으로 할당된 메모리는 힙 영역에 있으며, 포인터 변수 `ptr` 자체는 스택에 있지만 가리키는 메모리는 힙에 있습니다. 지역 변수는 함수 호출이 끝나면 스택에서 제거되는 반면, 다른 변수들은 더 긴 수명을 갖습니다.

## 문제 7
다음 프로그램을 실행하면 어떤 문제가 발생할 가능성이 높은가?
```c
void func() {
    char *str = "Hello World";
    str[0] = 'J';
    printf("%s\n", str);
}
```
- A) 메모리 누수(Memory leak)
- B) 세그멘테이션 오류(Segmentation fault)
- C) 스택 오버플로우(Stack overflow)
- D) 힙 손상(Heap corruption)

**정답: B**

**해설:** 문자열 리터럴 "Hello World"는 일반적으로 읽기 전용 메모리(텍스트 영역이나 읽기 전용 데이터 영역)에 저장됩니다. 이 코드에서는 이 읽기 전용 문자열을 수정하려고 시도하므로 세그멘테이션 오류가 발생합니다. 문자열을 수정하려면 다음과 같이 배열이나 힙 메모리를 사용해야 합니다: `char str[] = "Hello World";` 또는 `char *str = strdup("Hello World");`. 이는 메모리 레이아웃의 보호 특성을 이해하는 것이 중요함을 보여줍니다.

## 문제 8
다음 중 스택(stack) 메모리의 특징이 아닌 것은?
- A) 함수 호출이 끝나면 자동으로 메모리가 해제된다
- B) 지역 변수가 저장된다
- C) 메모리 할당/해제 속도가 빠르다
- D) 런타임에 크기를 조정할 수 있다

**정답: D**

**해설:** 스택 메모리는 런타임에 크기를 자유롭게 조정할 수 없습니다. 스택은 일반적으로 프로그램 시작 시 고정된 크기로 할당되며(운영체제에 따라 다름), 이 제한을 초과하면 스택 오버플로우가 발생합니다. 반면 힙 메모리는 `malloc()`, `realloc()` 등을 통해 런타임에 크기를 조정할 수 있습니다. 스택은 함수 호출과 지역 변수 관리에 최적화되어 있으며, 함수 종료 시 자동으로 메모리가 해제되고 할당/해제 오버헤드가 적습니다.

## 문제 9
`argc`와 `argv` 매개변수는 메모리 레이아웃의 어느 부분에 저장되는가?
- A) Heap 영역
- B) 스택의 함수 프레임 내부
- C) 별도의 전용 영역(이미지에 표시된 대로)
- D) Initialized data 영역

**정답: C**

**해설:** 이미지에 표시된 대로, `argc`와 `argv` 매개변수는 일반적인 스택의 함수 인자 영역이 아닌 별도의 전용 영역에 저장됩니다. 이 영역은 프로그램 실행 시 운영체제에 의해 설정되며, 메모리의 가장 높은 주소 부분에 위치합니다. 이는 C 프로그램의 `main()` 함수가 다른 일반 함수들과 다르게 처리됨을 보여줍니다. `argv` 배열은 문자열 포인터의 배열로, 명령줄 인자들이 저장된 메모리 주소를 가리킵니다.

## 문제 10
다음 코드에서 메모리 누수(memory leak)를 일으키는 부분은?
```c
void process_data() {
    int *arr1 = (int*)malloc(10 * sizeof(int));
    int *arr2 = (int*)malloc(5 * sizeof(int));
    
    // 데이터 처리 로직
    
    if(arr1[0] > 10) {
        free(arr1);
        return;
    }
    
    free(arr1);
    free(arr2);
}
```
- A) `arr1`에 대한 메모리 누수 가능성
- B) `arr2`에 대한 메모리 누수 확실함
- C) `arr1`과 `arr2` 모두 메모리 누수 없음
- D) `arr1`과 `arr2` 모두 메모리 누수 가능성

**정답: B**

**해설:** 이 코드에서 `arr1 > 10` 조건이 참이면 `arr1`은 해제되지만 `arr2`는 해제되지 않은 채 함수가 종료됩니다. 이는 명백한 메모리 누수를 일으킵니다. 힙 메모리는 명시적으로 해제해야 하며, 함수가 종료될 때 자동으로 해제되지 않습니다. 이런 메모리 누수는 장기간 실행되는 프로그램에서 점진적으로 메모리를 소모하여 결국 성능 저하나 프로그램 실패를 초래할 수 있습니다.

## 문제 11
다음 코드에서 어떤 문제가 발생할 수 있는가?
```c
char* get_message() {
    char message[100];
    strcpy(message, "Function completed successfully");
    return message;
}
```
- A) 메모리 누수
- B) 댕글링 포인터(Dangling pointer) 반환
- C) 스택 오버플로우
- D) 힙 손상

**정답: B**

**해설:** 이 함수는 스택에 할당된 지역 배열 `message`의 주소를 반환합니다. 함수가 종료되면 스택 프레임이 해제되어 `message` 배열이 존재하는 메모리는 더 이상 유효하지 않습니다. 따라서 반환된 포인터는 댕글링 포인터가 되어, 이를 사용하면 예측 불가능한 동작이나 세그멘테이션 오류가 발생할 수 있습니다. 이 문제를 해결하려면 `malloc()`을 사용하여 힙에 메모리를 할당하거나, 정적 배열을 사용하거나, 함수 외부에서 할당한 메모리를 매개변수로 전달해야 합니다.

## 문제 12
`size memory` 명령 출력에서 `bss` 값 8은 어떤 종류의 변수들의 크기를 나타내는가?
- A) 초기화된 전역/정적 변수
- B) 초기화되지 않은 전역/정적 변수
- C) 스택 변수
- D) 힙에 할당된 메모리

**정답: B**

**해설:** 이미지 하단에 설명된 대로, `bss` 값은 초기화되지 않은 데이터(Block Started by Symbol)를 위한, 세그먼트의 크기를 바이트 단위로 나타냅니다. 이 영역은 초기화되지 않은 전역 변수와 정적 변수를 저장하며, 프로그램 실행 시 운영체제가 자동으로 0으로 초기화합니다. 초기화되지 않은 변수를 BSS에 저장함으로써 실행 파일 크기를 줄일 수 있습니다(초기값이 0인 대규모 배열 등을 파일에 저장할 필요가 없음).
