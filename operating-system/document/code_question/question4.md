# 운영체제 스레드 및 병행성 문제

# 쓰레드와 프로세스 생성 혼합 문제

쓰레드와 프로세스는 운영체제의 핵심 개념이지만, 특히 둘을 함께 사용할 때 헷갈리기 쉬운 상황이 많이 발생합니다. 다음은 쓰레드 호출과 fork() 시스템 콜을 혼합한 문제들입니다.

## 문제 1: 쓰레드와 fork() 조합 시 생성되는 프로세스/쓰레드 수

다음 코드를 실행하면 총 몇 개의 프로세스와 몇 개의 쓰레드가 생성됩니까?

```c
#include 
#include 
#include 

void *thread_function(void *arg) {
    fork();
    return NULL;
}

int main() {
    pthread_t tid1, tid2;
    
    pthread_create(&tid1, NULL, thread_function, NULL);
    pthread_create(&tid2, NULL, thread_function, NULL);
    
    pthread_join(tid1, NULL);
    pthread_join(tid2, NULL);
    
    return 0;
}
```

**정답**: 총 5개의 프로세스, 6개의 쓰레드

**해설**: 
1. 최초 메인 프로세스에는 3개의 쓰레드가 있음(메인 쓰레드, tid1, tid2)
2. tid1이 fork()를 호출하면 새로운 프로세스가 생성됨. 이 새 프로세스는 tid1 쓰레드만 복제함
3. tid2가 fork()를 호출하면 또 다른 프로세스가 생성됨. 이 프로세스도 tid2 쓰레드만 복제함
4. 원래 프로세스의 tid1도 fork()를 호출하여 또 다른 프로세스 생성
5. 원래 프로세스의 tid2도 fork()를 호출하여 또 다른 프로세스 생성

결과: 원래 프로세스(3 쓰레드) + 4개의 새 프로세스(각각 1 쓰레드) = 5 프로세스, 3+1+1+1+1 = 7 쓰레드

## 문제 2: 공유 변수 값 예측

다음 코드를 실행한 후 출력되는 값은 무엇입니까?

```c
#include 
#include 
#include 
#include 

int global_var = 0;

void *thread_function(void *arg) {
    global_var += 5;
    return NULL;
}

int main() {
    pthread_t tid;
    
    pthread_create(&tid, NULL, thread_function, NULL);
    pthread_join(tid, NULL);
    
    if (fork() == 0) {
        // 자식 프로세스
        global_var += 10;
        printf("Child: %d\n", global_var);
        return 0;
    } else {
        // 부모 프로세스
        wait(NULL);
        printf("Parent: %d\n", global_var);
    }
    
    return 0;
}
```

**정답**: 
```
Child: 15
Parent: 5
```

**해설**: 
1. 처음에 global_var는 0
2. 쓰레드가 global_var를 5 증가시켜 값은 5가 됨
3. fork() 호출 시 자식 프로세스는 부모의 메모리를 복사하므로 global_var=5를 상속받음
4. 자식 프로세스는 global_var에 10을 더해 15가 되고 이를 출력
5. 부모 프로세스는 자식이 종료될 때까지 기다린 후 global_var를 출력하지만, 자식이 변경한 값은 부모에게 영향을 주지 않으므로 여전히 5

## 문제 3: 실행 경로 예측

다음 코드를 실행할 때 출력되는 순서를 예측하세요.

```c
#include 
#include 
#include 

void *thread_function(void *arg) {
    printf("Thread running\n");
    if (fork() == 0) {
        printf("Child of thread\n");
        return NULL;
    }
    printf("Thread continues\n");
    return NULL;
}

int main() {
    pthread_t tid;
    
    printf("Main starts\n");
    pthread_create(&tid, NULL, thread_function, NULL);
    
    if (fork() == 0) {
        printf("Child of main\n");
        return 0;
    }
    
    pthread_join(tid, NULL);
    printf("Main ends\n");
    
    return 0;
}
```

**정답**: 출력 순서는 여러 가능성이 있지만, 다음 제약 조건이 적용됩니다:
- "Main starts"는 항상 첫 번째로 출력됨
- "Thread running"은 "Thread continues" 이전에 출력됨
- "Child of thread"는 "Thread running" 이후에 출력됨
- "Main ends"는 "Thread continues" 이후에 출력됨

**해설**: 
이 문제에서는 특정 순서가 보장되지 않지만, 쓰레드 생성과 fork() 호출 간의 상대적 타이밍 관계에 따라 여러 출력 순서가 가능합니다. 프로세스 스케줄링에 따라 달라질 수 있습니다.

## 문제 4: 혼합 모델에서의 쓰레드 수 계산

다음 코드를 실행하면 최종적으로 몇 개의 쓰레드가 실행됩니까?

```c
#include 
#include 
#include 
#include 

void *thread_func(void *arg) {
    int i;
    for (i = 0; i 
#include 
#include 

void *compute_task(void *arg) {
    // CPU 집약적 작업 시뮬레이션
    int i;
    for (i = 0; i 
#include 
#include 
#include 

int x = 0;

void *thread_function(void *arg) {
    x += 5;
    if (fork() == 0) {
        // 자식 프로세스
        x += 10;
        printf("Child of thread: x = %d\n", x);
        _exit(0);
    }
    x += 15;
    return NULL;
}

int main() {
    pthread_t tid;
    
    pthread_create(&tid, NULL, thread_function, NULL);
    x += 2;
    
    if (fork() == 0) {
        // 자식 프로세스
        x += 8;
        printf("Child of main: x = %d\n", x);
        _exit(0);
    }
    
    pthread_join(tid, NULL);
    printf("Main process: x = %d\n", x);
    
    return 0;
}
```

**정답**:
```
Child of thread: x = 15
Child of main: x = 10
Main process: x = 22
```

**해설**: 
1. 초기에 x = 0
2. 메인 쓰레드와 새 쓰레드가 병렬로 실행됨
3. 메인 쓰레드는 x += 2를 실행, 새 쓰레드는 x += 5를 실행. x = 7
4. 메인 쓰레드가 fork()를 호출하면 자식 프로세스는 x = 7을 상속받고 x += 8을 실행하여 x = 15가 됨
5. 새 쓰레드가 fork()를 호출하면 그 자식 프로세스는 x = 7을 상속받고 x += 10을 실행하여 x = 17이 됨
6. 새 쓰레드는 계속 실행하여 x += 15를 수행, x = 22가 됨
7. 메인 프로세스에서는 모든 쓰레드가 join된 후 x = 22를 출력함

## 객관식 문제

1. 스레드가 속한 프로세스의 자원 중 스레드 간에 공유되는 것은?
   - A) 레지스터 값
   - B) 힙 메모리
   - C) 스택 메모리
   - D) 프로그램 카운터

2. 다음 중 스레드 사용의 주요 이점으로 볼 수 없는 것은?
   - A) 응답성(Responsiveness)
   - B) 자원 공유(Resource sharing)
   - C) 경제성(Economy)
   - D) 메모리 격리(Memory isolation)

3. 병행성(Concurrency)과 병렬성(Parallelism)의 차이점으로 올바른 것은?
   - A) 병행성은 여러 스레드가 동시에 진행되는 것이고, 병렬성은 여러 스레드가 실제로 동시에 실행되는 것이다
   - B) 병행성은 단일 코어에서만 가능하고, 병렬성은 불가능하다
   - C) 병행성은 여러 스레드의 동시 실행을 의미하고, 병렬성은 스레드 간 자원 공유를 의미한다
   - D) 병행성과 병렬성은 동일한 개념이다

4. 다음 중 사용자 수준 스레드와 커널 수준 스레드의 차이점으로 옳지 않은 것은?
   - A) 사용자 수준 스레드는 운영체제 커널이 인식하지 못한다
   - B) 커널 수준 스레드는 운영체제에 의해 직접 관리된다
   - C) 사용자 수준 스레드는 컨텍스트 스위칭이 필요 없다
   - D) 사용자 수준 스레드는 멀티코어 시스템에서 병렬 실행이 불가능하다

5. 암달의 법칙(Amdahl's Law)에 따라 60%가 병렬화 가능한 프로그램을 4개의 처리 코어에서 실행할 때 얻을 수 있는 최대 속도 향상은?
   - A) 1.6배
   - B) 2.0배
   - C) 2.5배
   - D) 4.0배

## 단답형 문제

6. 스레드가 생성될 때 프로세스 생성과 비교하여 어떤 자원이 새로 할당되는가?

7. 여러 스레드가 서로의 작업 완료를 기다려야 하는 상황에서 사용되는 자바 API는?

8. 많은 수의 작은 작업을 효율적으로 실행하기 위해 여러 스레드를 미리 생성해 두는 기법은?

9. 리눅스에서 프로세스와 스레드를 모두 지칭하는 용어는?

10. 스레드 취소(thread cancellation)에는 비동기식과 지연식 두 가지 방법이 있다. 일반적으로 어떤 방법이 선호되는가?

## 서술형 문제

11. 다중 스레드 웹 서버가 단일 스레드 웹 서버보다 성능이 우수한 이유를 설명하시오.

12. 사용자 수준 스레드 매핑 모델(many-to-one, one-to-one, many-to-many)의 차이점과 각각의 장단점을 설명하시오.

13. 데이터 병렬성(Data Parallelism)과 작업 병렬성(Task Parallelism)의 차이점을 예를 들어 설명하시오.

14. 스레드 풀(Thread Pool)을 사용하는, 이점과 구현 방법에 대해 설명하시오.

15. 다음 코드가 생성하는 총 프로세스 수를 계산하고 이유를 설명하시오.
```c
#include 
#include 
int main()
{
    int i;
    for (i = 0; i < 4; i++)
        fork();
    return 0;
}
```

## 프로그래밍 과제

16. 정수 배열을 입력받아 평균값, 최댓값, 최솟값을 계산하는 다중 스레드 프로그램을 작성하시오. 세 개의 별도 작업자 스레드를 생성하여 각각 평균, 최댓값, 최솟값을 계산하도록 합니다.

17. 몬테카를로 방법을 사용하여 π값을 계산하는 다중 스레드 프로그램을 작성하시오. 별도의 스레드를 생성하여 무작위 점을 생성하고, 원 안에 있는 점의 수를 계산한 후 이를 이용해 π값을 추정합니다.

18. Fork-Join 병렬 처리를 사용하여 퀵소트 또는 병합 정렬을 구현하는 자바 프로그램을 작성하시오. RecursiveAction 클래스를 확장하여 구현합니다.


# 운영체제 스레드 및 병행성 문제 - 답안

## 객관식 문제

1. 스레드가 속한 프로세스의 자원 중 스레드 간에 공유되는 것은?
   - **정답: B) 힙 메모리**
   
   **해설:** 스레드는 동일한 프로세스 내에서 "코드와 데이터를 포함한 프로세스 자원의 많은 부분을 공유합니다"[1]. 힙 메모리는 모든 스레드가 공유하는 반면, 레지스터 값, 스택 메모리, 프로그램 카운터는 각 스레드마다 고유합니다.

2. 다음 중 스레드 사용의 주요 이점으로 볼 수 없는 것은?
   - **정답: D) 메모리 격리(Memory isolation)**

   **해설:** 교재에 따르면 "다중 스레드 애플리케이션의 네 가지 주요 이점은 (1) 응답성, (2) 자원 공유, (3) 경제성, (4) 확장성입니다"[1]. 메모리 격리는 이점이 아니라 오히려 스레드의 특성과 반대되는 개념입니다. 스레드는 메모리를 공유하므로 격리되지 않습니다.

3. 병행성(Concurrency)과 병렬성(Parallelism)의 차이점으로 올바른 것은?
   - **정답: A) 병행성은 여러 스레드가 동시에 진행되는 것이고, 병렬성은 여러 스레드가 실제로 동시에 실행되는 것이다**

   **해설:** "병행성은 여러 스레드가 진행 중일 때 존재하는 반면, 병렬성은 여러 스레드가 동시에 진행 중일 때 존재합니다. 단일 CPU 시스템에서는 병행성만 가능하며, 병렬성은 여러 CPU를 제공하는 멀티코어 시스템이 필요합니다"[1].

4. 다음 중 사용자 수준 스레드와 커널 수준 스레드의 차이점으로 옳지 않은 것은?
   - **정답: C) 사용자 수준 스레드는 컨텍스트 스위칭이 필요 없다**

   **해설:** 사용자 수준 스레드도 컨텍스트 스위칭이 필요합니다. 다만 커널 개입 없이 사용자 공간에서 더 가볍게 수행될 수 있습니다. 사용자 수준 스레드는 커널이 인식하지 못하고, 멀티코어에서 병렬 실행이 불가능하며, 커널 수준 스레드는 운영체제가 직접 관리한다는 점은 모두 올바른 설명입니다.

5. 암달의 법칙(Amdahl's Law)에 따라 60%가 병렬화 가능한 프로그램을 4개의 처리 코어에서 실행할 때 얻을 수 있는 최대 속도 향상은?
   - **정답: B) 2.0배**

   **해설:** 암달의 법칙은 다음과 같습니다: Speedup = 1 / ((1 - P) + P/N)
   P는 병렬화 가능한 부분(0.6), N은 코어 수(4)입니다.
   Speedup = 1 / ((1 - 0.6) + 0.6/4) = 1 / (0.4 + 0.15) = 1 / 0.55 ≈ 1.82
   가장 가까운 답은 B) 2.0배입니다.

## 단답형 문제

6. 스레드가 생성될 때 프로세스 생성과 비교하여 어떤 자원이 새로 할당되는가?
   
   **정답:** 스택 메모리, 레지스터 집합(프로그램 카운터 포함), 스레드 로컬 저장소

   **해설:** 스레드는 "코드와 데이터를 포함한 많은 프로세스 자원을 공유"[1]하지만, 각 스레드는 독립적인 실행을 위해 자체 스택과 레지스터 값을 유지해야 합니다. 프로세스 생성과 달리 스레드 생성은 주소 공간, 파일 디스크립터 등 많은 자원을 공유하므로 더 가볍습니다.

7. 여러 스레드가 서로의 작업 완료를 기다려야 하는 상황에서 사용되는 자바 API는?

   **정답:** Thread.join()

   **해설:** Java에서 스레드가 다른 스레드의 완료를 기다려야 할 때 Thread.join() 메서드를 사용합니다. 이 메서드를 호출하면 호출 스레드는 대상 스레드가 종료될 때까지 실행이 일시 중지됩니다.

8. 많은 수의 작은 작업을 효율적으로 실행하기 위해 여러 스레드를 미리 생성해 두는 기법은?

   **정답:** 스레드 풀(Thread Pool)

   **해설:** "암시적 스레딩에는 여러 접근 방식이 있으며, 스레드 풀, 포크-조인 프레임워크, Grand Central Dispatch가 포함됩니다"[1]. 스레드 풀은 스레드 생성/소멸 오버헤드를 줄이고 많은 작은 작업을 효율적으로 처리합니다.

9. 리눅스에서 프로세스와 스레드를 모두 지칭하는 용어는?

   **정답:** 태스크(task)

   **해설:** "다른 많은 운영체제와 달리 Linux는 프로세스와 스레드를 구분하지 않습니다. 대신 각각을 태스크(task)로 동일하게 취급합니다"[1].

10. 스레드 취소(thread cancellation)에는 비동기식과 지연식 두 가지 방법이 있다. 일반적으로 어떤 방법이 선호되는가?

    **정답:** 지연식 취소(deferred cancellation)

    **해설:** "스레드는 비동기식 또는 지연식 취소를 사용하여 종료될 수 있습니다. 비동기식 취소는 업데이트 중이더라도 스레드를 즉시 중지시키는 반면, 지연식 취소는 스레드에게 종료해야 함을 알리지만 질서 있게 종료할 수 있게 합니다. 대부분의 경우, 지연식 취소가 비동기식 종료보다 선호됩니다"[1].

## 서술형 문제

11. 다중 스레드 웹 서버가 단일 스레드 웹 서버보다 성능이 우수한 이유를 설명하시오.

    **정답:**
    다중 스레드 웹 서버는 여러 가지 이유로 단일 스레드 서버보다 성능이 우수합니다:

    1. **응답성 향상**: 각 클라이언트 요청을 별도의 스레드에서 처리할 수 있어, 한 요청이 I/O를 기다리는 동안 다른 요청을 처리할 수 있습니다. 이로 인해 전체 응답 시간이 크게 개선됩니다.

    2. **자원 효율성**: 프로세스보다 스레드가 더 가벼우므로, 많은 동시 연결을 처리할 때 메모리와 CPU 사용이 더 효율적입니다. 스레드는 코드, 데이터 세그먼트, 열린 파일 등을 공유합니다.

    3. **처리량 증가**: 다중 CPU 또는 멀티코어 시스템에서 병렬 실행이 가능해 전체 처리량이 증가합니다.

    4. **블로킹 작업 처리**: 웹 서버는 디스크 I/O, 데이터베이스 쿼리, 외부 API 호출 등 많은 블로킹 작업을 수행합니다. 다중 스레드 환경에서는 한 스레드가 블로킹되어도 다른 스레드가 계속 작업할 수 있습니다.

    멀티스레딩의 이러한 이점들은 특히 높은 동시성이 요구되는 웹 서버 환경에서 중요합니다.

12. 사용자 수준 스레드 매핑 모델(many-to-one, one-to-one, many-to-many)의 차이점과 각각의 장단점을 설명하시오.

    **정답:**
    사용자 수준 스레드 매핑 모델은 사용자 스레드와 커널 스레드 간의 관계를 정의합니다:

    **Many-to-One 모델**:
    - 여러 사용자 수준 스레드가 하나의 커널 스레드에 매핑됩니다.
    - 장점: 사용자 공간에서 스레드 관리, 효율적인 스레드 전환, 운영체제 지원 불필요
    - 단점: 한 스레드가 블로킹 호출을 하면 전체 프로세스가 블로킹됨, 멀티코어 활용 불가, 진정한 병렬성 달성 불가

    **One-to-One 모델**:
    - 각 사용자 스레드가 하나의 커널 스레드에 매핑됩니다.
    - 장점: 더 많은 병렬성 제공, 한 스레드 블로킹이 다른 스레드에 영향 없음, 멀티코어 활용 가능
    - 단점: 각 스레드 생성이 커널 스레드 생성 필요, 시스템 리소스 부담 증가, 스레드 수 제한될 수 있음

    **Many-to-Many 모델**:
    - 여러 사용자 스레드가 유사하거나 더 적은 수의 커널 스레드에 매핑됩니다.
    - 장점: 개발자가 필요한 만큼 스레드 생성 가능, 커널 스레드는 멀티프로세서에서 병렬 실행 가능, 효율성과 병렬성 간 좋은 균형
    - 단점: 구현 복잡성 증가, 스케줄링이 더 복잡해짐, 모델 이해 어려움

    이 모델들 중 선택은 애플리케이션 요구사항, 시스템 특성, 운영체제 지원에 따라 달라집니다.

13. 데이터 병렬성(Data Parallelism)과 작업 병렬성(Task Parallelism)의 차이점을 예를 들어 설명하시오.

    **정답:**
    데이터 병렬성과 작업 병렬성은 병렬 컴퓨팅의 두 가지 주요 접근 방식입니다:

    **데이터 병렬성(Data Parallelism)**:
    - 같은 데이터의 하위 집합을 여러 컴퓨팅 코어에 분산하고 각 코어에서 동일한 연산을 수행합니다[1].
    - 데이터가 분할되지만 작업은 동일합니다.
    - 예: 대용량 배열의 모든 요소에 동일한 함수 적용(예: 각 픽셀에 필터 적용), 행렬 곱셈에서 각 코어가 결과 행렬의 다른 부분 계산

    **작업 병렬성(Task Parallelism)**:
    - 데이터가 아닌 작업을 여러 코어에 분산합니다. 각 작업은 고유한 연산을 실행합니다[1].
    - 다양한 작업이 다른 데이터에 병렬로 수행됩니다.
    - 예: 웹 브라우저에서 렌더링, 다운로드, 사용자 인터페이스 처리를 별도 스레드에서 처리, 비디오 인코더에서 오디오 처리, 비디오 처리, I/O를 별도 스레드에서 동시 수행

    데이터 병렬성은, 계산이 데이터 집합에 균일하게 적용될 때 적합하며, 작업 병렬성은 명확하게 구분되는 독립적인 작업이 있을 때 효과적입니다.

14. 스레드 풀(Thread Pool)을 사용하는, 이점과 구현 방법에 대해 설명하시오.

    **정답:**
    **스레드 풀 이점**:
    1. **성능 향상**: 스레드 생성 및 소멸 오버헤드 감소
    2. **자원 관리**: 동시 실행 스레드 수 제한으로 시스템 리소스 과부하 방지
    3. **응답성 개선**: 작업 제출 즉시 기존 스레드로 실행 가능
    4. **재사용성**: 완료된 스레드가 새 작업에 재사용되어 효율성 증가
    5. **유연성**: 작업 큐 우선순위 조정, 다양한 실행 정책 구현 가능

    **구현 방법**:
    1. **작업 큐 생성**: 실행할 작업을 저장하는 큐 구현
    2. **스레드 풀 초기화**: 애플리케이션 시작 시 고정 또는 가변 수의 스레드 생성
    3. **작업 제출 메커니즘**: 클라이언트가 작업을 큐에 추가할 수 있는 인터페이스 제공
    4. **워커 스레드 구현**: 각 스레드는 큐에서 작업을 가져와 실행하고 완료 후 다음 작업 처리
    5. **풀 관리**: 필요에 따라 스레드 추가/제거, 작업자 스레드 상태 모니터링

    자바의 경우 java.util.concurrent 패키지의 ExecutorService와 Executors 클래스가 다양한 스레드 풀 구현을 제공합니다. C#의 ThreadPool 클래스, C++11의 std::async 및 std::thread 등 다른 언어에도 유사한 메커니즘이 있습니다.

15. 다음 코드가 생성하는 총 프로세스 수를 계산하고 이유를 설명하시오.
    ```c
    #include 
    #include 
    int main()
    {
        int i;
        for (i = 0; i < 4; i++)
            fork();
        return 0;
    }
    ```

    **정답:**
    이 코드는 총 16개의 프로세스를 생성합니다.

    **해설:**
    fork() 호출은 현재 프로세스를 복제합니다. 각 반복에서 존재하는 모든 프로세스가 fork()를 실행하므로 프로세스 수가 기하급수적으로 증가합니다.

    프로세스 생성 과정:
    - 초기 상태: 1개 프로세스
    - i=0 반복 후: 2개 프로세스 (1 → 2)
    - i=1 반복 후: 4개 프로세스 (2 → 4)
    - i=2 반복 후: 8개 프로세스 (4 → 8)
    - i=3 반복 후: 16개 프로세스 (8 → 16)

    따라서 총 프로세스 수는 2^4 = 16개입니다.

## 프로그래밍 과제 (개요만 제공)

16. 정수 배열 통계 계산용 다중 스레드 프로그램:
    - 세 개의 작업자 스레드 생성: 평균, 최댓값, 최솟값 계산
    - 전역 변수를 통한 결과 공유
    - 메인 스레드는 작업자 스레드 종료 후 결과 출력
    - 입력: 명령줄 인자로 정수 리스트

17. 몬테카를로 방식 π 계산용 다중 스레드 프로그램:
    - 별도 스레드에서 무작위 점 생성 및 원 내부 점 계산
    - 전역 변수로 결과 공유
    - 공식: π ≈ 4 × (원 안의 점 수) / (전체 점 수)
    - 점 수가 많을수록 정확도 향상

18. Fork-Join 프레임워크 기반 정렬 알고리즘:
    - RecursiveAction 클래스 확장 구현
    - 병렬 처리를 위한 작업 분할 전략 구현
    - 임계값보다 작은 하위 배열은 직접 정렬
    - 임계값보다 큰 하위 배열은 재귀적으로 작업 분할
