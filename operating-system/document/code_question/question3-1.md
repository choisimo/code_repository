# 운영체제 Chapter 3 연습문제

## 연습문제(Practice Exercises)

**3.1 다음 프로그램의 출력 결과는 무엇인가?**

```c
#include 
#include 
#include 

int value = 5;

int main()
{
    pid_t pid;
    
    pid = fork();
    
    if (pid == 0) { /* 자식 프로세스 */
        value += 15;
        return 0;
    }
    else if (pid > 0) { /* 부모 프로세스 */
        wait(NULL);
        printf("PARENT: value = %d", value);
        return 0;
    }
}
```

**3.2 다음 프로그램이 생성하는 프로세스의 총 개수는 몇 개인가? (초기 부모 프로세스 포함)**

```c
#include 
#include 

int main()
{
    /* fork a child process */
    fork();
    
    /* fork another child process */
    fork();
    
    /* and fork another */
    fork();
    
    return 0;
}
```

**3.3 모바일 iOS 운영체제의 초기 버전은 동시 처리를 지원하지 않았다. 운영체제에 동시 처리를 추가할 때 발생하는 세 가지 주요 복잡성을 논의하시오.**

**3.4 일부 컴퓨터 시스템은 다중 레지스터 세트를 제공한다. 새로운 컨텍스트가 이미 레지스터 세트 중 하나에 로드되어 있는 경우 컨텍스트 스위치가 어떻게 진행되는지 설명하시오. 새로운 컨텍스트가 레지스터 세트가 아닌 메모리에 있고 모든 레지스터 세트가 사용 중인 경우는 어떻게 되는가?**

**3.5 프로세스가 fork() 연산을 사용하여 새 프로세스를 생성할 때, 다음 중 부모 프로세스와 자식 프로세스 간에 공유되는 것은 무엇인가?**
a. 스택
b. 힙
c. 공유 메모리 세그먼트

**3.6 RPC 메커니즘에서 "exactly once" 의미체계와 관련하여, 클라이언트에게 전송되는 ACK 메시지가 네트워크 문제로 인해 손실되더라도 알고리즘이 올바르게 실행되는가? 메시지 순서를 설명하고 "exactly once"가 여전히 유지되는지 논의하시오.**

**3.7 분산 시스템이 서버 장애에 취약하다고 가정하자. RPC의 "exactly once" 의미체계를 보장하기 위해 어떤 메커니즘이 필요한가?**

## 일반 연습문제(Exercises)

**3.8 프로세스 간 컨텍스트 스위치를 수행하기 위해 커널이 취하는 조치를 설명하시오.**

**3.9 Figure 3.7과 유사한 프로세스 트리를 구성하시오. UNIX 또는 Linux 시스템에서 프로세스 정보를 얻으려면 `ps -ael` 명령을 사용하세요. `ps` 명령에 대한 자세한 정보를 얻으려면 `man ps` 명령을 사용하세요. Windows 시스템의 작업 관리자는 부모 프로세스 ID를 제공하지 않지만, technet.microsoft.com에서 제공하는 프로세스 모니터 도구는 프로세스 트리 도구를 제공합니다.**

**3.10 UNIX 및 Linux 시스템에서 프로세스 종료와 관련하여 init(또는 systemd) 프로세스의 역할을 설명하시오.**

**3.11 초기 부모 프로세스를 포함하여, 다음 프로그램이 생성하는 프로세스의 총 개수는 몇 개인가?**

```c
#include 
#include 

int main()
{
    int i;
    for (i = 0; i 
#include 
#include 

int main()
{
    pid_t pid;
    
    /* fork a child process */
    pid = fork();
    
    if (pid 
#include 
#include 

int main()
{
    pid_t pid, pid1;
    
    /* fork a child process */
    pid = fork();
    
    if (pid 
#include 
#include 
#define SIZE 5

int nums[SIZE] = {0, 1, 2, 3, 4};

int main()
{
    int i;
    pid_t pid;
    
    pid = fork();
    
    if (pid == 0) {
        for (i = 0; i  0) {
        wait(NULL);
        for (i = 0; i "로 실행되며 지정된 명령을 실행하는 데 소요된 경과 시간을 보고합니다. 이는 fork() 및 exec() 함수와 경과 시간을 결정하기 위한 gettimeofday() 함수를 사용합니다. 또한 두 가지 다른 IPC 메커니즘의 사용이 필요합니다.**

일반적인 전략은 지정된 명령을 실행할 자식 프로세스를 포크하는 것입니다. 그러나 자식이 명령을 실행하기 전에 현재 시간의 타임스탬프("시작 시간"이라고 함)를 기록합니다. 부모 프로세스는 자식 프로세스가 종료될 때까지 기다립니다. 자식이 종료되면 부모는 종료 시간에 대한 현재 타임스탬프를 기록합니다. 시작 시간과 종료 시간의 차이는 명령을 실행하는 데 소요된 경과 시간을 나타냅니다. 아래 예시 출력은 ls 명령을 실행하는 데 소요된 시간을 보고합니다:

```
./time ls
time.c
time
Elapsed time: 0.25422
```

부모와 자식은 별도의 프로세스이므로 시작 시간을 공유하는 방법을 마련해야 합니다. 이 프로그램의 두 가지 버전을 작성해야 합니다. 각각 다른 IPC 방법을 사용합니다.

첫 번째 버전은 자식 프로세스가 exec()을 호출하기 전에 공유 메모리 영역에 시작 시간을 쓰도록 합니다. 자식 프로세스가 종료된 후 부모는 공유 메모리에서 시작 시간을 읽습니다. 3.7.1절의 POSIX 공유 메모리를 참조하세요. 해당 섹션에는 생산자와 소비자를 위한 별도의 프로그램이 있습니다. 이 문제의 해결책에는 단일 프로그램만 필요하므로 자식 프로세스가 포크되기 전에 공유 메모리 영역을 설정하여 부모와 자식 프로세스 모두 공유 메모리 영역에 접근할 수 있도록 할 수 있습니다.

두 번째 버전은 파이프를 사용합니다. 자식은 시작 시간을 파이프에 쓰고, 부모는 자식 프로세스 종료 후 이를 읽습니다.

현재 타임스탬프를 기록하기 위해 gettimeofday() 함수를 사용합니다. 이 함수는 struct timeval 객체에 대한 포인터를 전달받습니다. 이 객체에는 tv_sec와 t_usec 두 멤버가 있습니다. 이들은 1970년 1월 1일(UNIX EPOCH로 알려진) 이후 경과된 초 및 마이크로초 수를 나타냅니다. 다음 코드 샘플은 이 함수를 사용하는 방법을 보여줍니다:

```c
struct timeval current;
gettimeofday(&current, NULL);
// current.tv_sec는 초를 나타냄
// current.tv_usec는 마이크로초를 나타냄
```

**3.20 운영체제의 pid 관리자는 프로세스 식별자를 관리하는 역할을 합니다. 프로세스가 처음 생성될 때 pid 관리자에 의해 고유한 pid가 할당됩니다. 프로세스가 실행을 완료하면 pid는 pid 관리자에게 반환되며, 관리자는 나중에 이 pid를 재할당할 수 있습니다. 프로세스 식별자는 3.3.1절에서 더 자세히 논의됩니다. 여기서 가장 중요한 것은 프로세스 식별자가 고유해야 한다는 것입니다. 활성 상태의 두 프로세스는 동일한 pid를 가질 수 없습니다.**

가능한 pid 값의 범위를 식별하기 위해 다음 상수를 사용하세요:

```c
#define MIN_PID 300
#define MAX_PID 5000
```

프로세스 식별자의 가용성을 나타내기 위해 원하는 데이터 구조를 사용할 수 있습니다. 한 가지 전략은 Linux가 사용한 방식을 채택하여 비트맵을 사용하는 것입니다. 여기서 위치 i에서 값이 0이면 값이 i인 프로세스 id를 사용할 수 있으며, 값이 1이면 프로세스 id가 현재 사용 중임을 나타냅니다.

pid를 획득하고 해제하기 위한 다음 API를 구현하세요:
- `int allocate_map(void)` - pid를 나타내기 위한 데이터 구조를 생성하고 초기화합니다. 실패하면 -1을 반환하고, 성공하면 1을 반환합니다.
- `int allocate_pid(void)` - pid를 할당하고 반환합니다. pid를 할당할 수 없는 경우(모든 pid가 사용 중) -1을 반환합니다.
- `void release_pid(int pid)` - pid를 해제합니다.

이 프로그래밍 문제는 나중에 4장과 6장에서 수정될 예정입니다.

**3.21 Collatz 추측은 양의 정수 n을 취하여 다음 알고리즘을 적용할 때 어떤 일이 발생하는지에 관한 것입니다:**

```
n = {
    n/2, n이 짝수인 경우
    3 × n + 1, n이 홀수인 경우
}
```

이 추측은 이 알고리즘이 계속 적용될 때 모든 양의 정수가 결국 1에 도달한다고 주장합니다. 예를 들어, n = 35인 경우 수열은 다음과 같습니다:

35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1

fork() 시스템 호출을 사용하여 자식 프로세스에서 이 수열을 생성하는 C 프로그램을 작성하세요. 시작 번호는 명령줄에서 제공됩니다. 예를 들어, 명령줄에 매개변수로 8이 전달되면 자식 프로세스는 8, 4, 2, 1을 출력합니다. 부모와 자식 프로세스는 데이터의 자체 복사본을 가지므로 자식이 수열을 출력해야 합니다. 부모가 프로그램을 종료하기 전에 자식 프로세스가 완료될 때까지 기다리도록 wait() 호출을 호출하게 하세요. 명령줄에서 양의 정수가 전달되는지 확인하기 위해 필요한 오류 검사를 수행하세요.
