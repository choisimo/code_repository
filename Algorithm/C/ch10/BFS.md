### BFS 코드와 작동 방식 설명

#### 코드 설명
```c
bfs(int v) {
    front = 0; rear = 0;   // 큐 초기화
    for (i = 0; i < N; i++) // 모든 정점을 방문하지 않은 상태로 초기화
        visit[i] = false;

    visit[v] = true;        // 시작 정점 방문 표시
    printf("%d ", v);       // 정점 출력
    addq(v);                // 큐에 정점 추가

    while (front) {         // 큐가 비어 있지 않은 동안 반복
        v = deleteq();      // 큐에서 정점 제거
        for (w = graph[v]; w; w = w->link) { // 인접 정점 탐색
            if (!visit[w->ver]) {            // 방문하지 않은 정점이면
                visit[w->ver] = true;        // 방문 표시
                printf("%d ", w->ver);       // 정점 출력
                addq(w->ver);                // 큐에 추가
            }
        }
    }
}
```

- `front`와 `rear`는 큐의 앞과 뒤를 관리합니다.
- `visit[]` 배열은 정점 방문 여부를 기록합니다.
- `addq(v)`는 정점을 큐에 추가하는 함수이고, `deleteq()`는 큐에서 정점을 제거하는 함수입니다.
- `graph[v]`는 정점 `v`에 연결된 인접 정점의 리스트입니다.

---

#### BFS 작동 방식 설명 (이미지 참고)

1. **초기 상태 (a)**:
    - 시작 정점 `1`에서 탐색을 시작합니다.
    - 정점 `1` 방문 표시 (`visit[1] = true`) 및 큐에 추가.

2. **첫 번째 반복 (b)**:
    - 큐에서 `1` 제거하고 인접한 정점 `2`, `3`, `4`를 탐색.
    - 정점 `2`, `3`, `4`를 방문 표시 후 큐에 추가.

3. **두 번째 반복 (c)**:
    - 큐에서 `2` 제거하고 인접한 정점 `5` 탐색.
    - 정점 `5`를 방문 표시 후 큐에 추가.

4. **세 번째 반복 (d)**:
    - 큐에서 `3` 제거하고 인접한 정점 `6` 탐색.
    - 정점 `6`을 방문 표시 후 큐에 추가.

5. **마지막 반복 (e)**:
    - 큐에서 `4` 제거하고 인접한 정점 `7` 탐색.
    - 정점 `7`을 방문 표시 후 큐에 추가.
    - 이후 `8`까지 탐색 후 종료.

---

#### 쉽게 암기하는 방법
1. **큐 초기화**:
   ```c
   front = 0; rear = 0;
   ```
   큐를 초기화하고, 방문 여부를 모두 `false`로 설정.

2. **시작 정점 처리**:
   ```c
   visit[v] = true;
   addq(v);
   ```
   시작 정점을 방문 처리하고 큐에 추가.

3. **큐가 빌 때까지 반복**:
   ```c
   while (front) {
       v = deleteq();
       // 인접 정점 탐색
   }
   ```
   BFS의 핵심은 큐를 이용해 방문 대기 중인 정점을 하나씩 처리하는 것입니다.

4. **인접 정점 탐색**:
   ```c
   for (w = graph[v]; w; w = w->link) {
       if (!visit[w->ver]) {
           visit[w->ver] = true;
           addq(w->ver);
       }
   }
   ```
   방문하지 않은 정점을 방문 처리하고 큐에 추가.

---

#### 암기 요령
- 큐 사용 강조: "정점 넣고 → 꺼내고 → 이웃 방문"
- `visit[]` 배열로 방문 여부 확인.
- BFS는 **Queue** 기반, DFS는 **Stack** 기반.

---

#### 문제
1. **다음 그래프의 BFS 탐색 순서를 구하시오.**  
   정점 1부터 시작하며, 인접 정점은 오름차순으로 탐색.
   ```
         1
        /|\
       2 3 4
      /   \
     5     6
   ```
    - 입력: 그래프의 인접 리스트 또는 인접 행렬.
    - 출력: 탐색 순서.

2. **코드 빈칸 채우기**:
    - 아래 코드를 완성하세요:
      ```c
      bfs(int v) {
          front = 0; rear = 0;
          for (i = 0; i < N; i++) visit[i] = false;
 
          visit[v] = true;
          ____________; // 큐에 시작 정점 추가
 
          while (__________) {
              v = deleteq();
              for (w = graph[v]; w; w = w->link) {
                  if (__________) {
                      visit[w->ver] = true;
                      addq(__________);
                  }
              }
          }
      }
      ```

---

#### 정답
1. BFS 탐색 순서: `1 → 2 → 3 → 4 → 5 → 6`
2. 빈칸 정답:
   ```c
   addq(v);
   front;
   !visit[w->ver];
   w->ver;
   ```