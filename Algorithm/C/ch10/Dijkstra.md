아래는 이미지의 다익스트라 알고리즘 코드를 그대로 작성한 것입니다.

---

```c
Dijkstra(v, cost[][], dist[], n, found[]) {
    for (i = 0; i < n; i++) { 
        found[i] = false;  // 모든 정점 초기화
        dist[i] = cost[v][i];  // 시작 정점 v에서 각 정점까지 초기 거리
    }
    found[v] = true;  // 시작 정점 방문 처리

    for (i = 0; i < n - 2; i++) {  // 모든 정점 방문
        u = extractMin(dist, n, found);  // 최소 거리 정점 선택
        found[u] = true;  // 선택된 정점 방문 처리

        for (w = 0; w < n; w++) {  // 선택된 정점 u와 연결된 정점들 갱신
            if (!found[w] && dist[w] > dist[u] + cost[u][w]) {
                dist[w] = dist[u] + cost[u][w];  // 더 짧은 거리로 갱신
            }
        }
    }
}
```

```c
extractMin(dist[], n, found[]) {
    min = MAX;
    minpos = -1;

    for (i = 0; i < n; i++) {
        if (!found[i] && dist[i] < min) {  // 방문하지 않은 정점 중 최소 거리
            min = dist[i];
            minpos = i;
        }
    }
    return minpos;  // 최소 거리 정점 반환
}
```

---

### 주요 포인트
1. `Dijkstra` 함수는 전체 흐름을 제어합니다.
    - `dist[]` 배열 초기화
    - `found[]` 배열로 방문 여부 관리
2. `extractMin` 함수는 방문하지 않은 정점 중 최소 거리 정점을 선택합니다.
3. 내부 반복문은 선택된 정점으로부터 연결된 정점들의 거리를 갱신합니다.

위 코드를 활용해서 직접 코딩하거나 손으로 흐름을 따라보며 이해하면 확실히 기억할 수 있을 거예요! 😊
---

### 다익스트라 알고리즘 코드 구조

1. **초기화 단계**
    - `found[]`: 모든 정점이 아직 방문되지 않았음을 표시합니다.
    - `dist[]`: 시작 정점에서 각 정점까지의 거리 배열입니다. 초기값은 시작 정점으로부터의 직접적인 비용(`cost[v][i]`)으로 설정됩니다.

   ```c
   for (i = 0; i < n; i++) {
       found[i] = false; // 아직 방문하지 않음
       dist[i] = cost[v][i]; // 시작점 v에서 각 노드까지의 초기 비용
   }
   found[v] = true; // 시작점은 방문한 상태
   ```

2. **가장 작은 거리의 정점 선택 (extractMin)**
    - `extractMin` 함수로 `dist[]` 배열에서 아직 방문하지 않은 정점 중 가장 작은 거리를 가진 정점을 선택합니다.
    - 선택된 정점은 `found[]`를 통해 방문 처리됩니다.

   ```c
   u = extractMin(dist, n, found); // 방문하지 않은 노드 중 최소 거리 노드 선택
   found[u] = true; // 선택된 노드는 방문 표시
   ```

3. **거리 갱신 단계**
    - 선택된 정점 `u`를 통해 다른 정점으로 가는 경로의 거리가 더 짧은지 확인하고, 더 짧다면 `dist[]` 값을 갱신합니다.
    - 이때, `dist[w] > dist[u] + cost[u][w]` 조건으로 새로운 경로를 확인합니다.

   ```c
   for (w = 0; w < n; w++) {
       if (!found[w] && dist[w] > dist[u] + cost[u][w]) {
           dist[w] = dist[u] + cost[u][w]; // 더 짧은 경로로 갱신
       }
   }
   ```

4. **최종 결과 반환**
    - 모든 정점이 방문되면 `dist[]` 배열에 시작 정점에서 각 정점까지의 최소 비용이 저장됩니다.

---

### 코드 기억 팁
1. **큰 흐름 잡기**: 초기화 → 최소 거리 선택 → 거리 갱신 → 반복
    - 이 4단계를 생각하면서 코드를 외우면 기억하기 쉽습니다.

2. **핵심 로직 요약**:
    - `extractMin`은 최소 거리를 선택
    - `dist[w] > dist[u] + cost[u][w]` 조건으로 거리 갱신

3. **그림으로 이해**:
    - 각 단계마다 `dist[]`, `found[]` 상태를 확인하며 어떻게 갱신되는지 손으로 따라 그려보세요.

---

### 예제 흐름 설명
- 시작점 `0`에서 출발합니다.
- `dist` 배열이 `0 10 ∞ ∞ ∞`로 초기화됩니다.
- `u = 1`(최소 거리인 `10`을 가진 정점)을 방문하며, 다른 정점들과의 거리를 갱신합니다.
- 반복하며 모든 정점이 방문될 때까지 진행합니다.

위 내용을 반복하며 코드 흐름과 작동 방식을 이해하고 연습해보세요! 🎯