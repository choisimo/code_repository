### **행렬 경로 문제 연습 문제**

#### **문제 1: 빈칸 채우기**
1. 아래 점화식을 완성하세요:
   \[
   c[i, j] = m[i, j] + max(\_\_\_\_, \_\_\_\_)
   \]
    - \(\_\_\_\_\): 위쪽에서 오는 값 \( c[i-1, j] \)
    - \(\_\_\_\_\): 왼쪽에서 오는 값 \( c[i, j-1] \)

2. \( c[i, j] \)의 초기 조건은 무엇인가요?
    - \( c[i, 0] = \_\_\_\_\)
    - \( c[0, j] = \_\_\_\_\)

3. 최종 반환값은 무엇인가요?
   ```c
   return \_\_\_\_\_;
   ```

---

#### **문제 2: 새로운 입력 \( m \) 테이블 주어졌을 때 최적 경로 찾기**

##### **입력 테이블 (\( m \))**
| 열 | 1  | 2  | 3  | 4  |
|----|----|----|----|----|
| 행 1 | 3  | 8  | 2  | 6  |
| 행 2 | 5  | 1  | 4  | 9  |
| 행 3 | 6  | 7  | 3  | 2  |

##### **문제**
1. \( c[i, j] \) 테이블을 채우세요.
2. 최종 반환값 \( c[3, 4] \)의 값을 구하세요.

---

#### **문제 3: 경로 추적하기**
위의 테이블에서 최적 경로를 추적하세요:
1. \( c[3, 4] \)에서 시작하여 \( c[0, 0] \)까지 이동하며 경로를 표시하세요.
2. 어떤 셀에서 왔는지 경로를 화살표로 표시하세요.

---

#### **문제 4: 예제 복습 문제**
##### **입력 테이블**
| 열 | 1  | 2  | 3  |
|----|----|----|----|
| 행 1 | 6  | 7  | 12 |
| 행 2 | 5  | 3  | 11 |
| 행 3 | 7  | 17 | 3  |

1. \( c[i, j] \) 테이블을 계산하세요.
2. 최적 경로의 점수를 구하고 경로를 작성하세요.

---

### **정답**

#### **문제 1**
1. 점화식:
   \[
   c[i, j] = m[i, j] + \max(c[i-1, j], c[i, j-1])
   \]
2. 초기 조건:
    - \( c[i, 0] = 0 \)
    - \( c[0, j] = 0 \)
3. 반환값:
   ```c
   return c[n, n];
   ```

---

#### **문제 2: 풀이**

##### \( c \) 테이블 계산
| 열 | 1  | 2  | 3  | 4  |
|----|----|----|----|----|
| 행 1 | 3  | 11 | 13 | 19 |
| 행 2 | 8  | 12 | 16 | 25 |
| 행 3 | 14 | 21 | 24 | 27 |

최종 값: \( c[3, 4] = 27 \).

##### 최적 경로
- 시작: \( c[3, 4] \)
- 경로: \( (3, 4) \to (3, 3) \to (2, 3) \to (2, 2) \to (1, 2) \to (1, 1) \)

---

#### **문제 4**
##### \( c \) 테이블 계산
| 열 | 1  | 2  | 3  |
|----|----|----|----|
| 행 1 | 6  | 13 | 25 |
| 행 2 | 11 | 14 | 36 |
| 행 3 | 18 | 35 | 39 |

최종 값: \( c[3, 3] = 39 \).

##### 최적 경로
- 시작: \( c[3, 3] \)
- 경로: \( (3, 3) \to (3, 2) \to (2, 2) \to (1, 2) \to (1, 1) \).

위 문제들은 연습용으로 최적의 경로 문제를 이해하는 데 유용합니다!




### **행렬 경로 문제: 코드 작성 문제**

#### **문제 1: 코드 작성**
아래의 동적 프로그래밍 알고리즘을 기반으로 행렬 경로 문제를 해결하는 코드를 작성하세요.

##### **조건**
1. 입력은 \( n \times n \) 크기의 행렬 \( m \)입니다.
2. 출력은 \( c[n][n] \), 즉 최적 경로의 점수를 반환해야 합니다.

##### **참고: 점화식**
1. 초기 조건:
    - \( c[i][0] = 0 \) (행 초기화)
    - \( c[0][j] = 0 \) (열 초기화)
2. 점화식:
   \[
   c[i][j] = m[i][j] + \max(c[i-1][j], c[i][j-1])
   \]
3. 최종 반환값:
   ```c
   return c[n][n];
   ```

---

#### **문제 2: 함수 설계**
- 함수 이름: `matrixPath`
- 입력:
    - 행렬 \( m[n][n] \)
    - 행렬 크기 \( n \)
- 출력:
    - 최적 경로의 점수 \( c[n][n] \)

---

#### **문제 3: 코드의 빈칸 채우기**
아래 코드의 빈칸을 채우세요:

```c
#include <stdio.h>
#define MAX 100

int matrixPath(int m[MAX][MAX], int n) {
    int c[MAX][MAX] = {0};

    // 초기화
    for (int i = 0; i <= n; i++) c[i][0] = 0;  // (1) ______
    for (int j = 0; j <= n; j++) c[0][j] = 0;  // (2) ______

    // 점화식 계산
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            c[i][j] = m[i][j] + ______;  // (3) max(c[i-1][j], c[i][j-1])
        }
    }

    // 최종 결과 반환
    return ______;  // (4) c[n][n]
}

int main() {
    int n = 3;
    int m[MAX][MAX] = {
        {0, 0, 0, 0},  // 더미 행
        {0, 6, 7, 12}, // 입력 데이터 (1행)
        {0, 5, 3, 11}, // 입력 데이터 (2행)
        {0, 7, 17, 3}  // 입력 데이터 (3행)
    };

    printf("최적 경로 점수: %d\n", matrixPath(m, n));
    return 0;
}
```

---

### **정답**
#### **문제 3의 빈칸 채우기**
1. (1) \( c[i][0] = 0 \)
2. (2) \( c[0][j] = 0 \)
3. (3) \( \max(c[i-1][j], c[i][j-1]) \)
4. (4) \( c[n][n] \)

위의 코드가 동작하도록 빈칸을 채우고 실행해보세요. 필요시 추가적인 테스트 데이터를 제공할 수 있습니다!