### **암기 및 연습을 위한 문제와 빈칸 문제**

#### **문제 1: 빈칸 채우기**
1. \( peb(p, i) \)의 점화식을 완성하세요:
   \[
   peb(p, i) = \max_{q} (\_\_\_\_ + \_\_\_\_)
   \]
    - \( q \)는 현재 패턴 \( p \)와 양립 가능한 이전 열의 패턴입니다.
    - \( w(p, i) \): \( i \)열에서 패턴 \( p \)에 해당하는 점수입니다.

2. \( peb(n) \)의 최종 값을 반환하는 코드를 완성하세요:
   ```c
   return \_\_\_\_\_;
   ```

3. 초기 조건은 다음과 같습니다. 빈칸을 채우세요:
    - \( peb(p, 1) = \_\_\_\_\_; \)

---

#### **문제 2: 새로운 입력 테이블 주어질 때 \( W \) 테이블과 \( peb \) 테이블 구하기**

##### **입력 테이블 (Input Table):**
| 열 | 1  | 2  | 3  | 4  |
|----|----|----|----|----|
| 행 1 | 8  | 5  | 6  | -4 |
| 행 2 | -7 | 9  | 4  | 8  |
| 행 3 | 10 | 3  | 5  | 7  |

##### **문제**
1. \( W \) 테이블을 계산하세요:
    - 패턴 1, 2, 3, 4에 따라 값을 채우세요.
2. \( peb \) 테이블의 값을 계산하세요:
    - 각 열에서 \( peb(p, i) \) 값을 채우고, 마지막 열에서 최대값을 구하세요.

---

#### **문제 3: 패턴 양립 관계**
아래 패턴 \( p \)와 \( q \) 간의 양립 관계를 완성하세요.
1. \( p = 1 \): \( q = \_\_\_\_\_, \_\_\_\_\_ \)
2. \( p = 2 \): \( q = \_\_\_\_\_, \_\_\_\_\_ \)
3. \( p = 3 \): \( q = \_\_\_\_\_, \_\_\_\_\_, \_\_\_\_\_ \)
4. \( p = 4 \): \( q = \_\_\_\_\_ \)

---

#### **문제 4: 복습용 점화식 응용 문제**
\( n = 4 \), 아래 입력 테이블에 대해 \( peb(p, i) \)의 값을 구하세요.
| 열 | 1  | 2  | 3  | 4  |
|----|----|----|----|----|
| 행 1 | 6  | 5  | 8  | -1 |
| 행 2 | 9  | 7  | -2 | 3  |
| 행 3 | 4  | -6 | 3  | 5  |

##### 요구 사항
1. **\( W \) 테이블 계산하기**:
    - \( W[i][p] \): 패턴 1, 2, 3, 4를 기반으로 점수를 계산.
2. **\( peb \) 테이블 채우기**:
    - DP를 사용하여 \( peb(p, i) \) 값을 채우고 마지막 열에서 최댓값을 구하세요.

---

#### **정답 확인용**
이 문제들은 주어진 알고리즘과 점화식을 연습할 수 있도록 구성되었습니다. 결과 확인이 필요하거나 답안을 작성하시면 피드백을 드릴 수 있습니다!




### **문제 1: 빈칸 채우기**

1. \( peb(p, i) \)의 점화식:
   \[
   peb(p, i) = \max_{q} (peb(q, i-1) + w(p, i))
   \]

2. 최종 반환값:
   ```c
   return max(peb[1][n], peb[2][n], peb[3][n], peb[4][n]);
   ```

3. 초기 조건:
    - \( peb(p, 1) = w[p][1]; \)

---

### **문제 2: 새로운 입력 테이블 \( W \)와 \( peb \) 테이블 계산**

#### **입력 테이블**
| 열 | 1  | 2  | 3  | 4  |
|----|----|----|----|----|
| 행 1 | 8  | 5  | 6  | -4 |
| 행 2 | -7 | 9  | 4  | 8  |
| 행 3 | 10 | 3  | 5  | 7  |

#### **답변**

##### **1. \( W \) 테이블 계산**
| 열 | 패턴 1 | 패턴 2 | 패턴 3 | 패턴 4 |
|----|--------|--------|--------|--------|
| 1  |   8    |  -7    |   10   |   18   |
| 2  |   5    |   9    |    3   |    8   |
| 3  |   6    |   4    |    5   |   11   |
| 4  |  -4    |   8    |    7   |    3   |

##### **2. \( peb \) 테이블 계산**
- 초기화 (\( peb(p, 1) = w[p][1] \)):

| 열 | 패턴 1 | 패턴 2 | 패턴 3 | 패턴 4 |
|----|--------|--------|--------|--------|
| 1  |   8    |  -7    |   10   |   18   |

- 점화식 계산 (\( i = 2, 3, 4 \)):

| 열 | 패턴 1 | 패턴 2 | 패턴 3 | 패턴 4 |
|----|--------|--------|--------|--------|
| 2  |   23   |   19   |   21   |   18   |
| 3  |   27   |   25   |   26   |   34   |
| 4  |   30   |   36   |   41   |   39   |

최종 답: \( \max(30, 36, 41, 39) = 41 \).

---

### **문제 3: 패턴 양립 관계**
1. \( p = 1 \): \( q = 2, 3 \)
2. \( p = 2 \): \( q = 1, 3 \)
3. \( p = 3 \): \( q = 1, 2, 4 \)
4. \( p = 4 \): \( q = 2, 3 \)

---

### **문제 4: 복습용 점화식 응용**

#### 입력 테이블
| 열 | 1  | 2  | 3  | 4  |
|----|----|----|----|----|
| 행 1 | 6  | 5  | 8  | -1 |
| 행 2 | 9  | 7  | -2 | 3  |
| 행 3 | 4  | -6 | 3  | 5  |

#### **답변**

##### \( W \) 테이블 계산
| 열 | 패턴 1 | 패턴 2 | 패턴 3 | 패턴 4 |
|----|--------|--------|--------|--------|
| 1  |   6    |   9    |    4   |   10   |
| 2  |   5    |   7    |   -6   |   -1   |
| 3  |   8    |  -2    |    3   |   11   |
| 4  |  -1    |   3    |    5   |    4   |

##### \( peb \) 테이블 계산
| 열 | 패턴 1 | 패턴 2 | 패턴 3 | 패턴 4 |
|----|--------|--------|--------|--------|
| 1  |   6    |   9    |    4   |   10   |
| 2  |   16   |   16   |   3    |   8    |
| 3  |   24   |   21   |   19   |   27   |
| 4  |   26   |   30   |   32   |   31   |

최종 답: \( \max(26, 30, 32, 31) = 32 \).

---

### **문제 정리**
1. 빈칸 문제는 알고리즘의 주요 점화식과 초기화를 암기하는 데 유용.
2. 새로운 입력 테이블 문제는 알고리즘을 실제로 적용해보는 연습.
3. 복습 문제는 \( W \) 테이블과 \( peb \) 테이블 계산을 반복하며 전체 흐름을 숙지할 수 있도록 구성.

필요시 추가 문제와 설명을 제공할 수 있습니다!



### **돌 놓기 문제: 코드 작성 문제**

#### **문제 1: 코드 작성**
다음 점화식을 기반으로 돌 놓기 문제를 해결하는 코드를 작성하세요.

##### **조건**
1. 입력은 \( n \times 4 \) 크기의 점수 테이블 \( w \)입니다.
2. 출력은 \( peb[n][p] \)의 최대값, 즉 최적 점수를 반환해야 합니다.
3. \( peb[i][p] \)는 \( i \)열에서 패턴 \( p \)로 돌을 놓았을 때의 최적 점수입니다.

##### **참고: 점화식**
1. 초기화:
   \[
   peb[1][p] = w[1][p] \quad (p = 1, 2, 3, 4)
   \]
2. 점화식:
   \[
   peb[i][p] = \max_{q} (peb[i-1][q] + w[i][p])
   \]
   단, \( q \)는 \( p \)와 양립 가능한 패턴.

3. 최종 반환값:
   \[
   return \max_{p=1,2,3,4}(peb[n][p])
   \]

---

#### **문제 2: 함수 설계**
- 함수 이름: `pebble`
- 입력:
    - 점수 테이블 \( w[n][4] \)
    - 열 개수 \( n \)
- 출력:
    - 최적 점수 \( \max(peb[n][1], \dots, peb[n][4]) \)

---

#### **문제 3: 코드의 빈칸 채우기**
아래 코드를 완성하세요.

```c
#include <stdio.h>
#define MAX 100

// 양립 가능한 패턴을 확인하는 함수
int compatible(int p, int q) {
    // p와 q의 양립 관계를 정의 (예: 1은 2, 3과 양립 가능)
    int compatibility[5][5] = {
        {0, 0, 0, 0, 0},
        {0, 0, 1, 1, 0},  // 패턴 1
        {0, 1, 0, 1, 1},  // 패턴 2
        {0, 1, 1, 0, 1},  // 패턴 3
        {0, 0, 1, 1, 0}   // 패턴 4
    };
    return compatibility[p][q];
}

int pebble(int w[MAX][5], int n) {
    int peb[MAX][5] = {0};

    // 초기화
    for (int p = 1; p <= 4; p++) {
        peb[1][p] = w[1][p];  // (1) ______
    }

    // 점화식 계산
    for (int i = 2; i <= n; i++) {
        for (int p = 1; p <= 4; p++) {
            int max_value = 0;
            for (int q = 1; q <= 4; q++) {
                if (compatible(p, q)) {
                    int value = peb[i - 1][q] + w[i][p];
                    if (value > max_value) {
                        max_value = value;  // (2) ______
                    }
                }
            }
            peb[i][p] = max_value;  // (3) ______
        }
    }

    // 최종 결과 반환
    int result = 0;
    for (int p = 1; p <= 4; p++) {
        if (peb[n][p] > result) {
            result = peb[n][p];  // (4) ______
        }
    }
    return result;
}

int main() {
    int n = 4;
    int w[MAX][5] = {
        {0, 0, 0, 0, 0},  // 더미 행
        {0, 6, -8, 11, 17}, // 1열 점수
        {0, 7, 10, 12, 19}, // 2열 점수
        {0, 12, 14, 7, 19}, // 3열 점수
        {0, -5, 9, 4, -1}   // 4열 점수
    };

    printf("최적 점수: %d\n", pebble(w, n));
    return 0;
}
```

---

### **정답**
#### **문제 3의 빈칸 채우기**
1. (1): \( peb[1][p] = w[1][p]; \)
2. (2): \( max_value = value; \)
3. (3): \( peb[i][p] = max_value; \)
4. (4): \( result = peb[n][p]; \)

이 코드를 실행하여 최적 점수를 계산하세요! 추가적인 질문이 있으면 알려주세요.