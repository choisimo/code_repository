### 행렬 곱셈 순서 문제 (DP) 빈칸 문제

다음은 행렬 곱셈 순서를 최적화하는 동적 프로그래밍 문제에 대한 코드입니다. 빈칸(______)을 채워 코드를 완성하세요.

---

```c
matrixChain(n) {
    // 1단계: 대각선 초기화
    for (i = 1 to n) {
        m[i][i] = ________;
    }

    // 2단계: 문제 크기 r에 따라 계산
    for (r = 1 to n-1) { // r은 문제 크기 - 1
        for (i = 1 to n-r) {
            j = i + r; // 끝 열 계산
            m[i][j] = ________;
            for (k = i to j-1) {
                m[i][j] = min(m[i][j], ________ + ________ + p[i-1] * p[k] * p[j]);
            }
        }
    }

    // 3단계: 최적 비용 반환
    return ________;
}
```

---

### 문제 조건
1. `p[i]`는 행렬의 차원을 나타냅니다.
2. `m[i][j]`는 행렬 `A[i]`에서 `A[j]`까지 곱하는 최소 비용을 의미합니다.

---

### 풀이 힌트
- 대각선 요소(`m[i][i]`)는 항상 0입니다(행렬 하나의 곱셈 비용은 없음).
- `m[i][j]`를 계산하기 위해 가능한 모든 `k`를 확인하고 최소값을 저장합니다.
- `p[i-1] * p[k] * p[j]`는 `k`에서 분할한 행렬 곱셈의 비용을 계산합니다.

---

### 정답 (빈칸 해답)
1. `0` (한 행렬의 곱셈 비용은 0)
2. `INT_MAX` (초기 큰 값)
3. `m[i][k] + m[k+1][j]`
4. `p[i-1] * p[k] * p[j]`
5. `m[1][n]` (1부터 n까지의 최소 곱셈 비용)

---

### 행렬 곱셈 순서 (DP) 문제

빈칸을 채우는 문제와 함께 답안을 제공합니다.

---

#### 빈칸 문제
다음은 행렬 곱셈 순서를 최적화하는 코드입니다. 빈칸(______)에 들어갈 내용을 작성하세요.

```c
matrixChain(n) {
    // 1단계: 대각선 초기화
    for (i = 1 to n) {
        m[i][i] = ________;
    }

    // 2단계: 문제 크기 r에 따라 계산
    for (r = 1 to n-1) { // r은 문제 크기 - 1
        for (i = 1 to n-r) {
            j = i + r; // 끝 열 계산
            m[i][j] = ________;
            for (k = i to j-1) {
                m[i][j] = min(m[i][j], ________ + ________ + ________);
            }
        }
    }

    // 3단계: 최적 비용 반환
    return ________;
}
```

---

#### 답안
```c
matrixChain(n) {
    // 1단계: 대각선 초기화
    for (i = 1 to n) {
        m[i][i] = 0; // 대각선은 0으로 초기화
    }

    // 2단계: 문제 크기 r에 따라 계산
    for (r = 1 to n-1) { // r은 문제 크기 - 1
        for (i = 1 to n-r) {
            j = i + r; // 끝 열 계산
            m[i][j] = INT_MAX; // 최소값을 구하기 위해 큰 값으로 초기화
            for (k = i to j-1) {
                m[i][j] = min(m[i][j], m[i][k] + m[k+1][j] + p[i-1] * p[k] * p[j]);
            }
        }
    }

    // 3단계: 최적 비용 반환
    return m[1][n]; // 1부터 n까지의 최소 곱셈 비용 반환
}
```

---

#### 설명
1. `m[i][i] = 0`:
    - 단일 행렬은 곱셈 비용이 없기 때문에 대각선 값을 0으로 초기화합니다.

2. `m[i][j] = INT_MAX`:
    - 최소 비용을 계산하기 위해 초기 값을 충분히 크게 설정합니다.

3. `m[i][j] = min(...)`:
    - 가능한 모든 분할 지점 `k`를 확인하며 최적 비용을 계산합니다.

4. `p[i-1] * p[k] * p[j]`:
    - `i~k`, `k+1~j`를 분할하고 두 행렬 곱셈의 비용을 계산합니다.

5. 최종 반환 값 `m[1][n]`:
    - 1번 행렬부터 n번 행렬까지의 최소 비용을 반환합니다.

---

이 코드를 반복적으로 작성하고 실행하며 익히세요. 문제를 통해 연습해 보세요! 😊