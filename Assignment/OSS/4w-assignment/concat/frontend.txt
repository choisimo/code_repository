// 파일: frontend/.eslintrc.js
module.exports = {
  root: true,
  env: {
    node: true
  },
  extends: [
    'plugin:vue/vue3-essential',
    'eslint:recommended'
  ],
  parserOptions: {
    ecmaVersion: 2020
  },
  rules: {}
}


// ===================================

// 파일: frontend/postcss.config.js
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {}
  }
}


// ===================================

// 파일: frontend/src/App.vue
<template>
  <div class="app-container">
    <header class="bg-gradient-to-r from-blue-500 to-indigo-600 text-white p-4 shadow-lg">
      <div class="container mx-auto flex justify-between items-center">
        <h1 class="text-2xl font-bold">Nodove 날씨</h1>
        <nav>
          <router-link to="/" class="px-4 py-2 mr-2 hover:bg-blue-600 rounded-md transition-colors">홈</router-link>
          <router-link to="/map" class="px-4 py-2 hover:bg-blue-600 rounded-md transition-colors">지도</router-link>
        </nav>
      </div>
    </header>
    
    <main class="container mx-auto p-4 min-h-screen">
      <router-view />
    </main>
    
    <footer class="bg-gray-800 text-white p-4 mt-8">
      <div class="container mx-auto text-center">
        <p>© 2023 Nodove 날씨 애플리케이션</p>
      </div>
    </footer>
  </div>
</template>

<script>
export default {
  name: 'App'
}
</script>

<style lang="scss">
.app-container {
  display: flex;
  flex-direction: column;
  min-height: 100vh;
}

main {
  flex: 1;
}
</style>


// ===================================

// 파일: frontend/src/components/ErrorAlert.vue
<template>
    <div v-if="show" class="error-alert" :class="{ 'error-alert-show': show }">
      <div class="error-content">
        <div class="error-icon">⚠️</div>
        <div class="error-message">{{ message }}</div>
      </div>
      <button class="close-button" @click="close">×</button>
    </div>
  </template>
  
  <script>
  import { ref, watch } from 'vue';
  
  export default {
    name: 'ErrorAlert',
    props: {
      message: {
        type: String,
        required: true
      },
      duration: {
        type: Number,
        default: 5000 // 5초 후 자동으로 닫힘
      },
      show: {
        type: Boolean,
        default: false
      }
    },
    emits: ['close'],
    setup(props, { emit }) {
      const timer = ref(null);
      
      const close = () => {
        emit('close');
      };
      
      watch(() => props.show, (newValue) => {
        if (newValue) {
          // 이전 타이머가 있으면 제거
          if (timer.value) {
            clearTimeout(timer.value);
          }
          
          // 새 타이머 설정
          timer.value = setTimeout(() => {
            close();
          }, props.duration);
        }
      });
      
      return {
        close
      };
    }
  };
  </script>
  
  <style scoped>
  .error-alert {
    position: fixed;
    top: 20px;
    right: 20px;
    background-color: #f8d7da;
    color: #721c24;
    border: 1px solid #f5c6cb;
    border-radius: 4px;
    padding: 12px 16px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    z-index: 1000;
    max-width: 400px;
    transform: translateX(120%);
    transition: transform 0.3s ease-in-out;
  }
  
  .error-alert-show {
    transform: translateX(0);
  }
  
  .error-content {
    display: flex;
    align-items: center;
  }
  
  .error-icon {
    margin-right: 12px;
    font-size: 20px;
  }
  
  .error-message {
    font-size: 14px;
  }
  
  .close-button {
    background: none;
    border: none;
    font-size: 20px;
    cursor: pointer;
    margin-left: 16px;
    color: #721c24;
  }
  </style>


// ===================================

// 파일: frontend/src/components/WeatherForecast.vue
<template>
  <div class="weather-forecast">
    <div v-if="isLoading" class="loading-container">
      <div class="spinner"></div>
      <p>날씨 정보를 불러오는 중...</p>
    </div>
    
    <div v-else-if="error" class="error-container">
      <p class="error-message">{{ error }}</p>
      <button class="retry-button" @click="refreshData">다시 시도</button>
    </div>
    
    <div v-else-if="forecast.length" class="forecast-container">
      <h3 class="forecast-title">
        {{ selectedLocation.address }} 일기 예보
      </h3>
      
      <div class="forecast-cards">
        <div 
          v-for="(item, index) in forecast" 
          :key="index" 
          class="forecast-card"
          :class="{ 'current-day': index === 0 }"
        >
          <div class="forecast-day">{{ formatDay(item.date) }}</div>
          <div class="forecast-icon">
            <img :src="getWeatherIconUrl(item.skyCode)" :alt="item.skyText" />
          </div>
          <div class="forecast-temp">
            <span class="high">{{ item.temperatureMax }}°</span>
            <span class="low">{{ item.temperatureMin }}°</span>
          </div>
          <div class="forecast-desc">{{ item.skyText }}</div>
          <div v-if="item.precipitation > 0" class="forecast-rain">
            <span class="rain-icon">💧</span>
            <span class="rain-percent">{{ item.precipitation }}%</span>
          </div>
        </div>
      </div>
      
      <!-- 상세 날씨 정보 -->
      <div class="weather-details" v-if="currentWeather">
        <div class="detail-row">
          <div class="detail-item">
            <div class="detail-label">습도</div>
            <div class="detail-value">{{ currentWeather.humidity || 0 }}%</div>
          </div>
          <div class="detail-item">
            <div class="detail-label">기압</div>
            <div class="detail-value">{{ currentWeather.pressure || 0 }} hPa</div>
          </div>
        </div>
        <div class="detail-row">
          <div class="detail-item">
            <div class="detail-label">풍속</div>
            <div class="detail-value">{{ currentWeather.windSpeed || 0 }} m/s</div>
          </div>
          <div class="detail-item">
            <div class="detail-label">체감온도</div>
            <div class="detail-value">{{ currentWeather.temperatureFeelsLike || 0 }}°C</div>
          </div>
        </div>
      </div>
    </div>
    
    <div v-else class="empty-state">
      <p>날씨 정보가 없습니다.</p>
      <p>지도에서 위치를 선택하거나 주소를 검색해주세요.</p>
    </div>
  </div>
</template>

<script>
import { computed, onMounted } from 'vue';
import { useWeatherStore } from '@/stores/weather';

export default {
  name: 'WeatherForecast',
  
  props: {
    // 날씨 예보를 표시할 위치 (선택적)
    location: {
      type: Object,
      default: null
    }
  },
  
  setup(props) {
    const weatherStore = useWeatherStore();
    
    // 날씨 정보와 상태 가져오기
    const forecast = computed(() => weatherStore.forecast || []);
    const currentWeather = computed(() => weatherStore.currentWeather);
    const isLoading = computed(() => weatherStore.loading);
    const error = computed(() => weatherStore.error);
    const selectedLocation = computed(() => weatherStore.selectedLocation);
    
    // 현재 위치에 대한 날씨 데이터 가져오기
    const fetchData = async () => {
      // props.location이 있으면 해당 위치로, 없으면 선택된 위치 사용
      if (props.location) {
        await weatherStore.setLocation(
          props.location.lat, 
          props.location.lng, 
          props.location.address
        );
      } else {
        await weatherStore.fetchCurrentWeather();
        await weatherStore.fetchForecast();
      }
    };
    
    // 날씨 데이터 새로고침
    const refreshData = async () => {
      await weatherStore.refreshAll();
    };
    
    // 날짜 포맷팅 (요일 표시)
    const formatDay = (dateString) => {
      if (!dateString) return '';
      
      const days = ['일', '월', '화', '수', '목', '금', '토'];
      const date = new Date(dateString);
      
      // 오늘인지 확인
      const today = new Date();
      if (date.setHours(0, 0, 0, 0) === today.setHours(0, 0, 0, 0)) {
        return '오늘';
      }
      
      return days[date.getDay()] + '요일';
    };
    
    // 날씨 상태에 따른 아이콘 URL 반환
    const getWeatherIconUrl = (skyCode) => {
      if (!skyCode) return '/icons/weather/unknown.svg';
      
      // 날씨 코드에 따른 아이콘 매핑
      const iconMap = {
        'CLEAR': 'clear-day',
        'PARTLY_CLOUDY': 'partly-cloudy-day',
        'MOSTLY_CLOUDY': 'cloudy',
        'CLOUDY': 'cloudy',
        'RAIN': 'rain',
        'SNOW': 'snow',
        'SLEET': 'sleet',
        'THUNDERSTORM': 'thunderstorm'
      };
      
      const iconName = iconMap[skyCode] || 'unknown';
      return `/icons/weather/${iconName}.svg`;
    };
    
    // 컴포넌트 마운트 시 데이터 로드
    onMounted(() => {
      fetchData();
    });
    
    return {
      forecast,
      currentWeather,
      isLoading,
      error,
      selectedLocation,
      refreshData,
      formatDay,
      getWeatherIconUrl
    };
  }
};
</script>

<style lang="scss" scoped>
.weather-forecast {
  width: 100%;
  padding: 1rem;
  border-radius: 12px;
  background: rgba(255, 255, 255, 0.8);
  backdrop-filter: blur(10px);
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
  margin-bottom: 1.5rem;
  
  .loading-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 2rem;
    
    .spinner {
      width: 30px;
      height: 30px;
      border: 3px solid rgba(0, 0, 0, 0.1);
      border-top-color: #3498db;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 1rem;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  }
  
  .error-container {
    text-align: center;
    padding: 1.5rem;
    
    .error-message {
      color: #e74c3c;
      margin-bottom: 1rem;
    }
    
    .retry-button {
      padding: 0.5rem 1rem;
      background: #3498db;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.2s;
      
      &:hover {
        background: #2980b9;
      }
    }
  }
  
  .forecast-container {
    .forecast-title {
      font-size: 1.2rem;
      font-weight: 600;
      margin-bottom: 1rem;
      color: #2c3e50;
      text-align: center;
    }
    
    .forecast-cards {
      display: flex;
      overflow-x: auto;
      gap: 10px;
      padding: 0.5rem 0;
      
      &::-webkit-scrollbar {
        height: 4px;
      }
      
      &::-webkit-scrollbar-track {
        background: rgba(0, 0, 0, 0.05);
        border-radius: 10px;
      }
      
      &::-webkit-scrollbar-thumb {
        background: rgba(0, 0, 0, 0.2);
        border-radius: 10px;
      }
    }
    
    .forecast-card {
      flex: 0 0 auto;
      width: 90px;
      padding: 0.8rem;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.7);
      text-align: center;
      transition: transform 0.2s, box-shadow 0.2s;
      
      &:hover {
        transform: translateY(-3px);
        box-shadow: 0 5px 10px rgba(0, 0, 0, 0.1);
      }
      
      &.current-day {
        background: rgba(52, 152, 219, 0.1);
        border: 1px solid rgba(52, 152, 219, 0.3);
      }
      
      .forecast-day {
        font-size: 0.8rem;
        font-weight: 600;
        margin-bottom: 0.5rem;
        color: #34495e;
      }
      
      .forecast-icon {
        margin: 0.5rem 0;
        
        img {
          width: 40px;
          height: 40px;
        }
      }
      
      .forecast-temp {
        margin: 0.5rem 0;
        
        .high {
          font-weight: 600;
          color: #e74c3c;
          margin-right: 0.5rem;
        }
        
        .low {
          color: #3498db;
        }
      }
      
      .forecast-desc {
        font-size: 0.75rem;
        color: #7f8c8d;
        margin-bottom: 0.5rem;
      }
      
      .forecast-rain {
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.75rem;
        color: #3498db;
        
        .rain-icon {
          margin-right: 0.2rem;
        }
      }
    }
  }
  
  .weather-details {
    margin-top: 1.5rem;
    padding-top: 1rem;
    border-top: 1px solid rgba(0, 0, 0, 0.1);
    
    .detail-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 0.8rem;
    }
    
    .detail-item {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      
      .detail-label {
        font-size: 0.8rem;
        color: #7f8c8d;
        margin-bottom: 0.2rem;
      }
      
      .detail-value {
        font-size: 1rem;
        font-weight: 600;
        color: #2c3e50;
      }
    }
  }
  
  .empty-state {
    text-align: center;
    padding: 2rem;
    color: #7f8c8d;
  }
}

@media (max-width: 768px) {
  .weather-forecast {
    padding: 0.8rem;
    
    .forecast-container {
      .forecast-cards {
        .forecast-card {
          width: 80px;
          padding: 0.6rem;
        }
      }
    }
  }
}
</style>


// ===================================

// 파일: frontend/src/components/WeatherMap.vue
<template>
  <div class="weather-map-container">
    <div v-if="loading" class="loading-overlay">
      <div class="loading-spinner"></div>
      <p>날씨 데이터 로딩 중...</p>
    </div>
    <div v-if="error" class="error-message">
      <p>{{ error }}</p>
      <button @click="fetchWeatherData" class="retry-button">다시 시도</button>
    </div>
    <div id="weather-map" ref="mapContainer" class="map-container"></div>
    <div class="map-controls">
      <button @click="zoomIn" class="map-control-button">+</button>
      <button @click="zoomOut" class="map-control-button">-</button>
      <button @click="resetLocation" class="map-control-button">
        <span class="reset-icon">⟳</span>
      </button>
    </div>
    <div v-if="selectedLocation" class="location-info">
      <h3>{{ selectedLocation.name }}</h3>
      <div class="weather-details">
        <div class="weather-icon">
          <img :src="getWeatherIconUrl(selectedLocation.weather.icon)" :alt="selectedLocation.weather.description" />
        </div>
        <div class="weather-data">
          <p class="temperature">{{ Math.round(selectedLocation.weather.temp) }}°C</p>
          <p class="description">{{ selectedLocation.weather.description }}</p>
          <p class="humidity">습도: {{ selectedLocation.weather.humidity }}%</p>
          <p class="wind">풍속: {{ selectedLocation.weather.windSpeed }} m/s</p>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import { ref, onMounted, onUnmounted } from 'vue';
import axios from 'axios';

export default {
  name: 'WeatherMap',
  props: {
    initialLat: {
      type: Number,
      default: 37.5665 // 서울의 위도
    },
    initialLng: {
      type: Number,
      default: 126.9780 // 서울의 경도
    },
    zoom: {
      type: Number,
      default: 10
    },
    naverMapsClientId: {
      type: String,
      required: true
    }
  },
  setup(props) {
    const mapContainer = ref(null);
    const map = ref(null);
    const markers = ref([]);
    const loading = ref(true);
    const error = ref(null);
    const selectedLocation = ref(null);
    const weatherData = ref([]);

    // 날씨 데이터 가져오기
    const fetchWeatherData = async () => {
      if (!map.value) return;
      
      loading.value = true;
      error.value = null;
      
      try {
        // API 호출
        const response = await axios.get('/api/weather/regions');
        
        weatherData.value = response.data;
        clearMarkers();
        addWeatherMarkers();
      } catch (err) {
        console.error('날씨 데이터를 가져오는 중 오류가 발생했습니다:', err);
        error.value = '날씨 데이터를 가져오는 중 오류가 발생했습니다. 다시 시도해 주세요.';
      } finally {
        loading.value = false;
      }
    };

    // 지도 초기화
    const initMap = () => {
      if (!window.naver || !window.naver.maps) {
        error.value = "네이버 지도 API가 로드되지 않았습니다.";
        loading.value = false;
        return;
      }

      map.value = new window.naver.maps.Map(mapContainer.value, {
        center: new window.naver.maps.LatLng(props.initialLat, props.initialLng),
        zoom: props.zoom,
        zoomControl: false,
        mapTypeControl: false
      });

      // 지도 로딩 완료 이벤트 - 네이버 지도는 'init' 이벤트 사용
      window.naver.maps.Event.addListener(map.value, 'init', () => {
        fetchWeatherData();
      });

      // 지도 클릭 이벤트
      window.naver.maps.Event.addListener(map.value, 'click', () => {
        selectedLocation.value = null;
      });
    };

    // 마커 초기화
    const clearMarkers = () => {
      markers.value.forEach(marker => marker.setMap(null));
      markers.value = [];
    };

    // 날씨 마커 추가
    const addWeatherMarkers = () => {
      if (!weatherData.value || !Array.isArray(weatherData.value)) return;
      
      weatherData.value.forEach(location => {
        const marker = new window.naver.maps.Marker({
          position: new window.naver.maps.LatLng(location.lat, location.lng),
          map: map.value,
          title: location.name,
          icon: {
            url: getWeatherIconUrl(location.weather.icon),
            size: new window.naver.maps.Size(50, 50),
            scaledSize: new window.naver.maps.Size(50, 50)
          }
        });

        window.naver.maps.Event.addListener(marker, 'click', () => {
          selectedLocation.value = location;
        });

        markers.value.push(marker);
      });
    };

    // 날씨 아이콘 URL 가져오기
    const getWeatherIconUrl = (iconCode) => {
      return `https://openweathermap.org/img/wn/${iconCode}@2x.png`;
    };

    // 확대
    const zoomIn = () => {
      if (map.value) {
        map.value.setZoom(map.value.getZoom() + 1);
      }
    };

    // 축소
    const zoomOut = () => {
      if (map.value) {
        map.value.setZoom(map.value.getZoom() - 1);
      }
    };

    // 위치 재설정
    const resetLocation = () => {
      if (map.value) {
        map.value.setCenter(new window.naver.maps.LatLng(props.initialLat, props.initialLng));
        map.value.setZoom(props.zoom);
      }
    };

    // 컴포넌트 마운트 시 네이버 지도 API 로드
    onMounted(() => {
      if (window.naver && window.naver.maps) {
        initMap();
      } else {
        const script = document.createElement('script');
        script.src = `https://openapi.map.naver.com/openapi/v3/maps.js?ncpClientId=${props.naverMapsClientId}&submodules=geocoder`;
        script.async = true;
        script.defer = true;
        
        script.onload = () => {
          initMap();
        };
        
        script.onerror = () => {
          error.value = "네이버 지도 API 로드에 실패했습니다.";
          loading.value = false;
        };
        
        document.head.appendChild(script);
      }
    });

    // 컴포넌트 언마운트 시 정리
    onUnmounted(() => {
      if (window.naver && window.naver.maps) {
        clearMarkers();
      }
    });

    return {
      mapContainer,
      loading,
      error,
      selectedLocation,
      fetchWeatherData,
      getWeatherIconUrl,
      zoomIn,
      zoomOut,
      resetLocation
    };
  }
};
</script>

<style scoped>
.weather-map-container {
  position: relative;
  width: 100%;
  height: 500px;
  border-radius: 8px;
  overflow: hidden;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.map-container {
  width: 100%;
  height: 100%;
}

.loading-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(255, 255, 255, 0.8);
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 10;
}

.loading-spinner {
  width: 50px;
  height: 50px;
  border: 5px solid #f3f3f3;
  border-top: 5px solid #3498db;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin-bottom: 10px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.error-message {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: white;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  text-align: center;
  z-index: 10;
}

.retry-button {
  background-color: #3498db;
  color: white;
  border: none;
  padding: 8px 16px;
  border-radius: 4px;
  cursor: pointer;
  margin-top: 10px;
}

.retry-button:hover {
  background-color: #2980b9;
}

.map-controls {
  position: absolute;
  top: 10px;
  right: 10px;
  display: flex;
  flex-direction: column;
  gap: 5px;
  z-index: 5;
}

.map-control-button {
  width: 36px;
  height: 36px;
  background-color: white;
  border: 1px solid #ccc;
  border-radius: 4px;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 18px;
  cursor: pointer;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.map-control-button:hover {
  background-color: #f5f5f5;
}

.reset-icon {
  font-size: 16px;
}

.location-info {
  position: absolute;
  bottom: 20px;
  left: 20px;
  background-color: white;
  border-radius: 8px;
  padding: 15px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  max-width: 280px;
  z-index: 5;
}

.location-info h3 {
  margin-top: 0;
  margin-bottom: 10px;
  font-size: 18px;
  font-weight: 600;
}

.weather-details {
  display: flex;
  align-items: center;
}

.weather-icon {
  flex-shrink: 0;
  margin-right: 10px;
}

.weather-icon img {
  width: 60px;
  height: 60px;
}

.weather-data {
  flex-grow: 1;
}

.temperature {
  font-size: 24px;
  font-weight: 700;
  margin: 0;
}

.description {
  text-transform: capitalize;
  margin: 5px 0;
}

.humidity, .wind {
  font-size: 14px;
  margin: 3px 0;
  color: #555;
}
</style>


// ===================================

// 파일: frontend/src/main.js
import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './App.vue'
import router from './router'
import './assets/styles/tailwind.css'

const app = createApp(App)
app.use(createPinia())
app.use(router)
app.mount('#app')


// ===================================

// 파일: frontend/src/router/index.js
import { createRouter, createWebHistory } from 'vue-router'
import HomeView from '../views/HomeView.vue'

const routes = [
  {
    path: '/',
    name: 'home',
    component: HomeView
  },
  {
    path: '/map',
    name: 'map',
    component: () => import(/* webpackChunkName: "map" */ '../views/MapView.vue')
  }
]

const router = createRouter({
  history: createWebHistory(process.env.BASE_URL),
  routes
})

export default router


// ===================================

// 파일: frontend/src/services/api.js
import axios from 'axios';

// 기본 API 클라이언트 인스턴스 생성
const apiClient = axios.create({
  baseURL: process.env.VUE_APP_API_BASE_URL || '/api',
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
    'Accept': 'application/json'
  }
});

// 날씨 관련 API 호출
export const weatherApi = {
  /**
   * 특정 좌표의 현재 날씨 정보를 가져옵니다.
   * @param {number} lat - 위도
   * @param {number} lng - 경도
   * @returns {Promise} 날씨 정보 객체
   */
  getCurrentWeather(lat, lng) {
    return apiClient.get('/weather', {
      params: { lat, lng }
    });
  },

  /**
   * 특정 좌표의 날씨 예보를 가져옵니다.
   * @param {number} lat - 위도
   * @param {number} lng - 경도
   * @param {number} days - 예보 일수 (기본값: 5)
   * @returns {Promise} 예보 정보 객체
   */
  getForecast(lat, lng, days = 5) {
    return apiClient.get('/forecast', {
      params: { lat, lng, days }
    });
  },

  /**
   * 주소를 좌표로 변환합니다 (지오코딩).
   * @param {string} address - 변환할 주소
   * @returns {Promise} 좌표 정보 객체
   */
  getCoordinates(address) {
    return apiClient.get('/geocode', {
      params: { address }
    });
  }
};

export default apiClient;


// ===================================

// 파일: frontend/src/stores/weather.js
import { defineStore } from 'pinia';
import { weatherApi } from '@/services/api';

export const useWeatherStore = defineStore('weather', {
  state: () => ({
    currentWeather: null,
    forecast: [],
    loading: false,
    error: null,
    selectedLocation: {
      lat: 37.5665, // 서울 기본 좌표
      lng: 126.9780,
      address: '서울특별시'
    },
    locations: [], // 최근 조회한 위치 목록
  }),

  getters: {
    // 날씨 상태에 따른 아이콘 코드 반환
    getWeatherIcon: (state) => {
      if (!state.currentWeather) return 'unknown';
      
      const weatherState = state.currentWeather.sky?.code || 'CLEAR';
      const isNight = state.currentWeather.isNight;
      
      switch (weatherState) {
        case 'CLEAR':
          return isNight ? 'clear-night' : 'clear-day';
        case 'PARTLY_CLOUDY':
          return isNight ? 'partly-cloudy-night' : 'partly-cloudy-day';
        case 'MOSTLY_CLOUDY':
        case 'CLOUDY':
          return 'cloudy';
        case 'RAIN':
          return 'rain';
        case 'SNOW':
          return 'snow';
        case 'SLEET':
          return 'sleet';
        case 'THUNDERSTORM':
          return 'thunderstorm';
        default:
          return 'unknown';
      }
    },
    
    // 온도에 따른 색상 반환
    getTemperatureColor: (state) => {
      if (!state.currentWeather) return '#888888';
      
      const temp = state.currentWeather.temperature?.current;
      if (temp === undefined) return '#888888';
      
      if (temp <= 0) return '#4287f5';  // 매우 추움 (파란색)
      if (temp <= 10) return '#42adf5'; // 추움 (하늘색)
      if (temp <= 20) return '#42f59e'; // 시원함 (연두색)
      if (temp <= 25) return '#f5d442'; // 따뜻함 (노란색)
      if (temp <= 30) return '#f59442'; // 더움 (주황색)
      return '#f54242';                // 매우 더움 (빨간색)
    }
  },

  actions: {
    /**
     * 현재 선택된 위치의 날씨 정보를 가져옵니다.
     */
    async fetchCurrentWeather() {
      if (!this.selectedLocation) return;
      
      const { lat, lng } = this.selectedLocation;
      this.loading = true;
      this.error = null;
      
      try {
        const response = await weatherApi.getCurrentWeather(lat, lng);
        this.currentWeather = response.data;
        
        // 최근 위치 목록에 추가
        this.addToRecentLocations({
          ...this.selectedLocation,
          weather: this.currentWeather
        });
      } catch (err) {
        this.error = err.message || '날씨 정보를 가져오는데 실패했습니다.';
        console.error('날씨 정보 조회 오류:', err);
      } finally {
        this.loading = false;
      }
    },
    
    /**
     * 현재 선택된 위치의 날씨 예보를 가져옵니다.
     * @param {number} days - 예보 일수
     */
    async fetchForecast(days = 5) {
      if (!this.selectedLocation) return;
      
      const { lat, lng } = this.selectedLocation;
      this.loading = true;
      this.error = null;
      
      try {
        const response = await weatherApi.getForecast(lat, lng, days);
        this.forecast = response.data.forecastList || [];
      } catch (err) {
        this.error = err.message || '날씨 예보를 가져오는데 실패했습니다.';
        console.error('날씨 예보 조회 오류:', err);
      } finally {
        this.loading = false;
      }
    },
    
    /**
     * 주소를 검색하여 좌표로 변환하고 해당 위치의 날씨를 가져옵니다.
     * @param {string} address - 검색할 주소
     */
    async searchByAddress(address) {
      if (!address) return;
      
      this.loading = true;
      this.error = null;
      
      try {
        const response = await weatherApi.getCoordinates(address);
        const { lat, lng, formattedAddress } = response.data;
        
        this.selectedLocation = {
          lat,
          lng,
          address: formattedAddress
        };
        
        // 날씨 정보 및 예보 가져오기
        await this.fetchCurrentWeather();
        await this.fetchForecast();
      } catch (err) {
        this.error = err.message || '주소 검색에 실패했습니다.';
        console.error('주소 검색 오류:', err);
      } finally {
        this.loading = false;
      }
    },
    
    /**
     * 좌표로 날씨 정보를 가져옵니다.
     * @param {number} lat - 위도
     * @param {number} lng - 경도
     * @param {string} address - 주소 (선택사항)
     */
    async setLocation(lat, lng, address = '선택한 위치') {
      this.selectedLocation = { lat, lng, address };
      await this.fetchCurrentWeather();
      await this.fetchForecast();
    },
    
    /**
     * 최근 위치 목록에 위치를 추가합니다.
     * @param {Object} location - 추가할 위치 정보
     */
    addToRecentLocations(location) {
      // 중복 위치 체크
      const exists = this.locations.some(loc => 
        loc.lat === location.lat && loc.lng === location.lng
      );
      
      if (!exists) {
        // 최대 5개까지만 저장
        if (this.locations.length >= 5) {
          this.locations.pop();
        }
        
        this.locations.unshift(location);
      }
    },
    
    /**
     * 모든 날씨 정보를 새로고침합니다.
     */
    async refreshAll() {
      await this.fetchCurrentWeather();
      await this.fetchForecast();
    }
  }
});


// ===================================

// 파일: frontend/src/views/HomeView.vue
<template>
  <div class="home">
    <div class="glass-card p-6 rounded-xl shadow-xl backdrop-blur-md bg-white/30 max-w-xl mx-auto">
      <h1 class="text-3xl font-bold mb-4 text-center text-gray-800">날씨 정보 서비스</h1>
      <p class="mb-6 text-gray-700">
        네이버 지도 API와 공공데이터 포털의 날씨 API를 활용하여 
        현재 위치 및 검색한 지역의 날씨 정보를 확인할 수 있습니다.
      </p>
      <div class="flex justify-center">
        <router-link 
          to="/map" 
          class="px-6 py-3 bg-gradient-to-r from-blue-500 to-indigo-600 text-white rounded-lg shadow-md hover:shadow-lg transition duration-300 ease-in-out transform hover:-translate-y-1">
          지도로 날씨 보기
        </router-link>
      </div>
    </div>
  </div>
</template>

<script>
export default {
  name: 'HomeView'
}
</script>

<style scoped>
.home {
  padding: 2rem;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 70vh;
}

.glass-card {
  background: rgba(255, 255, 255, 0.25);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.3);
}
</style>


// ===================================

// 파일: frontend/src/views/MapView.vue
<template>
  <div class="map-container">
    <ErrorAlert 
      :message="errorMessage" 
      :show="showError" 
      @close="showError = false" 
    />
    
    <div class="glass-card p-4 mb-4 rounded-lg">
      <h2 class="text-2xl font-bold mb-2 text-gray-800">지도 날씨</h2>
      <p class="text-gray-700 mb-4">지도에서 원하는 위치를 클릭하여 해당 지역의 날씨 정보를 확인하세요.</p>
      
      <div class="search-box mb-4">
        <input 
          type="text" 
          v-model="searchQuery" 
          @keyup.enter="searchLocation"
          placeholder="지역 검색" 
          class="w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
        />
        <button 
          @click="searchLocation" 
          class="mt-2 px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition-colors"
        >
          검색
        </button>
      </div>
    </div>
    
    <WeatherMap 
      :initialLat="initialLocation.lat" 
      :initialLng="initialLocation.lng" 
      :zoom="zoom"
      :naverMapsClientId="naverMapsClientId"
    />
    
    <WeatherForecast v-if="selectedLocation" :location="selectedLocation" class="mt-4" />
  </div>
</template>

<script>
import { ref } from 'vue';
import { useWeatherStore } from '@/stores/weather';
import WeatherMap from '@/components/WeatherMap.vue';
import WeatherForecast from '@/components/WeatherForecast.vue';
import ErrorAlert from '@/components/ErrorAlert.vue';

export default {
  name: 'MapView',
  components: {
    WeatherMap,
    WeatherForecast,
    ErrorAlert
  },
  setup() {
    const weatherStore = useWeatherStore();
    const searchQuery = ref('');
    const initialLocation = ref({
      lat: 37.5665, // 서울의 위도
      lng: 126.9780 // 서울의 경도
    });
    const zoom = ref(10);
    const naverMapsClientId = process.env.VUE_APP_NAVER_MAPS_CLIENT_ID || '';
    
    const selectedLocation = ref(weatherStore.selectedLocation);
    const errorMessage = ref('');
    const showError = ref(false);
    
    // 위치 검색
    const searchLocation = async () => {
      if (!searchQuery.value.trim()) return;
      
      try {
        await weatherStore.searchByAddress(searchQuery.value);
        
        // 검색 성공 시 초기 위치 업데이트
        if (weatherStore.selectedLocation) {
          initialLocation.value = {
            lat: weatherStore.selectedLocation.lat,
            lng: weatherStore.selectedLocation.lng
          };
          selectedLocation.value = weatherStore.selectedLocation;
          zoom.value = 13; // 검색 시 줌 레벨 조정
        }
      } catch (err) {
        console.error('위치 검색 오류:', err);
        errorMessage.value = '위치 검색 중 오류가 발생했습니다: ' + (err.message || '알 수 없는 오류');
        showError.value = true;
      }
    };
    
    return {
      searchQuery,
      initialLocation,
      zoom,
      selectedLocation,
      searchLocation,
      naverMapsClientId,
      errorMessage,
      showError
    };
  }
};
</script>

<style scoped>
.map-container {
  padding: 1rem;
}

.glass-card {
  background: rgba(255, 255, 255, 0.25);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.3);
}

.search-box {
  display: flex;
  flex-direction: column;
}

@media (min-width: 640px) {
  .search-box {
    flex-direction: row;
    gap: 8px;
  }
  
  .search-box button {
    margin-top: 0;
  }
}
</style>


// ===================================

// 파일: frontend/tailwind.config.js
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./src/**/*.{vue,js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        primary: {
          light: '#6596ff',
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./src/**/*.{vue,js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        primary: {
          light: '#6596ff',
          DEFAULT: '#4070f4',
          dark: '#2c4eaf'
        },
      },
      fontFamily: {
        sans: ['Noto Sans KR', 'Roboto', 'sans-serif'],
      },
    },
  },
  plugins: [],
}


// ===================================

// 파일: frontend/vue.config.js
const { defineConfig } = require('@vue/cli-service')

module.exports = defineConfig({
  transpileDependencies: true,
  
  // 개발 서버 설정
  devServer: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:8081',
        changeOrigin: true
      }
    }
  },
  
  // 프로덕션 빌드 설정
  outputDir: 'dist',
  assetsDir: 'assets',
  
  // CSS 설정
  css: {
    loaderOptions: {
      scss: {
        additionalData: (content, loaderContext) => {
          if (loaderContext.resourcePath.endsWith('variables.scss')) {
            return content
          }
          return `@import "@/assets/styles/variables.scss";\n${content}`
        }
      }
    }
  }
})


// ===================================

