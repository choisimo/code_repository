// 파일: backend/src/main/java/com/example/weather/client/KmaApiClient.java
    /**
     * 기상청 단기예보 조회 API를 호출하여 현재 날씨 데이터를 가져옵니다.
     *
     * @param latitude 위도
     * @param longitude 경도
     * @return 날씨 데이터
     */
    /**
     * 기상청 중기예보 조회 API를 호출하여 예보 데이터를 가져옵니다.
     *
package com.example.weather.client;

import com.example.weather.model.ForecastData;
import com.example.weather.model.WeatherData;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.util.UriComponentsBuilder;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

@Slf4j
@Component
@RequiredArgsConstructor
public class KmaApiClient {

    private final RestTemplate restTemplate;
    private final ObjectMapper objectMapper;

    @Value("${weather.api.key}")
    private String apiKey;

    @Value("${weather.api.base-url}")
    private String baseUrl;

    /**
     * 기상청 단기예보 조회 API를 호출하여 현재 날씨 데이터를 가져옵니다.
     *
     * @param latitude 위도
     * @param longitude 경도
     * @return 날씨 데이터
     */
    public WeatherData getCurrentWeather(double latitude, double longitude) {
        try {
            // 좌표를 기상청 격자 좌표로 변환
            GridCoordinate grid = convertToGridCoordinate(latitude, longitude);
            
            // 현재 시간 기준으로 API 요청 파라미터 생성
            LocalDateTime now = LocalDateTime.now();
            String baseDate = now.format(DateTimeFormatter.ofPattern("yyyyMMdd"));
            String baseTime = getBaseTime(now);
            
            // API URL 구성
            String url = UriComponentsBuilder.fromHttpUrl(baseUrl + "/getVilageFcst")
                    .queryParam("serviceKey", apiKey)
                    .queryParam("numOfRows", 100)
                    .queryParam("pageNo", 1)
                    .queryParam("dataType", "JSON")
                    .queryParam("base_date", baseDate)
                    .queryParam("base_time", baseTime)
                    .queryParam("nx", grid.getX())
                    .queryParam("ny", grid.getY())
                    .build()
                    .toUriString();
            
            // API 호출
            log.info("Requesting URL: {}", url);
            HttpHeaders headers = new HttpHeaders();
            HttpEntity<String> entity = new HttpEntity<>(headers);
            ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.GET, entity, String.class);
            log.info("API 응답: {}", response.getBody());
            
            // 응답 파싱
            JsonNode root = objectMapper.readTree(response.getBody());
            JsonNode items = root.path("response").path("body").path("items").path("item");
            
            // 날씨 데이터 생성
            return parseWeatherData(items, latitude, longitude);
        } catch (Exception e) {
            log.error("날씨 데이터 조회 중 오류 발생: {}", e.getMessage(), e);
            throw new RuntimeException("날씨 데이터를 가져오는 중 오류가 발생했습니다: " + e.getMessage(), e);
        }
    }

    /**
     * 기상청 중기예보 조회 API를 호출하여 예보 데이터를 가져옵니다.
     *
     * @param latitude 위도
     * @param longitude 경도
     * @param days 예보 일수
     * @return 예보 데이터 목록
     */
    public List<ForecastData> getForecast(double latitude, double longitude, int days) {
        try {
            // 좌표를 기상청 격자 좌표로 변환
            GridCoordinate grid = convertToGridCoordinate(latitude, longitude);
            
            // 현재 시간 기준으로 API 요청 파라미터 생성
            LocalDateTime now = LocalDateTime.now();
            String baseDate = now.format(DateTimeFormatter.ofPattern("yyyyMMdd"));
            String baseTime = getBaseTime(now);
            
            // API URL 구성
            String url = UriComponentsBuilder.fromHttpUrl(baseUrl + "/getMidLandFcst")
                    .queryParam("serviceKey", apiKey)
                    .queryParam("numOfRows", 100)
                    .queryParam("pageNo", 1)
                    .queryParam("dataType", "JSON")
                    .queryParam("regId", getRegionCode(grid))
                    .build()
                    .toUriString();
            
            // API 호출
            log.info("Requesting URL: {}", url);
            HttpHeaders headers = new HttpHeaders();
            HttpEntity<String> entity = new HttpEntity<>(headers);
            ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.GET, entity, String.class);
            log.info("API 응답: {}", response.getBody());
            
            // 응답 파싱
            JsonNode root = objectMapper.readTree(response.getBody());
            JsonNode items = root.path("response").path("body").path("items").path("item");
            
            // 예보 데이터 생성
            return parseForecastData(items, latitude, longitude, days);
        } catch (Exception e) {
            log.error("예보 데이터 조회 중 오류 발생: {}", e.getMessage(), e);
            throw new RuntimeException("예보 데이터를 가져오는 중 오류가 발생했습니다: " + e.getMessage(), e);
        }
    }

    /**
     * 위도/경도를 기상청 격자 좌표로 변환합니다.
     */
    private GridCoordinate convertToGridCoordinate(double latitude, double longitude) {
        // 기상청 격자 좌표 변환 알고리즘 (LCC 투영법)
        double RE = 6371.00877; // 지구 반경(km)
        double GRID = 5.0; // 격자 간격(km)
        double SLAT1 = 30.0; // 표준위도 1
        double SLAT2 = 60.0; // 표준위도 2
        double OLON = 126.0; // 기준점 경도
        double OLAT = 38.0; // 기준점 위도
        double XO = 43; // 기준점 X좌표
        double YO = 136; // 기준점 Y좌표
        
        double DEGRAD = Math.PI / 180.0;
        double re = RE / GRID;
        double slat1 = SLAT1 * DEGRAD;
        double slat2 = SLAT2 * DEGRAD;
        double olon = OLON * DEGRAD;
        double olat = OLAT * DEGRAD;
        
        double sn = Math.tan(Math.PI * 0.25 + slat2 * 0.5) / Math.tan(Math.PI * 0.25 + slat1 * 0.5);
        sn = Math.log(Math.cos(slat1) / Math.cos(slat2)) / Math.log(sn);
        double sf = Math.tan(Math.PI * 0.25 + slat1 * 0.5);
        sf = Math.pow(sf, sn) * Math.cos(slat1) / sn;
        double ro = Math.tan(Math.PI * 0.25 + olat * 0.5);
        ro = re * sf / Math.pow(ro, sn);
        
        double ra = Math.tan(Math.PI * 0.25 + latitude * DEGRAD * 0.5);
        ra = re * sf / Math.pow(ra, sn);
        double theta = longitude * DEGRAD - olon;
        if (theta > Math.PI) theta -= 2.0 * Math.PI;
        if (theta < -Math.PI) theta += 2.0 * Math.PI;
        theta *= sn;
        
        int nx = (int) Math.floor(ra * Math.sin(theta) + XO + 0.5);
        int ny = (int) Math.floor(ro - ra * Math.cos(theta) + YO + 0.5);
        
        return new GridCoordinate(nx, ny);
    }

    /**
     * 현재 시간에 맞는 API 요청 기준 시간을 반환합니다.
     */
    private String getBaseTime(LocalDateTime dateTime) {
        int hour = dateTime.getHour();
        int minute = dateTime.getMinute();
        
        // 기상청 API는 3시간 단위로 업데이트됨 (02:00, 05:00, 08:00, 11:00, 14:00, 17:00, 20:00, 23:00)
        if (hour < 2) return "2300";
        else if (hour < 5) return "0200";
        else if (hour < 8) return "0500";
        else if (hour < 11) return "0800";
        else if (hour < 14) return "1100";
        else if (hour < 17) return "1400";
        else if (hour < 20) return "1700";
        else if (hour < 23) return "2000";
        else return "2300";
    }

    /**
     * 격자 좌표에 해당하는 지역 코드를 반환합니다.
     */
    private String getRegionCode(GridCoordinate grid) {
        // 격자 좌표를 기반으로 지역 코드 매핑
        // 실제 구현에서는 좀 더 정확한 매핑 로직이 필요합니다
        int x = grid.getX();
        int y = grid.getY();
        
        if (x >= 55 && x <= 66 && y >= 123 && y <= 131) return "11B00000"; // 서울, 인천, 경기도
        else if (x >= 73 && x <= 106 && y >= 76 && y <= 122) return "11D10000"; // 강원도 영서
        else if (x >= 92 && x <= 106 && y >= 123 && y <= 140) return "11D20000"; // 강원도 영동
        else if (x >= 48 && x <= 70 && y >= 108 && y <= 119) return "11C20000"; // 충청북도
        else if (x >= 44 && x <= 65 && y >= 87 && y <= 107) return "11C10000"; // 충청남도
        else if (x >= 60 && x <= 89 && y >= 59 && y <= 76) return "11F20000"; // 전라북도
        else if (x >= 50 && x <= 72 && y >= 33 && y <= 58) return "11F10000"; // 전라남도
        else if (x >= 86 && x <= 103 && y >= 46 && y <= 75) return "11H10000"; // 경상북도
        else if (x >= 74 && x <= 101 && y >= 31 && y <= 45) return "11H20000"; // 경상남도
        else if (x >= 52 && x <= 56 && y >= 33 && y <= 39) return "11G00000"; // 제주도
        else return "11B00000"; // 기본값: 서울
    }

    /**
     * API 응답에서 날씨 데이터를 파싱합니다.
     */
    private WeatherData parseWeatherData(JsonNode items, double latitude, double longitude) {
        // 필요한 날씨 요소 초기화
        Double temperature = null;
        Double feelsLike = null;
        Integer humidity = null;
        Double windSpeed = null;
        Double windDirection = null;
        Integer cloudiness = null;
        Double precipitation = null;
        String weatherMain = "맑음"; // 기본값
        String weatherDescription = "맑음";
        String weatherIcon = "01d";
        Double pressure = null;
        Double visibility = null;
        
        // 위치 정보
        String locationId = "loc_" + latitude + "_" + longitude;
        String locationName = getLocationNameByCoordinates(latitude, longitude);
        
        // API 응답 파싱
        if (items.isArray()) {
            for (JsonNode item : items) {
                String category = item.path("category").asText();
                String fcstValue = item.path("fcstValue").asText();
                
                switch (category) {
                    case "T1H": // 기온
                        temperature = Double.parseDouble(fcstValue);
                        break;
                    case "REH": // 습도
                        humidity = Integer.parseInt(fcstValue);
                        break;
                    case "WSD": // 풍속
                        windSpeed = Double.parseDouble(fcstValue);
                        break;
                    case "VEC": // 풍향
                        windDirection = Double.parseDouble(fcstValue);
                        break;
                    case "SKY": // 하늘상태
                        int skyCode = Integer.parseInt(fcstValue);
                        if (skyCode == 1) {
                            weatherMain = "맑음";
                            weatherDescription = "맑음";
                            weatherIcon = "01d";
                        } else if (skyCode == 3) {
                            weatherMain = "구름많음";
                            weatherDescription = "구름많음";
                            weatherIcon = "03d";
                        } else if (skyCode == 4) {
                            weatherMain = "흐림";
                            weatherDescription = "흐림";
                            weatherIcon = "04d";
                        }
                        break;
                    case "PTY": // 강수형태
                        int ptyCode = Integer.parseInt(fcstValue);
                        if (ptyCode == 1) {
                            weatherMain = "비";
                            weatherDescription = "비";
                            weatherIcon = "09d";
                        } else if (ptyCode == 2) {
                            weatherMain = "비/눈";
                            weatherDescription = "비/눈";
                            weatherIcon = "13d";
                        } else if (ptyCode == 3) {
                            weatherMain = "눈";
                            weatherDescription = "눈";
                            weatherIcon = "13d";
                        } else if (ptyCode == 4) {
                            weatherMain = "소나기";
                            weatherDescription = "소나기";
                            weatherIcon = "09d";
                        }
                        break;
                    case "RN1": // 1시간 강수량
                        precipitation = Double.parseDouble(fcstValue);
                        break;
                }
            }
        }
        
        // 체감온도 계산 (간단한 계산식)
        if (temperature != null && windSpeed != null) {
            feelsLike = temperature - (windSpeed * 0.5);
        } else {
            feelsLike = temperature;
        }
        
        // 날씨 데이터 생성
        return WeatherData.builder()
                .id(locationId + "_" + LocalDateTime.now())
                .locationId(locationId)
                .locationName(locationName)
                .temperature(temperature)
                .feelsLike(feelsLike)
                .humidity(humidity)
                .windSpeed(windSpeed)
                .windDirection(windDirection)
                .cloudiness(cloudiness)
                .precipitation(precipitation)
                .weatherMain(weatherMain)
                .weatherDescription(weatherDescription)
                .weatherIcon(weatherIcon)
                .pressure(pressure)
                .visibility(visibility)
                .observationTime(LocalDateTime.now())
                .lastUpdated(LocalDateTime.now())
                .build();
    }

    /**
     * API 응답에서 예보 데이터를 파싱합니다.
     */
    private List<ForecastData> parseForecastData(JsonNode items, double latitude, double longitude, int days) {
        List<ForecastData> forecastList = new ArrayList<>();
        String locationId = "loc_" + latitude + "_" + longitude;
        String locationName = getLocationNameByCoordinates(latitude, longitude);
        LocalDateTime now = LocalDateTime.now();
        
        // 중기예보 데이터 파싱
        if (items.isArray() && items.size() > 0) {
            JsonNode item = items.get(0);
            
            // 최대 days일까지의 예보 생성
            for (int i = 0; i < Math.min(days, 10); i++) {
                LocalDateTime forecastTime = now.plusDays(i);
                String dayKey = "rnSt" + (i + 3) + "Am"; // 강수확률 키 (3일 후부터 시작)
                String tempHighKey = "taMax" + (i + 3); // 최고기온 키
                String tempLowKey = "taMin" + (i + 3); // 최저기온 키
                
                // 해당 일자의 예보 데이터가 없으면 건너뜀
                if (!item.has(dayKey)) continue;
                
                Integer rainProbability = item.has(dayKey) ? item.path(dayKey).asInt() : null;
                Double tempHigh = item.has(tempHighKey) ? item.path(tempHighKey).asDouble() : null;
                Double tempLow = item.has(tempLowKey) ? item.path(tempLowKey).asDouble() : null;
                
                // 예보 데이터 생성
                ForecastData forecast = ForecastData.builder()
                        .id("daily_forecast_" + latitude + "_" + longitude + "_" + i)
                        .locationId(locationId)
                        .locationName(locationName)
                        .forecastTime(forecastTime)
                        .temperature((tempHigh + tempLow) / 2) // 평균 기온
                        .temperatureMax(tempHigh)
                        .temperatureMin(tempLow)
                        .rainProbability(rainProbability)
                        .weatherMain(getWeatherMainByRainProbability(rainProbability))
                        .weatherDescription(getWeatherDescriptionByRainProbability(rainProbability))
                        .weatherIcon(getWeatherIconByRainProbability(rainProbability))
                        .lastUpdated(LocalDateTime.now())
                        .build();
                
                forecastList.add(forecast);
            }
        }
        
        return forecastList;
    }

    /**
     * 강수확률에 따른 날씨 상태를 반환합니다.
     */
    private String getWeatherMainByRainProbability(Integer rainProbability) {
        if (rainProbability == null) return "맑음";
        if (rainProbability >= 60) return "비";
        if (rainProbability >= 30) return "구름많음";
        return "맑음";
    }

    /**
     * 강수확률에 따른 날씨 설명을 반환합니다.
     */
    private String getWeatherDescriptionByRainProbability(Integer rainProbability) {
        if (rainProbability == null) return "맑음";
        if (rainProbability >= 60) return "비가 내릴 확률이 높습니다";
        if (rainProbability >= 30) return "구름이 많고 비가 내릴 수 있습니다";
        return "맑은 날씨가 예상됩니다";
    }

    /**
     * 강수확률에 따른 날씨 아이콘을 반환합니다.
     */
    private String getWeatherIconByRainProbability(Integer rainProbability) {
        if (rainProbability == null) return "01d";
        if (rainProbability >= 60) return "09d";
        if (rainProbability >= 30) return "03d";
        return "01d";
    }

    /**
     * 좌표에 해당하는 위치 이름을 반환합니다.
     */
    private String getLocationNameByCoordinates(double latitude, double longitude) {
        // 실제 구현에서는 좌표를 기반으로 위치 이름을 조회하는 로직이 필요합니다
        // 여기서는 간단히 서울로 고정
        return "서울";
    }

    /**
     * 기상청 격자 좌표를 나타내는 내부 클래스
     */
    @lombok.Data
    private static class GridCoordinate {
        private final int x;
        private final int y;
    }
}


// ===================================

// 파일: backend/src/main/java/com/example/weather/config/CacheConfig.java
/**
 * 애플리케이션의 캐싱 설정을 담당하는 구성 클래스
 * 
 * <p>이 클래스는 Spring의 캐시 추상화 계층을 설정하고, Caffeine 캐시 구현체를 사용합니다.
 * Caffeine은 고성능 Java 캐싱 라이브러리로 Google Guava 캐시의 개선된 버전입니다.</p>
 * 
 * <p>주요 특징:</p>
 * <ul>
 *   <li>메모리 기반 캐시 설정</li>
 *   <li>캐시 만료 정책 설정 (TTL, 시간 기반 만료)</li>
/**
 * 애플리케이션의 캐싱 설정을 담당하는 구성 클래스
 * 
 * <p>이 클래스는 Spring의 캐시 추상화 계층을 설정하고, Caffeine 캐시 구현체를 사용합니다.
 * Caffeine은 고성능 Java 캐싱 라이브러리로 Google Guava 캐시의 개선된 버전입니다.</p>
 * 
 * <p>주요 특징:</p>
 * <ul>
 *   <li>메모리 기반 캐시 설정</li>
 *   <li>캐시 만료 정책 설정 (TTL, 시간 기반 만료)</li>
 *   <li>최대 캐시 항목 수 제한</li>
 *   <li>캐시 통계 활성화</li>
 * </ul>
 * 
 * <p>이 설정은 날씨 API 호출과 같은 자주 변경되지 않는 데이터를 캐싱하여
 * 외부 API 호출 횟수를 줄이고 응답 시간을 개선하는 데 사용됩니다.</p>
 * 
 * @author Nodove 개발팀
 * @version 1.0
 * @since 2023-06-01
 */
package com.example.weather.config;

import com.github.benmanes.caffeine.cache.Caffeine;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.cache.caffeine.CaffeineCacheManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.cache.caffeine.CaffeineCache;
import org.springframework.cache.support.SimpleCacheManager;

import java.util.Arrays;
import java.util.concurrent.TimeUnit;

@Configuration
@EnableCaching
public class CacheConfig {

    @Bean
    public CacheManager cacheManager() {
        SimpleCacheManager cacheManager = new SimpleCacheManager();
        cacheManager.setCaches(Arrays.asList(
            // 현재 날씨 데이터 캐시 (5분 TTL)
            new CaffeineCache("weatherData", 
                Caffeine.newBuilder()
                    .maximumSize(500)
                    .expireAfterWrite(5, TimeUnit.MINUTES)
                    .recordStats()
                    .build()),
                    
            // 일반 예보 데이터 캐시 (30분 TTL)
            new CaffeineCache("forecasts", 
                Caffeine.newBuilder()
                    .maximumSize(300)
                    .expireAfterWrite(30, TimeUnit.MINUTES)
                    .recordStats()
                    .build()),
                    
            // 시간별 예보 데이터 캐시 (15분 TTL)
            new CaffeineCache("hourlyForecasts", 
                Caffeine.newBuilder()
                    .maximumSize(200)
                    .expireAfterWrite(15, TimeUnit.MINUTES)
                    .recordStats()
                    .build()),
                    
            // 주간 예보 데이터 캐시 (1시간 TTL)
            new CaffeineCache("weeklyForecasts", 
                Caffeine.newBuilder()
                    .maximumSize(100)
                    .expireAfterWrite(1, TimeUnit.HOURS)
                    .recordStats()
                    .build()),
                    
            // 지역 날씨 데이터 캐시 (10분 TTL)
            new CaffeineCache("regionWeather", 
                Caffeine.newBuilder()
                    .maximumSize(50)
                    .expireAfterWrite(10, TimeUnit.MINUTES)
                    .recordStats()
                    .build())
        ));
        return cacheManager;
    }
}


// ===================================

// 파일: backend/src/main/java/com/example/weather/config/RestTemplateConfig.java
package com.example.weather.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.ClientHttpRequestFactory;
import org.springframework.http.client.SimpleClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;

@Configuration
public class RestTemplateConfig {

    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate(clientHttpRequestFactory());
    }

    private ClientHttpRequestFactory clientHttpRequestFactory() {
        SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();
        factory.setConnectTimeout(5000);
        factory.setReadTimeout(5000);
        return factory;
    }
}


// ===================================

// 파일: backend/src/main/java/com/example/weather/config/SwaggerConfig.java
// package com.example.weather.config;

// import org.springframework.beans.factory.annotation.Value;
// import org.springframework.context.annotation.Bean;
// import org.springframework.context.annotation.Configuration;

// import java.util.List;

// import io.swagger.v3.oas.models.OpenAPI;
// import io.swagger.v3.oas.models.info.Info;
// import io.swagger.v3.oas.models.info.License;

// @Configuration
// public class SwaggerConfig {

//     @Value("${server.servlet.context-path:}")
//     private String contextPath;

//     @Bean
//     public OpenAPI weatherOpenAPI() {
//         return new OpenAPI()
//                 .info(new Info()
//                         .title("날씨 API")
//                         .description("날씨 정보 및 예보 제공 API")
//                         .version("v1.0.0")
//                         .contact(new Contact()
//                                 .name("Nodove 개발팀")
//                                 .email("support@nodove.com")
//                                 .url("https://nodove.com")) 
//                         .license(new License()
//                                 .name("Apache 2.0")
//                                 .url("http://springdoc.org")))
//                 .servers(List.of(
//                         new Server().url(contextPath).description("현재 서버"),
//                         new Server().url("https://api.nodove.com").description("운영 서버")
//                 ));
//     }
// }


// ===================================

// 파일: backend/src/main/java/com/example/weather/config/WebConfig.java
        registry.addMapping("/api/**")
                .allowedOrigins("http://localhost:8081")
                .allowedMethods("GET", "POST", "PUT", "DELETE")
                .allowCredentials(true)
                .maxAge(3600);
    }
}
package com.example.weather.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
                .allowedOrigins("http://localhost:8081")
                .allowedMethods("GET", "POST", "PUT", "DELETE")
                .allowCredentials(true)
                .maxAge(3600);
    }
}


// ===================================

// 파일: backend/src/main/java/com/example/weather/controller/ForecastController.java
/**
 * 날씨 예보 API를 제공하는 컨트롤러
 * 
 * <p>이 컨트롤러는 시간별, 일별, 주간 예보 등 다양한 형태의 날씨 예보 정보를 제공하는 API를 포함합니다.</p>
 * 
 * @author Nodove 개발팀
 * @version 1.0
 * @since 2023-07-01
 */
    /**
package com.example.weather.controller;

import com.example.weather.model.ForecastResponse;
import com.example.weather.service.WeatherService;
import lombok.RequiredArgsConstructor;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

/**
 * 날씨 예보 API를 제공하는 컨트롤러
 * 
 * <p>이 컨트롤러는 시간별, 일별, 주간 예보 등 다양한 형태의 날씨 예보 정보를 제공하는 API를 포함합니다.</p>
 * 
 * @author Nodove 개발팀
 * @version 1.0
 * @since 2023-07-01
 */
@RestController
@RequestMapping("/api/forecast")
@RequiredArgsConstructor
public class ForecastController {

    private final WeatherService weatherService;

    /**
     * 특정 좌표에 대한 날씨 예보를 제공합니다.
     * 
     * @param lat 위도
     * @param lng 경도
     * @param days 예보 일수 (기본값: 5)
     * @return 날씨 예보 응답
     */
    @GetMapping
    @Cacheable(value = "forecasts", key = "{#lat, #lng, #days}")
    public ResponseEntity<ForecastResponse> getForecast(
            @RequestParam double lat,
            @RequestParam double lng,
            @RequestParam(defaultValue = "5") int days) {
        return ResponseEntity.ok(weatherService.getForecastByCoordinates(lat, lng, days));
    }

    /**
     * 시간별 날씨 예보를 제공합니다.
     * 
     * @param lat 위도
     * @param lng 경도
     * @param hours 예보 시간 (기본값: 24)
     * @return 시간별 날씨 예보 응답
     */
    @GetMapping("/hourly")
    @Cacheable(value = "hourlyForecasts", key = "{#lat, #lng, #hours}")
    public ResponseEntity<ForecastResponse> getHourlyForecast(
            @RequestParam double lat,
            @RequestParam double lng,
            @RequestParam(defaultValue = "24") int hours) {
        return ResponseEntity.ok(weatherService.getHourlyForecast(lat, lng, hours));
    }

    /**
     * 주간 날씨 예보를 제공합니다.
     * 
     * @param lat 위도
     * @param lng 경도
     * @return 주간 날씨 예보 응답
     */
    @GetMapping("/weekly")
    @Cacheable(value = "weeklyForecasts", key = "{#lat, #lng}")
    public ResponseEntity<ForecastResponse> getWeeklyForecast(
            @RequestParam double lat,
            @RequestParam double lng) {
        return ResponseEntity.ok(weatherService.getWeeklyForecast(lat, lng));
    }
}


// ===================================

// 파일: backend/src/main/java/com/example/weather/controller/WeatherController.java
package com.example.weather.controller;

import com.example.weather.model.RegionWeather;
import com.example.weather.model.WeatherResponse;
import com.example.weather.service.WeatherService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Flux;

import java.util.List;

@RestController
@RequestMapping("/api/weather")
@RequiredArgsConstructor
public class WeatherController {

    private final WeatherService weatherService;

    @GetMapping
    public ResponseEntity<WeatherResponse> getWeather(
            @RequestParam double lat,
            @RequestParam double lng) {
        return ResponseEntity.ok(weatherService.getWeatherByCoordinates(lat, lng));
    }

    @GetMapping("/current-temp")
    public ResponseEntity<Double> getCurrentTemp(
            @RequestParam double lat,
            @RequestParam double lng) {
        return ResponseEntity.ok(weatherService.getCurrentTemp(lat, lng));
    }

    @GetMapping("/rain-probability")
    public ResponseEntity<Integer> getRainProbability(
            @RequestParam double lat,
            @RequestParam double lng) {
        return ResponseEntity.ok(weatherService.getRainProbability(lat, lng));
    }

    @GetMapping("/wind")
    public ResponseEntity<Double> getWindSpeed(
            @RequestParam double lat,
            @RequestParam double lng) {
        return ResponseEntity.ok(weatherService.getWindSpeed(lat, lng));
    }

    @GetMapping("/regions")
    public ResponseEntity<List<RegionWeather>> getRegionWeather() {
        return ResponseEntity.ok(weatherService.getRegionWeather());
    }

    @GetMapping(value = "/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<WeatherResponse> streamWeather() {
        return weatherService.streamWeatherUpdates();
    }
}


// ===================================

// 파일: backend/src/main/java/com/example/weather/model/ForecastData.java
/**
 * 날씨 예보 데이터를 나타내는 엔티티 클래스
 * 
 * <p>이 클래스는 특정 위치의 미래 날씨 예보 정보를 저장합니다.
 * JPA 엔티티로 정의되어 있어 데이터베이스 테이블과 매핑됩니다.</p>
 * 
 * <p>포함된 예보 데이터:</p>
 * <ul>
 *   <li>기본 정보: 위치, 예보 시간</li>
 *   <li>기온 관련: 예상 기온, 최고/최저 기온</li>
/**
 * 날씨 예보 데이터를 나타내는 엔티티 클래스
 * 
 * <p>이 클래스는 특정 위치의 미래 날씨 예보 정보를 저장합니다.
 * JPA 엔티티로 정의되어 있어 데이터베이스 테이블과 매핑됩니다.</p>
 * 
 * <p>포함된 예보 데이터:</p>
 * <ul>
 *   <li>기본 정보: 위치, 예보 시간</li>
 *   <li>기온 관련: 예상 기온, 최고/최저 기온</li>
 *   <li>강수 관련: 강수 확률, 강수량</li>
 *   <li>기타 기상 요소: 습도, 풍속, 구름량 등</li>
 * </ul>
 * 
 * <p>이 엔티티는 일간/시간별 날씨 예보 API 응답 및 데이터베이스 저장에 사용됩니다.</p>
 * 
 * @author Nodove 개발팀
 * @version 1.0
 * @since 2023-07-01
 */
package com.example.weather.model;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import java.time.LocalDateTime;

/**
 * 날씨 예보 데이터를 저장하는 엔티티 클래스
 */
@Data               // Lombok: getter/setter, toString, equals, hashCode 자동 생성
@Entity             // JPA: 이 클래스가 데이터베이스 엔티티임을 나타냄
@Builder            // Lombok: 빌더 패턴 구현 자동 생성
@NoArgsConstructor  // Lombok: 파라미터 없는 기본 생성자 자동 생성
@AllArgsConstructor // Lombok: 모든 필드를 파라미터로 받는 생성자 자동 생성
@Table(name = "forecast_data") // JPA: 매핑될 데이터베이스 테이블 이름 지정
public class ForecastData {

    /**
     * 예보 데이터의 고유 식별자
     * 일반적으로 "{locationId}_{forecastTime}" 형식을 사용
     */
    @Id // JPA: 기본 키 필드로 지정
    private String id;
    
    /**
     * 날씨 예보가 속한 위치의
     * 고유 식별자 (예: "SEOUL_1", "BUSAN_2" 등)
     */
    private String locationId;
    
    /**
     * 위치의 이름 (예: "서울", "부산", "뉴욕" 등)
     */
    private String locationName;
    
    /**
     * 예보 시간 (이 시간에 대한 날씨 예보)
     */
    private LocalDateTime forecastTime;
    
    /**
     * 예상 기온 (섭씨 단위)
     */
    private Double temperature;
    
    /**
     * 체감 온도 (섭씨 단위)
     */
    private Double feelsLike;
    
    /**
     * 최저 기온 (섭씨 단위)
     */
    private Double temperatureMin;
    
    /**
     * 최고 기온 (섭씨 단위)
     */
    private Double temperatureMax;
    
    /**
     * 강수 확률 (백분율, 0-100)
     */
    private Integer rainProbability;
    
    /**
     * 강수량 (mm 단위, 예상 시간당)
     */
    private Double rainAmount;
    
    /**
     * 상대 습도 (백분율, 0-100)
     */
    private Integer humidity;
    
    /**
     * 기압 (hPa 단위)
     */
    private Double pressure;
    
    /**
     * 풍속 (m/s 단위)
     */
    private Double windSpeed;
    
    /**
     * 풍향 (도 단위, 0-359)
     */
    private Double windDirection;
    
    /**
     * 구름 양 (백분율, 0-100)
     */
    private Integer cloudiness;
    
    /**
     * 날씨 상태 주요 분류 (예: "Clear", "Rain", "Snow" 등)
     */
    private String weatherMain;
    
    /**
     * 날씨 상태 상세 설명
     */
    private String weatherDescription;
    
    /**
     * 날씨 아이콘 코드
     */
    private String weatherIcon;
    
    /**
     * 가시성 (미터 단위)
     */
    private Double visibility;
    
    /**
     * 자외선 지수 (0-11+)
     */
    private Double uvIndex;
    
    /**
     * 눈 량 (mm 단위, 물 상당량)
     */
    private Double snowAmount;
    
    /**
     * 예보가 마지막으로 업데이트된 시간
     */
    private LocalDateTime lastUpdated;
}


// ===================================

// 파일: backend/src/main/java/com/example/weather/model/ForecastResponse.java
/**
 * 날씨 예보 API 응답을 위한 DTO 클래스
 * 
 * <p>이 클래스는 클라이언트에게 날씨 예보 정보를 반환하기 위한 응답 객체입니다.
 * 여러 시간대의 예보 데이터와 함께 위치 정보 및 요약 정보를 포함합니다.</p>
 * 
 * @author Nodove 개발팀
 * @version 1.0
 * @since 2023-07-01
 */
/**
 * 날씨 예보 API 응답을 위한 DTO 클래스
 * 
 * <p>이 클래스는 클라이언트에게 날씨 예보 정보를 반환하기 위한 응답 객체입니다.
 * 여러 시간대의 예보 데이터와 함께 위치 정보 및 요약 정보를 포함합니다.</p>
 * 
 * @author Nodove 개발팀
 * @version 1.0
 * @since 2023-07-01
 */
package com.example.weather.model;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ForecastResponse {
    
    /**
     * 위치 식별자
     */
    private String locationId;
    
    /**
     * 위치 이름
     */
    private String locationName;
    
    /**
     * 위도
     */
    private Double latitude;
    
    /**
     * 경도
     */
    private Double longitude;
    
    /**
     * 시간별 예보 데이터 목록
     */
    private List<ForecastData> hourlyForecast;
    
    /**
     * 일별 예보 데이터 목록
     */
    private List<ForecastData> dailyForecast;
    
    /**
     * 예보 발표 시간
     */
    private LocalDateTime forecastTime;
    
    /**
     * 예보 유효 기간 (일 수)
     */
    private Integer forecastDays;
    
    /**
     * 데이터 제공자 정보
     */
    private String provider;
    
    /**
     * 마지막 업데이트 시간
     */
    private LocalDateTime lastUpdated;
}


// ===================================

// 파일: backend/src/main/java/com/example/weather/model/RegionWeather.java
package com.example.weather.model;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class RegionWeather {
    private String regionCode;
    private String regionName;
    private Double temperature;
    private Integer rainProbability;
    private Double windSpeed;
    private Double latitude;
    private Double longitude;
}


// ===================================

// 파일: backend/src/main/java/com/example/weather/model/WeatherData.java
/**
 * 날씨 데이터를 나타내는 엔티티 클래스
 * 
 * <p>이 클래스는 특정 위치의 날씨 상태를 나타내는 모든 관련 정보를 저장합니다.
 * JPA 엔티티로 정의되어 있어 데이터베이스 테이블과 매핑됩니다.</p>
 * 
 * <p>포함된 날씨 데이터:</p>
 * <ul>
 *   <li>기본 정보: 위치, 관측 시간</li>
 *   <li>기온 관련: 현재 기온, 체감 온도</li>
/**
 * 날씨 데이터를 나타내는 엔티티 클래스
 * 
 * <p>이 클래스는 특정 위치의 날씨 상태를 나타내는 모든 관련 정보를 저장합니다.
 * JPA 엔티티로 정의되어 있어 데이터베이스 테이블과 매핑됩니다.</p>
 * 
 * <p>포함된 날씨 데이터:</p>
 * <ul>
 *   <li>기본 정보: 위치, 관측 시간</li>
 *   <li>기온 관련: 현재 기온, 체감 온도</li>
 *   <li>습도 및 구름: 습도, 구름 양</li>
 *   <li>바람 관련: 풍속, 풍향</li>
 *   <li>기상 상태: 날씨 설명, 아이콘</li>
 *   <li>기타: 기압, 가시성, 일출/일몰 시간</li>
 * </ul>
 * 
 * <p>이 엔티티는 API 응답 및 데이터베이스 저장 둘 다에 사용됩니다.</p>
 * 
 * @author Nodove 개발팀
 * @version 1.0
 * @since 2023-05-01
 */
package com.example.weather.model;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import java.time.LocalDateTime;

/**
 * 날씨 데이터를 저장하는 엔티티 클래스
 */
@Data               // Lombok: getter/setter, toString, equals, hashCode 자동 생성
@Entity             // JPA: 이 클래스가 데이터베이스 엔티티임을 나타냄
@Builder            // Lombok: 빌더 패턴 구현 자동 생성
@NoArgsConstructor  // Lombok: 파라미터 없는 기본 생성자 자동 생성
@AllArgsConstructor // Lombok: 모든 필드를 파라미터로 받는 생성자 자동 생성
@Table(name = "weather_data") // JPA: 매핑될 데이터베이스 테이블 이름 지정
public class WeatherData {

    /**
     * 날씨 데이터의 고유 식별자
     * 일반적으로 "{locationId}_{timestamp}" 형식을 사용
     */
    @Id // JPA: 기본 키 필드로 지정
    private String id;
    
    /**
     * 날씨 데이터가 속한 위치의
     * 고유 식별자 (예: "SEOUL_1", "BUSAN_2" 등)
     */
    private String locationId;
    
    /**
     * 위치의 이름 (예: "서울", "부산", "뉴욕" 등)
     */
    private String locationName;
    
    /**
     * 현재 기온 (섭씨 단위)
     */
    private Double temperature;
    
    /**
     * 체감 온도 (섭씨 단위)
     * 기온, 습도, 풍속 등을 고려하여 계산된 값
     */
    private Double feelsLike;
    
    /**
     * 상대 습도 (백분율, 0-100)
     */
    private Integer humidity;
    
    /**
     * 풍속 (m/s 단위)
     */
    private Double windSpeed;
    
    /**
     * 풍향 (도 단위, 0-359)
     * 0은 북쪽, 90은 동쪽, 180은 남쪽, 270은 서쪽을 의미
     */
    private Double windDirection;
    
    /**
     * 구름 양 (백분율, 0-100)
     * 0은 맑음, 100은 완전히 흐림을 의미
     */
    private Integer cloudiness;
    
    /**
     * 강수량 (mm 단위, 지난 1시간)
     */
    private Double precipitation;
    
    /**
     * 날씨 상태 주요 분류 (예: "Clear", "Rain", "Snow" 등)
     * OpenWeatherMap API의 weather.main 필드에 해당
     */
    private String weatherMain;
    
    /**
     * 날씨 상태 상세 설명
     * OpenWeatherMap API의 weather.description 필드에 해당
     */
    private String weatherDescription;
    
    /**
     * 날씨 아이콘 코드
     * 프론트엔드에서 해당 날씨에 맞는 아이콘을 표시할 때 사용
     */
    private String weatherIcon;
    
    /**
     * 기압 (hPa 단위)
     */
    private Double pressure;
    
    /**
     * 가시성 (미터 단위)
     */
    private Double visibility;
    
    /**
     * 날씨 관측 시간
     */
    private LocalDateTime observationTime;
    
    /**
     * 일출 시간
     */
    private LocalDateTime sunriseTime;
    
    /**
     * 일몰 시간
     */
    private LocalDateTime sunsetTime;
    
    /**
     * 데이터가 마지막으로 업데이트된 시간
     * 캐시 관리 및 데이터 신선도 확인에 사용
     */
    private LocalDateTime lastUpdated;
}


// ===================================

// 파일: backend/src/main/java/com/example/weather/model/WeatherResponse.java
package com.example.weather.model;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class WeatherResponse {
    private Double temperature;
    private Integer rainProbability;
    private Double windSpeed;
    private String windDirection;
    private Double humidity;
    private String weatherCondition;
    private LocalDateTime timestamp;
    private String locationName;
    private Double latitude;
    private Double longitude;
}


// ===================================

// 파일: backend/src/main/java/com/example/weather/model/WeatherUpdateEvent.java
package com.example.weather.model;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class WeatherUpdateEvent {
    private String eventType;
    private WeatherResponse data;
    private LocalDateTime timestamp;
}


// ===================================

// 파일: backend/src/main/java/com/example/weather/service/exception/GlobalExceptionHandler.java
package com.example.weather.service.exception;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.server.ResponseStatusException;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(ResponseStatusException.class)
    public ResponseEntity<Map<String, Object>> handleResponseStatusException(ResponseStatusException ex) {
        Map<String, Object> body = new HashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", ex.getStatusCode().value());
        body.put("error", HttpStatus.valueOf(ex.getStatusCode().value()).getReasonPhrase());
        body.put("message", ex.getReason());
        
        return new ResponseEntity<>(body, ex.getStatusCode());
    }
    
    @ExceptionHandler(RuntimeException.class)
    public ResponseEntity<Map<String, Object>> handleRuntimeException(RuntimeException ex) {
        Map<String, Object> body = new HashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.INTERNAL_SERVER_ERROR.value());
        body.put("error", HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase());
        body.put("message", ex.getMessage());
        
        return new ResponseEntity<>(body, HttpStatus.INTERNAL_SERVER_ERROR);
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<Map<String, Object>> handleException(Exception ex) {
        Map<String, Object> body = new HashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.INTERNAL_SERVER_ERROR.value());
        body.put("error", HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase());
        body.put("message", "서버 내부 오류가 발생했습니다.");
        
        return new ResponseEntity<>(body, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}


// ===================================

// 파일: backend/src/main/java/com/example/weather/service/WeatherServiceImpl.java
    /**
     * WeatherData 객체를 WeatherResponse 객체로 변환합니다.
     */
    /**
     * 위치 ID에서 위도를 추출합니다.
     */
    /**
     * 위치 ID에서 경도를 추출합니다.
     */
    /**
package com.example.weather.service;

import com.example.weather.client.KmaApiClient;
import com.example.weather.model.ForecastData;
import com.example.weather.model.ForecastResponse;
import com.example.weather.model.RegionWeather;
import com.example.weather.model.WeatherData;
import com.example.weather.model.WeatherResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.web.server.ResponseStatusException;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Sinks;

import java.time.Duration;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@Slf4j
@Service
@RequiredArgsConstructor
public class WeatherServiceImpl implements WeatherService {

    private final KmaApiClient kmaApiClient;
    
    // SSE를 위한 Sink 생성
    private final Sinks.Many<WeatherResponse> weatherSink = Sinks.many().multicast().onBackpressureBuffer();

    @Override
    @Cacheable(value = "weatherData", key = "#latitude + '-' + #longitude")
    public WeatherResponse getWeatherByCoordinates(double latitude, double longitude) {
        try {
            // 공공데이터 포털 API 호출
            WeatherData weatherData = kmaApiClient.getCurrentWeather(latitude, longitude);
            
            // WeatherResponse 객체로 변환
            return convertToWeatherResponse(weatherData);
        } catch (Exception e) {
            log.error("날씨 데이터 조회 중 오류 발생", e);
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "날씨 데이터를 가져오는 중 오류가 발생했습니다.", e);
        }
    }

    @Override
    @Cacheable(value = "temperatureData", key = "#latitude + '-' + #longitude")
    public Double getCurrentTemp(double latitude, double longitude) {
        return getWeatherByCoordinates(latitude, longitude).getTemperature();
    }

    @Override
    @Cacheable(value = "rainData", key = "#latitude + '-' + #longitude")
    public Integer getRainProbability(double latitude, double longitude) {
        return getWeatherByCoordinates(latitude, longitude).getRainProbability();
    }

    @Override
    @Cacheable(value = "windData", key = "#latitude + '-' + #longitude")
    public Double getWindSpeed(double latitude, double longitude) {
        return getWeatherByCoordinates(latitude, longitude).getWindSpeed();
    }

    @Override
    @Cacheable(value = "regionWeatherData")
    public List<RegionWeather> getRegionWeather() {
        List<RegionWeather> regions = new ArrayList<>();
        
        // 주요 도시 좌표
        regions.add(createRegionWeather("11", "서울", 37.5665, 126.9780));
        regions.add(createRegionWeather("21", "부산", 35.1796, 129.0756));
        regions.add(createRegionWeather("22", "인천", 37.4563, 126.7052));
        regions.add(createRegionWeather("23", "대구", 35.8714, 128.6014));
        regions.add(createRegionWeather("24", "광주", 35.1595, 126.8526));
        regions.add(createRegionWeather("25", "대전", 36.3504, 127.3845));
        
        return regions;
    }

    @Override
    public Flux<WeatherResponse> streamWeatherUpdates() {
        return weatherSink.asFlux()
                .mergeWith(Flux.interval(Duration.ofSeconds(10))
                        .map(tick -> {
                            WeatherResponse update = getWeatherByCoordinates(37.5665, 126.9780);
                            weatherSink.tryEmitNext(update);
                            return update;
                        }));
    }

    @Override
    public ForecastResponse getHourlyForecast(double latitude, double longitude, int hours) {
        try {
            // 공공데이터 포털 API는 시간별 예보를 제공하지 않으므로
            // 일별 예보를 시간별로 세분화하여 제공
            List<ForecastData> dailyForecast = kmaApiClient.getForecast(latitude, longitude, 3);
            List<ForecastData> hourlyForecast = new ArrayList<>();
            
            // 일별 예보를 시간별로 세분화
            LocalDateTime now = LocalDateTime.now();
            for (int i = 0; i < hours; i++) {
                LocalDateTime forecastTime = now.plusHours(i);
                
                // 해당 시간이 속한 일자의 예보 찾기
                ForecastData dailyData = dailyForecast.stream()
                        .filter(data -> data.getForecastTime().toLocalDate().equals(forecastTime.toLocalDate()))
                        .findFirst()
                        .orElse(null);
                
                if (dailyData != null) {
                    // 시간별 예보 생성
                    ForecastData hourlyData = ForecastData.builder()
                            .id("hourly_forecast_" + latitude + "_" + longitude + "_" + i)
                            .locationId(dailyData.getLocationId())
                            .locationName(dailyData.getLocationName())
                            .forecastTime(forecastTime)
                            .temperature(adjustTemperatureByHour(dailyData.getTemperature(), forecastTime.getHour()))
                            .feelsLike(adjustTemperatureByHour(dailyData.getTemperature(), forecastTime.getHour()) - 2)
                            .rainProbability(dailyData.getRainProbability())
                            .rainAmount(dailyData.getRainAmount())
                            .humidity(dailyData.getHumidity())
                            .pressure(dailyData.getPressure())
                            .windSpeed(dailyData.getWindSpeed())
                            .windDirection(dailyData.getWindDirection())
                            .cloudiness(dailyData.getCloudiness())
                            .weatherMain(dailyData.getWeatherMain())
                            .weatherDescription(dailyData.getWeatherDescription())
                            .weatherIcon(dailyData.getWeatherIcon())
                            .visibility(dailyData.getVisibility())
                            .lastUpdated(LocalDateTime.now())
                            .build();
                    
                    hourlyForecast.add(hourlyData);
                }
            }
            
            return ForecastResponse.builder()
                .locationId("loc_" + latitude + "_" + longitude)
                .locationName(hourlyForecast.isEmpty() ? "알 수 없음" : hourlyForecast.get(0).getLocationName())
                .latitude(latitude)
                .longitude(longitude)
                .hourlyForecast(hourlyForecast)
                .forecastTime(LocalDateTime.now())
                .provider("기상청")
                .lastUpdated(LocalDateTime.now())
                .build();
        } catch (Exception e) {
            log.error("시간별 예보 조회 중 오류 발생", e);
            throw new RuntimeException("시간별 날씨 예보 데이터를 가져오는 중 오류가 발생했습니다.", e);
        }
    }
    
    @Override
    public ForecastResponse getWeeklyForecast(double latitude, double longitude) {
        return getForecastByCoordinates(latitude, longitude, 7);
    }
    
    @Override
    public ForecastResponse getForecastByCoordinates(double latitude, double longitude, int days) {
        try {
            // 공공데이터 포털 API 호출
            List<ForecastData> dailyForecast = kmaApiClient.getForecast(latitude, longitude, days);
            
            return ForecastResponse.builder()
                .locationId("loc_" + latitude + "_" + longitude)
                .locationName(dailyForecast.isEmpty() ? "알 수 없음" : dailyForecast.get(0).getLocationName())
                .latitude(latitude)
                .longitude(longitude)
                .dailyForecast(dailyForecast)
                .forecastDays(days)
                .forecastTime(LocalDateTime.now())
                .provider("기상청")
                .lastUpdated(LocalDateTime.now())
                .build();
        } catch (Exception e) {
            log.error("일별 예보 조회 중 오류 발생", e);
            throw new RuntimeException("주간 날씨 예보 데이터를 가져오는 중 오류가 발생했습니다.", e);
        }
    }
    
    /**
     * WeatherData 객체를 WeatherResponse 객체로 변환합니다.
     */
    private WeatherResponse convertToWeatherResponse(WeatherData weatherData) {
        return WeatherResponse.builder()
                .temperature(weatherData.getTemperature())
                .rainProbability(calculateRainProbability(weatherData))
                .windSpeed(weatherData.getWindSpeed())
                .windDirection(convertWindDirectionToText(weatherData.getWindDirection()))
                .humidity(weatherData.getHumidity() != null ? weatherData.getHumidity().doubleValue() : null)
                .weatherCondition(weatherData.getWeatherMain())
                .timestamp(weatherData.getObservationTime())
                .locationName(weatherData.getLocationName())
                .latitude(extractLatitude(weatherData.getLocationId()))
                .longitude(extractLongitude(weatherData.getLocationId()))
                .build();
    }
    
    /**
     * 위치 ID에서 위도를 추출합니다.
     */
    private Double extractLatitude(String locationId) {
        if (locationId == null || !locationId.startsWith("loc_")) return null;
        
        String[] parts = locationId.substring(4).split("_");
        if (parts.length >= 2) {
            try {
                return Double.parseDouble(parts[0]);
            } catch (NumberFormatException e) {
                return null;
            }
        }
        return null;
    }
    
    /**
     * 위치 ID에서 경도를 추출합니다.
     */
    private Double extractLongitude(String locationId) {
        if (locationId == null || !locationId.startsWith("loc_")) return null;
        
        String[] parts = locationId.substring(4).split("_");
        if (parts.length >= 2) {
            try {
                return Double.parseDouble(parts[1]);
            } catch (NumberFormatException e) {
                return null;
            }
        }
        return null;
    }
    
    /**
     * 풍향 각도를 텍스트로 변환합니다.
     */
    private String convertWindDirectionToText(Double windDirection) {
        if (windDirection == null) return "알 수 없음";
        
        if (windDirection >= 337.5 || windDirection < 22.5) return "북";
        if (windDirection >= 22.5 && windDirection < 67.5) return "북동";
        if (windDirection >= 67.5 && windDirection < 112.5) return "동";
        if (windDirection >= 112.5 && windDirection < 157.5) return "남동";
        if (windDirection >= 157.5 && windDirection < 202.5) return "남";
        if (windDirection >= 202.5 && windDirection < 247.5) return "남서";
        if (windDirection >= 247.5 && windDirection < 292.5) return "서";
        if (windDirection >= 292.5 && windDirection < 337.5) return "북서";
        
        return "알 수 없음";
    }
    
    /**
     * 강수 확률을 계산합니다.
     */
    private Integer calculateRainProbability(WeatherData weatherData) {
        // 날씨 상태에 따른 강수 확률 추정
        if (weatherData.getWeatherMain() == null) return 0;
        
        switch (weatherData.getWeatherMain()) {
            case "비":
            case "소나기":
                return 90;
            case "비/눈":
                return 80;
            case "눈":
                return 70;
            case "흐림":
                return 40;
            case "구름많음":
                return 20;
            case "맑음":
            default:
                return 0;
        }
    }
    
    /**
     * 시간에 따라 기온을 조정합니다.
     */
    private Double adjustTemperatureByHour(Double baseTemp, int hour) {
        if (baseTemp == null) return null;
        
        // 시간대별 기온 변화 패턴 적용
        if (hour >= 0 && hour < 6) {
            return baseTemp - 2.0; // 새벽: 기본 기온보다 낮음
        } else if (hour >= 6 && hour < 12) {
            return baseTemp + (hour - 6) * 0.5; // 오전: 점점 상승
        } else if (hour >= 12 && hour < 18) {
            return baseTemp + 3.0 - (hour - 12) * 0.2; // 오후: 점점 하강
        } else {
            return baseTemp - 1.0 - (hour - 18) * 0.2; // 저녁: 계속 하강
        }
    }
    
    /**
     * 지역 날씨 정보를 생성합니다.
     */
    private RegionWeather createRegionWeather(String code, String name, double lat, double lng) {
        try {
            WeatherResponse weather = getWeatherByCoordinates(lat, lng);
            
            return RegionWeather.builder()
                    .regionCode(code)
                    .regionName(name)
                    .temperature(weather.getTemperature())
                    .rainProbability(weather.getRainProbability())
                    .windSpeed(weather.getWindSpeed())
                    .latitude(lat)
                    .longitude(lng)
                    .build();
        } catch (Exception e) {
            log.error("지역 날씨 정보 생성 중 오류 발생", e);
            
            // 오류 발생 시 기본 데이터 반환
            return RegionWeather.builder()
                    .regionCode(code)
                    .regionName(name)
                    .temperature(20.0)
                    .rainProbability(0)
                    .windSpeed(2.0)
                    .latitude(lat)
                    .longitude(lng)
                    .build();
        }
    }
}


// ===================================

// 파일: backend/src/main/java/com/example/weather/service/WeatherService.java
    /**
     * 특정 좌표에 대한 날씨 예보를 조회합니다.
     * 
     * @param latitude 위도
     * @param longitude 경도
     * @param days 예보 일수 (1-7)
     * @return 날씨 예보 응답 객체
     */
    /**
     * 특정 좌표에 대한 시간별 예보를 조회합니다.
package com.example.weather.service;

import com.example.weather.model.ForecastResponse;
import com.example.weather.model.RegionWeather;
import com.example.weather.model.WeatherResponse;
import reactor.core.publisher.Flux;

import java.util.List;

public interface WeatherService {
    
    WeatherResponse getWeatherByCoordinates(double latitude, double longitude);
    
    Double getCurrentTemp(double latitude, double longitude);
    
    Integer getRainProbability(double latitude, double longitude);
    
    Double getWindSpeed(double latitude, double longitude);
    
    List<RegionWeather> getRegionWeather();
    
    Flux<WeatherResponse> streamWeatherUpdates();
    
    /**
     * 특정 좌표에 대한 날씨 예보를 조회합니다.
     * 
     * @param latitude 위도
     * @param longitude 경도
     * @param days 예보 일수 (1-7)
     * @return 날씨 예보 응답 객체
     */
    ForecastResponse getForecastByCoordinates(double latitude, double longitude, int days);
    
    /**
     * 특정 좌표에 대한 시간별 예보를 조회합니다.
     * 
     * @param latitude 위도
     * @param longitude 경도
     * @param hours 예보 시간 (1-48)
     * @return 날씨 예보 응답 객체
     */
    ForecastResponse getHourlyForecast(double latitude, double longitude, int hours);
    
    /**
     * 특정 좌표에 대한 주간 예보를 조회합니다.
     * 
     * @param latitude 위도
     * @param longitude 경도
     * @return 날씨 예보 응답 객체
     */
    ForecastResponse getWeeklyForecast(double latitude, double longitude);
}


// ===================================

// 파일: backend/src/main/java/com/example/weather/WeatherApplication.java
package com.example.weather;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableCaching
@EnableScheduling
public class WeatherApplication {

    public static void main(String[] args) {
        SpringApplication.run(WeatherApplication.class, args);
    }
}


// ===================================

